{
  "task_id": "taco_16916",
  "entry_point": "find_lexicographically_smallest_permutation",
  "mutant_count": 169,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "length = last - first",
      "mutated_line": "length = last + first",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last + first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "length = last - first",
      "mutated_line": "length = last * first",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last * first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length < 2:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length < 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length > 2:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length > 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length == 2:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length == 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first <= 10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first <= 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first >= 10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first >= 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first != 10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first != 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) / 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) / 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) * 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) * 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "first_len = middle - first",
      "mutated_line": "first_len = middle + first",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle + first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "first_len = middle - first",
      "mutated_line": "first_len = middle * first",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle * first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "head1 = 0",
      "mutated_line": "head1 = 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 1\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "head1 = 0",
      "mutated_line": "head1 = -1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = -1\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "head1 = 0",
      "mutated_line": "head1 = 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 1\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p + 1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p + 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p * 1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p * 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sort_merge(K, q, 0, N)",
      "mutated_line": "sort_merge(K, q, 1, N)",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 1, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sort_merge(K, q, 0, N)",
      "mutated_line": "sort_merge(K, q, -1, N)",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, -1, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sort_merge(K, q, 0, N)",
      "mutated_line": "sort_merge(K, q, 1, N)",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 1, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p - 1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p - 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p * 1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p * 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length <= 3:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 3:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length <= 1:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 1:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length <= 0:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 0:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length <= 1:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 1:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length <= 2:",
      "mutated_line": "if length <= -2:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= -2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 or data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 or data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first - 1, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first - 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first * 1, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first * 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last + first < 10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last + first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last * first < 10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last * first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first < 11:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 11:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first < 9:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 9:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first < 0:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 0:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first < 1:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 1:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if last - first < 10:",
      "mutated_line": "if last - first < -10:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < -10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first - last) // 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first - last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = first * last // 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = first * last // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) // 3",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 3\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) // 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 1\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) // 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 0\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) // 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 1\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "middle = (first + last) // 2",
      "mutated_line": "middle = (first + last) // -2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // -2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) + 2, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) + 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) * 2, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) * 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, +1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, +1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -1, +1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, +1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if head1 == first_len or head2 == last:",
      "mutated_line": "if head1 == first_len and head2 == last:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len and head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p - 2 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 2 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p - 0 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 0 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p - 0 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 0 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "P = [p - 1 for p in P]",
      "mutated_line": "P = [p - -1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - -1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p + 2 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 2 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p + 0 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 0 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p + 0 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 0 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return [p + 1 for p in P]",
      "mutated_line": "return [p + -1 for p in P]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + -1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length != 2 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length != 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 1] > k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] > k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 1] < k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] < k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 1] == k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] == k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first + 2, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 2, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first + 0, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 0, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first + 0, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 0, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(first + 1, last):",
      "mutated_line": "for i in range(first + -1, last):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + -1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i + 1, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i + 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i * 1, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i * 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first + 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first + 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first * 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first * 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 1, +1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, +1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if data[t] - v < k:",
      "mutated_line": "if data[t] - v <= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v <= k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if data[t] - v < k:",
      "mutated_line": "if data[t] - v >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v >= k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if data[t] - v < k:",
      "mutated_line": "if data[t] - v != k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v != k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t -= 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 3, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 3, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 1, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 1, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 0, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 0, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 1, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 1, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - -2, -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - -2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -2, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -2, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -0, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -0, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -0, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -0, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, --1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, --1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -1, -2):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -2):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -1, -0):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -0):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -1, -0):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -0):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(len(bounds) - 2, -1, -1):",
      "mutated_line": "for i in range(len(bounds) - 2, -1, --1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, --1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if head1 == first_len or head2 == last:",
      "mutated_line": "if head1 != first_len or head2 == last:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 != first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if head1 == first_len or head2 == last:",
      "mutated_line": "if head1 == first_len or head2 != last:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 != last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif bounds[head1] - data[head2] >= k:",
      "mutated_line": "elif bounds[head1] - data[head2] > k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] > k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif bounds[head1] - data[head2] >= k:",
      "mutated_line": "elif bounds[head1] - data[head2] < k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] < k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif bounds[head1] - data[head2] >= k:",
      "mutated_line": "elif bounds[head1] - data[head2] == k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] == k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "head2 += 1",
      "mutated_line": "head2 -= 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 -= 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "head1 += 1",
      "mutated_line": "head1 -= 1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 -= 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 3 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 3 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 1 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 1 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 0 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 0 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 1 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 1 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == -2 and data[first] - data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == -2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] + data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] + data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] * data[first + 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] * data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 2, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 2, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 0, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 0, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 0, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 0, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - -1, first - 1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - -1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 2, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 2, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 0, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 0, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 0, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 0, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - -1, -1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - -1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 1, -2):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -2):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 1, -0):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -0):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 1, -0):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -0):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for t in range(i - 1, first - 1, -1):",
      "mutated_line": "for t in range(i - 1, first - 1, --1):",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, --1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if data[t] - v < k:",
      "mutated_line": "if data[t] + v < k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] + v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if data[t] - v < k:",
      "mutated_line": "if data[t] * v < k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] * v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 2\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 0\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 0\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += -1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t - 1:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t - 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t * 1:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t * 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i - 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i - 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i * 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i * 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i - 1], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i - 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i * 1], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i * 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "elif bounds[head1] - data[head2] >= k:",
      "mutated_line": "elif bounds[head1] + data[head2] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] + data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "elif bounds[head1] - data[head2] >= k:",
      "mutated_line": "elif bounds[head1] * data[head2] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] * data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "head2 += 1",
      "mutated_line": "head2 += 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 2\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "head2 += 1",
      "mutated_line": "head2 += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 0\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "head2 += 1",
      "mutated_line": "head2 += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 0\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "head2 += 1",
      "mutated_line": "head2 += -1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += -1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "head1 += 1",
      "mutated_line": "head1 += 2",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 2\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "head1 += 1",
      "mutated_line": "head1 += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 0\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "head1 += 1",
      "mutated_line": "head1 += 0",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 0\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "head1 += 1",
      "mutated_line": "head1 += -1",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += -1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first - 1]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first - 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first * 1]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first * 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first - 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first - 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first * 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first * 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 2:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 2:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 0:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 0:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 0:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 0:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + -1:i + 1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + -1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i + 2] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 2] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i + 0] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 0] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i + 0] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 0] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data[t + 1:i + 1] = data[t:i]",
      "mutated_line": "data[t + 1:i + -1] = data[t:i]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + -1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i + 2], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 2], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i + 0], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 0], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i + 0], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 0], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bounds[i] = min(bounds[i + 1], bounds[i])",
      "mutated_line": "bounds[i] = min(bounds[i + -1], bounds[i])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + -1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "data[ohead:ohead + first_len - head1] = tmp[head1:first_len]",
      "mutated_line": "data[ohead:ohead + first_len + head1] = tmp[head1:first_len]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len + head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "data[ohead:ohead + first_len - head1] = tmp[head1:first_len]",
      "mutated_line": "data[ohead:(ohead + first_len) * head1] = tmp[head1:first_len]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:(ohead + first_len) * head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first - 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first - 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first * 1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first * 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 2]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 2]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 0]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 0]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 0]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 0]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + -1]) = (data[first + 1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + -1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first + 2], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 2], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first + 0], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 0], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first + 0], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 0], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(data[first], data[first + 1]) = (data[first + 1], data[first])",
      "mutated_line": "(data[first], data[first + 1]) = (data[first + -1], data[first])",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + -1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "data[ohead:ohead + first_len - head1] = tmp[head1:first_len]",
      "mutated_line": "data[ohead:ohead - first_len - head1] = tmp[head1:first_len]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead - first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "data[ohead:ohead + first_len - head1] = tmp[head1:first_len]",
      "mutated_line": "data[ohead:ohead * first_len - head1] = tmp[head1:first_len]",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead * first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 2] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 2] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 0] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 0] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + 0] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + 0] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if length == 2 and data[first] - data[first + 1] >= k:",
      "mutated_line": "if length == 2 and data[first] - data[first + -1] >= k:",
      "code": "def find_lexicographically_smallest_permutation(N, K, P):\n\n    def invert(p, q):\n        for (i, pi) in enumerate(p):\n            q[pi] = i\n\n    def sort_insertion(k, data, first, last):\n        length = last - first\n        if length <= 2:\n            if length == 2 and data[first] - data[first + -1] >= k:\n                (data[first], data[first + 1]) = (data[first + 1], data[first])\n            return\n        for i in range(first + 1, last):\n            v = data[i]\n            for t in range(i - 1, first - 1, -1):\n                if data[t] - v < k:\n                    t += 1\n                    break\n            data[t + 1:i + 1] = data[t:i]\n            data[t] = v\n\n    def sort_merge(k, data, first, last):\n        if last - first < 10:\n            sort_insertion(k, data, first, last)\n            return\n        middle = (first + last) // 2\n        sort_merge(k, data, first, middle)\n        sort_merge(k, data, middle, last)\n        bounds = data[first:middle]\n        for i in range(len(bounds) - 2, -1, -1):\n            bounds[i] = min(bounds[i + 1], bounds[i])\n        tmp = data[first:middle]\n        first_len = middle - first\n        head1 = 0\n        head2 = middle\n        for ohead in range(first, last):\n            if head1 == first_len or head2 == last:\n                data[ohead:ohead + first_len - head1] = tmp[head1:first_len]\n                return\n            elif bounds[head1] - data[head2] >= k:\n                data[ohead] = data[head2]\n                head2 += 1\n            else:\n                data[ohead] = tmp[head1]\n                head1 += 1\n    P = [p - 1 for p in P]\n    q = list(P)\n    invert(P, q)\n    sort_merge(K, q, 0, N)\n    invert(q, P)\n    return [p + 1 for p in P]"
    }
  ]
}