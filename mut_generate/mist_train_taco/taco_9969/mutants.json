{
  "task_id": "taco_9969",
  "entry_point": "calculate_minimum_time",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x2 < x1:",
      "mutated_line": "if x2 <= x1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 <= x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x2 < x1:",
      "mutated_line": "if x2 >= x1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 >= x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x2 < x1:",
      "mutated_line": "if x2 != x1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 != x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if c_e != 0:",
      "mutated_line": "if c_e == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e == 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 += 1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 += 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c_l != 0:",
      "mutated_line": "if c_l == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l == 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 += 1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 += 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if y1 == y2:",
      "mutated_line": "if y1 != y2:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 != y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 = float('inf')",
      "mutated_line": "t1 = float('')",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 = float('inf')",
      "mutated_line": "t2 = float('')",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if c_e != 0:",
      "mutated_line": "if c_e != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 1:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if c_e != 0:",
      "mutated_line": "if c_e != -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != -1:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if c_e != 0:",
      "mutated_line": "if c_e != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 1:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if ind1 == c_e:",
      "mutated_line": "if ind1 != c_e:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 != c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 += 1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 += 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) - math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) - math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = (abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2)) * math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = (abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2)) * math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 2",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 2\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 0\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 0\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= -1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= -1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 > 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 > 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 < 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 < 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 == 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c_l != 0:",
      "mutated_line": "if c_l != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 1:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c_l != 0:",
      "mutated_line": "if c_l != -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != -1:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c_l != 0:",
      "mutated_line": "if c_l != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 1:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ind3 == c_l:",
      "mutated_line": "if ind3 != c_l:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 != c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 += 1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 += 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) - abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) - abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = (abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2)) * abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = (abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2)) * abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 2",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 2\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 0\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 0\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= -1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= -1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 > 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 > 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 < 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 < 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 == 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 0 or c_l != 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 or c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 2",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 2\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 0\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 0\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind1 -= 1",
      "mutated_line": "ind1 -= -1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= -1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) - abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) - abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) * abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) * abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 >= 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 1:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 >= -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= -1:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if ind1 >= 0:",
      "mutated_line": "if ind1 >= 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 1:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 2",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 2\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 0\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= 0",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 0\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ind3 -= 1",
      "mutated_line": "ind3 -= -1",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= -1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) - abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) - abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) * abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) * abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 >= 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 1:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 >= -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= -1:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ind3 >= 0:",
      "mutated_line": "if ind3 >= 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 1:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e == 0 and c_l != 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e == 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 0 and c_l == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l == 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif c_e != 0:",
      "mutated_line": "elif c_e == 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e == 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) * v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) * v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) // v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) // v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) - math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) - math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, (abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2)) * math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, (abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2)) * math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 + y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 + y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 * y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 * y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) - abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) - abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, (abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2)) * abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, (abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2)) * abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "results.append(abs(x2 - x1))",
      "mutated_line": "results.append(abs(x2 + x1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 + x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "results.append(abs(x2 - x1))",
      "mutated_line": "results.append(abs(x2 * x1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 * x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 1 and c_l != 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 1 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != -1 and c_l != 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != -1 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 1 and c_l != 0:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 1 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 0 and c_l != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 1:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 0 and c_l != -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != -1:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif c_e != 0 and c_l != 0:",
      "mutated_line": "elif c_e != 0 and c_l != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 1:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif c_e != 0:",
      "mutated_line": "elif c_e != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 1:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif c_e != 0:",
      "mutated_line": "elif c_e != -1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != -1:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif c_e != 0:",
      "mutated_line": "elif c_e != 1:",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 1:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 + elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 + elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 * elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 * elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] + x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] + x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] * x2) + math.ceil(abs(y2 - y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] * x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) - abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) - abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) * abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) * abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 + stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 + stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 * stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 * stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] + x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] + x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)",
      "mutated_line": "t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] * x2) + abs(y2 - y1)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] * x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) - abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) - abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) * abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) * abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 + y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 + y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)",
      "mutated_line": "t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 * y1) / v)",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 * y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) * v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) * v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) // v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) // v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 + y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 + y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 * y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 * y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 + elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 + elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 * elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 * elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] + x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] + x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] * x2) + math.ceil(abs(y2 - y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] * x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 + stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 + stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 * stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 * stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] + x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] + x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))",
      "mutated_line": "t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] * x2) + abs(y2 - y1))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] * x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 + y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 + y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v))",
      "mutated_line": "t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 * y1) / v))",
      "code": "import bisect\nimport math\n\ndef calculate_minimum_time(n, m, c_l, c_e, v, stairs_positions, elevators_positions, queries):\n    results = []\n    for (y1, x1, y2, x2) in queries:\n        if x2 < x1:\n            (x1, x2) = (x2, x1)\n        t1 = float('inf')\n        t2 = float('inf')\n        if c_e != 0:\n            ind1 = bisect.bisect_left(elevators_positions, x1)\n            if ind1 == c_e:\n                ind1 -= 1\n            t1 = abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 - y1) / v)\n            ind1 -= 1\n            if ind1 >= 0:\n                t1 = min(t1, abs(x1 - elevators_positions[ind1]) + abs(elevators_positions[ind1] - x2) + math.ceil(abs(y2 * y1) / v))\n        if c_l != 0:\n            ind3 = bisect.bisect_left(stairs_positions, x1)\n            if ind3 == c_l:\n                ind3 -= 1\n            t2 = abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1)\n            ind3 -= 1\n            if ind3 >= 0:\n                t2 = min(t2, abs(x1 - stairs_positions[ind3]) + abs(stairs_positions[ind3] - x2) + abs(y2 - y1))\n        if y1 == y2:\n            results.append(abs(x2 - x1))\n        elif c_e != 0 and c_l != 0:\n            results.append(min(t1, t2))\n        elif c_e != 0:\n            results.append(t1)\n        else:\n            results.append(t2)\n    return results"
    }
  ]
}