{
  "task_id": "taco_7849",
  "entry_point": "find_longest_palindromic_substring",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sep = '|'",
      "mutated_line": "sep = ''",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = ''\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "t = sep + sep.join(s) + sep",
      "mutated_line": "t = sep + sep.join(s) - sep",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) - sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "t = sep + sep.join(s) + sep",
      "mutated_line": "t = (sep + sep.join(s)) * sep",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = (sep + sep.join(s)) * sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 1\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = -1\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 1\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 1\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = -1\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 1\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return \"\"",
      "mutated_line": "return 'MUTATED'",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return 'MUTATED'\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "t = sep + sep.join(s) + sep",
      "mutated_line": "t = sep - sep.join(s) + sep",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep - sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "t = sep + sep.join(s) + sep",
      "mutated_line": "t = sep * sep.join(s) + sep",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep * sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span or t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span or t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "span += 1",
      "mutated_line": "span -= 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span -= 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i + span > r:",
      "mutated_line": "if i + span >= r:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span >= r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i + span > r:",
      "mutated_line": "if i + span <= r:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span <= r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i + span > r:",
      "mutated_line": "if i + span != r:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span != r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, 'MUTATED')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, 'MUTATED')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i <= r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i <= r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i >= r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i >= r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i != r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i != r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 1\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else -1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else -1\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 1\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span < i < len(t) - span and t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span < i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span > i < len(t) - span and t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span > i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span == i < len(t) - span and t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span == i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span and t[i - span] != t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] != t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "span += 1",
      "mutated_line": "span += 2",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 2\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "span += 1",
      "mutated_line": "span += 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 0\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "span += 1",
      "mutated_line": "span += 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 0\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "span += 1",
      "mutated_line": "span += -1",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += -1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i + span > r:",
      "mutated_line": "if i - span > r:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i - span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i + span > r:",
      "mutated_line": "if i * span > r:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i * span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i + 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i + 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], (r - i) * 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], (r - i) * 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) + span and t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) + span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) * span and t[i - span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) * span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r, c = i + span, i",
      "mutated_line": "(r, c) = (i - span, i)",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i - span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r, c = i + span, i",
      "mutated_line": "(r, c) = (i * span, i)",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i * span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c + i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c + i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c * i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c * i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r + i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r + i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r * i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r * i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 2) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 2) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 0) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 0) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - 0) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 0) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 * c - i], r - i - -1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - -1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span and t[i + span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i + span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span and t[i * span] == t[i + span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i * span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span and t[i - span] == t[i - span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i - span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "while span <= i < len(t) - span and t[i - span] == t[i + span]:",
      "mutated_line": "while span <= i < len(t) - span and t[i - span] == t[i * span]:",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i * span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span - 1:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span - 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[(middle - span) * 1:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[(middle - span) * 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 1:middle - span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle - span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 1:middle * span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle * span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 / c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 / c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 + c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 + c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[2 ** c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 ** c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle + span + 1:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle + span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle * span + 1:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle * span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 2:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 2:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 0:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 0:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + 0:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 0:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')",
      "mutated_line": "longest_palindrome = t[middle - span + -1:middle + span].replace(sep, '')",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + -1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[3 * c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[3 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[1 * c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[1 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[0 * c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[0 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[1 * c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[1 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = min(spans[2 * c - i], r - i - 1) if i < r else 0",
      "mutated_line": "span = min(spans[-2 * c - i], r - i - 1) if i < r else 0",
      "code": "def find_longest_palindromic_substring(s: str) -> str:\n    if not s:\n        return ''\n    sep = '|'\n    t = sep + sep.join(s) + sep\n    r = 0\n    c = 0\n    spans = []\n    for (i, _) in enumerate(t):\n        span = min(spans[-2 * c - i], r - i - 1) if i < r else 0\n        while span <= i < len(t) - span and t[i - span] == t[i + span]:\n            span += 1\n        if i + span > r:\n            (r, c) = (i + span, i)\n        spans.append(span)\n    span = max(spans)\n    middle = spans.index(span)\n    longest_palindrome = t[middle - span + 1:middle + span].replace(sep, '')\n    return longest_palindrome"
    }
  ]
}