{
  "task_id": "taco_13051",
  "entry_point": "find_min_positive_divisible_outside_segment",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "left = l // d * d",
      "mutated_line": "left = l // d / d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d / d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "left = l // d * d",
      "mutated_line": "left = l // d + d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d + d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "left = l // d * d",
      "mutated_line": "left = (l // d) ** d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = (l // d) ** d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if left == l:",
      "mutated_line": "if left != l:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left != l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "left -= d",
      "mutated_line": "left += d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left += d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 1) // d / d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d / d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 1) // d + d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d + d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = ((r + d - 1) // d) ** d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = ((r + d - 1) // d) ** d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if right == r:",
      "mutated_line": "if right != r:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right != r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "right += d",
      "mutated_line": "right -= d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right -= d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "left = l // d * d",
      "mutated_line": "left = l / d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l / d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "left = l // d * d",
      "mutated_line": "left = l * d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l * d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 1) / d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) / d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 1) * d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) * d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not l <= d <= r:",
      "mutated_line": "if not l < d <= r:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l < d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not l <= d <= r:",
      "mutated_line": "if not l > d <= r:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l > d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not l <= d <= r:",
      "mutated_line": "if not l == d <= r:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l == d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left >= 0:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left >= 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left <= 0:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left <= 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left != 0:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left != 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d + 1) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d + 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d) * 1 // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d) * 1 // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left > 1:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 1:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left > -1:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > -1:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif left > 0:",
      "mutated_line": "elif left > 1:",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 1:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r - d - 1) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r - d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r * d - 1) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r * d - 1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 2) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 2) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 0) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 0) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - 0) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - 0) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "right = (r + d - 1) // d * d",
      "mutated_line": "right = (r + d - -1) // d * d",
      "code": "def find_min_positive_divisible_outside_segment(l: int, r: int, d: int) -> int:\n    \"\"\"\n    Finds the minimum positive integer x such that it is divisible by d and does not belong to the segment [l, r].\n\n    Parameters:\n    l (int): The lower bound of the segment.\n    r (int): The upper bound of the segment.\n    d (int): The divisor.\n\n    Returns:\n    int: The minimum positive integer x that meets the criteria.\n    \"\"\"\n    left = l // d * d\n    if left == l:\n        left -= d\n    right = (r + d - -1) // d * d\n    if right == r:\n        right += d\n    if not l <= d <= r:\n        return d\n    elif left > 0:\n        return left\n    else:\n        return right"
    }
  ]
}