{
  "task_id": "taco_19316",
  "entry_point": "minimum_cost_to_visit_any_city",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] / (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] + (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] ** (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "costs[k] = 0  # Cost to reach the starting city is 0",
      "mutated_line": "costs[k] = 1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 1\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "costs[k] = 0  # Cost to reach the starting city is 0",
      "mutated_line": "costs[k] = -1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = -1\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "costs[k] = 0  # Cost to reach the starting city is 0",
      "mutated_line": "costs[k] = 1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 1\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[0] = 1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 1\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[0] = -1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = -1\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[0] = 1",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 1\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n - 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n * 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[1] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[1] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[-1] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[-1] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs[0] = 0  # City 0 is a dummy city, we don't use it",
      "mutated_line": "costs[1] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[1] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return -1 if max_cost != np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost != np.inf else max_cost"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return +1 if max_cost == np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return +1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 2)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 0)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 0)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [np.inf] * (n + 1)",
      "mutated_line": "costs[0] = 0",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + -1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_cost = costs[current_city] + weight",
      "mutated_line": "new_cost = costs[current_city] - weight",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] - weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "new_cost = costs[current_city] + weight",
      "mutated_line": "new_cost = costs[current_city] * weight",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] * weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if costs[neighbor] > new_cost:",
      "mutated_line": "if costs[neighbor] >= new_cost:",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] >= new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if costs[neighbor] > new_cost:",
      "mutated_line": "if costs[neighbor] <= new_cost:",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] <= new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if costs[neighbor] > new_cost:",
      "mutated_line": "if costs[neighbor] != new_cost:",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] != new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -1 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return -2 if max_cost == np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -2 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return -0 if max_cost == np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -0 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return -0 if max_cost == np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return -0 if max_cost == np.inf else max_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1 if max_cost == np.inf else max_cost",
      "mutated_line": "return --1 if max_cost == np.inf else max_cost",
      "code": "import numpy as np\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef minimum_cost_to_visit_any_city(flights: List[List[int]], n: int, k: int) -> int:\n    graph = defaultdict(list)\n    for (source, dest, weight) in flights:\n        graph[source].append((dest, weight))\n    costs = [np.inf] * (n + 1)\n    costs[k] = 0\n    costs[0] = 0\n    queue = deque([k])\n    while queue:\n        current_city = queue.popleft()\n        for (neighbor, weight) in graph[current_city]:\n            new_cost = costs[current_city] + weight\n            if costs[neighbor] > new_cost:\n                costs[neighbor] = new_cost\n                queue.append(neighbor)\n    max_cost = max(costs)\n    return --1 if max_cost == np.inf else max_cost"
    }
  ]
}