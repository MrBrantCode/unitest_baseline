{
  "task_id": "taco_2548",
  "entry_point": "find_minimum_steps",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] - [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] - [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = ([list('#' * (w + 2))] + [list('#' + row + '#') for row in area]) * [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = ([list('#' * (w + 2))] + [list('#' + row + '#') for row in area]) * [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] / 4",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] / 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] + 4",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] + 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] ** 4",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] ** 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 1] = 1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 1\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 1] = -1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = -1\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 1] = 1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 1\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] - [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] - [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] * [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] * [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] * 5",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 5\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] * 3",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 3\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] * 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 0\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] * 1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 1\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "init_body = [None] * 4",
      "mutated_line": "init_body = [None] * -4",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * -4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(2, h + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(2, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(0, h + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(0, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(0, h + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(0, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(-1, h + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(-1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h - 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h - 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h * 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h * 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if target > n:",
      "mutated_line": "if target >= n:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target >= n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if target > n:",
      "mutated_line": "if target <= n:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target <= n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if target > n:",
      "mutated_line": "if target != n:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target != n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h + 2):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 2):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h + 0):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 0):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h + 0):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 0):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for y in range(1, h + 1):",
      "mutated_line": "for y in range(1, h + -1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + -1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(2, w + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(2, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(0, w + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(0, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(0, w + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(0, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(-1, w + 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(-1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w - 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w - 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w * 1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w * 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mp[y][x] == 'S':",
      "mutated_line": "if mp[y][x] != 'S':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] != 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if mp[y][x] == 'e':",
      "mutated_line": "if mp[y][x] != 'e':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] != 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 'a' <= mp[y][x] <= 'd':",
      "mutated_line": "if 'a' < mp[y][x] <= 'd':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' < mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 'a' <= mp[y][x] <= 'd':",
      "mutated_line": "if 'a' > mp[y][x] <= 'd':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' > mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 'a' <= mp[y][x] <= 'd':",
      "mutated_line": "if 'a' == mp[y][x] <= 'd':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' == mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if '1' <= mp[y][x] <= '9':",
      "mutated_line": "if '1' < mp[y][x] <= '9':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' < mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if '1' <= mp[y][x] <= '9':",
      "mutated_line": "if '1' > mp[y][x] <= '9':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' > mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if '1' <= mp[y][x] <= '9':",
      "mutated_line": "if '1' == mp[y][x] <= '9':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' == mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((1, init_head, init_body, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((1, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((-1, init_head, init_body, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((-1, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((1, init_head, init_body, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((1, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((0, init_head, init_body, 2))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 2))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((0, init_head, init_body, 0))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 0))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((0, init_head, init_body, 0))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 0))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "que.append((0, init_head, init_body, 1))",
      "mutated_line": "que.append((0, init_head, init_body, -1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, -1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 2] = 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 2] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 0] = 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 0] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), 0] = 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 0] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mem[init_head, tuple(init_body), 1] = 0",
      "mutated_line": "mem[init_head, tuple(init_body), -1] = 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), -1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((2, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((2, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((0, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((0, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((0, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((0, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((-1, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((-1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 1), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 1), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, -1), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, -1), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 1), (0, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 1), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (1, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (1, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (-1, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (-1, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (1, -1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (1, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, +1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, +1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (+1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (+1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 1), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 1), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, -1), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, -1), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 1), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 1), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (1, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (1, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (-1, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (-1, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (1, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (1, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 2))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 2))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 0))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 0))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 0))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 0))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, -1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, -1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (nx, ny) in body:",
      "mutated_line": "if (nx, ny) not in body:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) not in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mp[ny][nx] == '#':",
      "mutated_line": "if mp[ny][nx] != '#':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] != '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if mp[ny][nx] == target:",
      "mutated_line": "if mp[ny][nx] != target:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] != target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "new_target += 1",
      "mutated_line": "new_target -= 1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target -= 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ((nx, ny), new_body, new_target) not in mem:",
      "mutated_line": "if ((nx, ny), new_body, new_target) in mem:",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' / (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' / (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' + (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' + (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' ** (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' ** (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w + 2):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 2):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w + 0):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 0):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w + 0):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 0):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in range(1, w + 1):",
      "mutated_line": "for x in range(1, w + -1):",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + -1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if mp[y][x] == 'S':",
      "mutated_line": "if mp[y][x] == '':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == '':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x] = '.'",
      "mutated_line": "mp[y][x] = ''",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = ''\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if mp[y][x] == 'e':",
      "mutated_line": "if mp[y][x] == '':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == '':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x] = '.'",
      "mutated_line": "mp[y][x] = ''",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = ''\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 'a' <= mp[y][x] <= 'd':",
      "mutated_line": "if '' <= mp[y][x] <= 'd':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if '' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 'a' <= mp[y][x] <= 'd':",
      "mutated_line": "if 'a' <= mp[y][x] <= '':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= '':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mp[y][x] = '.'",
      "mutated_line": "mp[y][x] = ''",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = ''\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if '1' <= mp[y][x] <= '9':",
      "mutated_line": "if '' <= mp[y][x] <= '9':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if '1' <= mp[y][x] <= '9':",
      "mutated_line": "if '1' <= mp[y][x] <= '':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -2), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -2), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -0), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -0), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -0), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -0), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, --1), (-1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, --1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-2, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-2, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-0, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-0, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (-0, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-0, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vec = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "vec = ((1, 0), (0, -1), (--1, 0), (0, 1))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (--1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x - dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x * dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y - dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y * dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mp[ny][nx] == '#':",
      "mutated_line": "if mp[ny][nx] == '':",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_target += 1",
      "mutated_line": "new_target += 2",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 2\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_target += 1",
      "mutated_line": "new_target += 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 0\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_target += 1",
      "mutated_line": "new_target += 0",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 0\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_target += 1",
      "mutated_line": "new_target += -1",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += -1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] - list(body)[:-1])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] - list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] * list(body)[:-1])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] * list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "mem[(nx, ny), new_body, new_target] = True",
      "mutated_line": "mem[(nx, ny), new_body, new_target] = False",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = False\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' / (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' / (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' + (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' + (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' ** (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' ** (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row - '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row - '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list(('#' + row) * '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list(('#' + row) * '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w - 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w - 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w * 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w * 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "init_body[ord(mp[y][x]) - ord('a')] = (x, y)",
      "mutated_line": "init_body[ord(mp[y][x]) + ord('a')] = (x, y)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) + ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "init_body[ord(mp[y][x]) - ord('a')] = (x, y)",
      "mutated_line": "init_body[ord(mp[y][x]) * ord('a')] = (x, y)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) * ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w - 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w - 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w * 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w * 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' - row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' - row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' * row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' * row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 3))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 3))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 1))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 1))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 0))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 0))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 1))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 1))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + -2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + -2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score - 1, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score - 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score * 1, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score * 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 3))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 3))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 1))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 1))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 0))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 0))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 1))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 1))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + -2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + -2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "mutated_line": "mp = [list('#' * (w + 2))] + [list('' + row + '#') for row in area] + [list('#' * (w + 2))]",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "init_body[ord(mp[y][x]) - ord('a')] = (x, y)",
      "mutated_line": "init_body[ord(mp[y][x]) - ord('')] = (x, y)",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] + list(body)[:+1])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:+1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score + 2, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 2, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score + 0, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 0, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score + 0, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 0, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "que.append((score + 1, (nx, ny), new_body, new_target))",
      "mutated_line": "que.append((score + -1, (nx, ny), new_body, new_target))",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + -1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] + list(body)[:-2])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-2])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] + list(body)[:-0])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-0])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] + list(body)[:-0])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:-0])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_body = tuple([head] + list(body)[:-1])",
      "mutated_line": "new_body = tuple([head] + list(body)[:--1])",
      "code": "from collections import deque\n\ndef find_minimum_steps(h, w, n, area):\n    mp = [list('#' * (w + 2))] + [list('#' + row + '#') for row in area] + [list('#' * (w + 2))]\n    init_body = [None] * 4\n    init_head = None\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == 'S':\n                init_head = (x, y)\n                mp[y][x] = '.'\n            if mp[y][x] == 'e':\n                mp[y][x] = '.'\n            if 'a' <= mp[y][x] <= 'd':\n                init_body[ord(mp[y][x]) - ord('a')] = (x, y)\n                mp[y][x] = '.'\n            if '1' <= mp[y][x] <= '9':\n                mp[y][x] = int(mp[y][x])\n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[init_head, tuple(init_body), 1] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        (score, head, body, target) = que.popleft()\n        if target > n:\n            return score\n        (x, y) = head\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in body:\n                continue\n            if mp[ny][nx] == '#':\n                continue\n            new_target = target\n            if mp[ny][nx] == target:\n                new_target += 1\n            new_body = tuple([head] + list(body)[:--1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[(nx, ny), new_body, new_target] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    return -1"
    }
  ]
}