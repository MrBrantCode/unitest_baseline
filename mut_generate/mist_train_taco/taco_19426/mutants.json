{
  "task_id": "taco_19426",
  "entry_point": "calculate_minimum_travel_distance",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 2 / sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 / sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 2 + sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 + sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 2 ** sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 ** sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] / (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] + (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] ** (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "cost[start] = 0",
      "mutated_line": "cost[start] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 1\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "cost[start] = 0",
      "mutated_line": "cost[start] = -1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = -1\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "cost[start] = 0",
      "mutated_line": "cost[start] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 1\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distance_from_hostel = BFS(buildings, 0)",
      "mutated_line": "distance_from_hostel = BFS(buildings, 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 1)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distance_from_hostel = BFS(buildings, 0)",
      "mutated_line": "distance_from_hostel = BFS(buildings, -1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, -1)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distance_from_hostel = BFS(buildings, 0)",
      "mutated_line": "distance_from_hostel = BFS(buildings, 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 1)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 3 * sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 3 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 1 * sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 1 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 0 * sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 0 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = 1 * sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 1 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_distance = 2 * sum(subject_distances[:k])",
      "mutated_line": "min_distance = -2 * sum(subject_distances[:k])",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = -2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n - 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n * 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [+1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [+1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 2)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 0)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 0)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-1] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + -1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] != -1:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] != -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-2] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-2] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-0] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-0] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [-1] * (n + 1)",
      "mutated_line": "cost = [--1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [--1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] == +1:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == +1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] - 1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] - 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] * 1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] * 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "buildings = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] == -2:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -2:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] == -0:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -0:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] == -0:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -0:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if cost[neighbor] == -1:",
      "mutated_line": "if cost[neighbor] == --1:",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == --1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] + 2",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 2\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] + 0",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 0\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] + 0",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + 0\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost[neighbor] = cost[current] + 1",
      "mutated_line": "cost[neighbor] = cost[current] + -1",
      "code": "from collections import deque\n\ndef calculate_minimum_travel_distance(n, m, s, k, edges, subjects):\n\n    def BFS(bldg, start):\n        queue = deque()\n        queue.append(start)\n        cost = [-1] * (n + 1)\n        cost[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in bldg[current]:\n                if cost[neighbor] == -1:\n                    queue.append(neighbor)\n                    cost[neighbor] = cost[current] + -1\n        return cost\n    buildings = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        buildings[u].append(v)\n        buildings[v].append(u)\n    distance_from_hostel = BFS(buildings, 0)\n    subject_distances = [distance_from_hostel[subject] for subject in subjects]\n    subject_distances.sort()\n    min_distance = 2 * sum(subject_distances[:k])\n    return min_distance"
    }
  ]
}