{
  "task_id": "taco_4247",
  "entry_point": "max_three_blocks_palindrome_length",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(a) + len(b) < res:",
      "mutated_line": "if len(a) + len(b) <= res:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) <= res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(a) + len(b) < res:",
      "mutated_line": "if len(a) + len(b) >= res:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) >= res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(a) + len(b) < res:",
      "mutated_line": "if len(a) + len(b) != res:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) != res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lid = 0",
      "mutated_line": "lid = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 1\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lid = 0",
      "mutated_line": "lid = -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = -1\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lid = 0",
      "mutated_line": "lid = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 1\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) + 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) + 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) * 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) * 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 1\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = -1\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 1\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) + 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) + 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) * 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) * 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while lid < rid:",
      "mutated_line": "while lid <= rid:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid <= rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while lid < rid:",
      "mutated_line": "while lid >= rid:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid >= rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while lid < rid:",
      "mutated_line": "while lid != rid:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid != rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "lid += 1",
      "mutated_line": "lid -= 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid -= 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "rid -= 1",
      "mutated_line": "rid += 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid += 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 1\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = -1\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 1\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if len(a) + len(b) < res:",
      "mutated_line": "if len(a) - len(b) < res:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) - len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if len(a) + len(b) < res:",
      "mutated_line": "if len(a) * len(b) < res:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) * len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 1\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return -1\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 1\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) - 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 2\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) - 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 0\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) - 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 0\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rid = len(a) - 1",
      "mutated_line": "rid = len(a) - -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - -1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) - 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 2\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) - 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 0\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) - 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 0\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y = len(b) - 1",
      "mutated_line": "y = len(b) - -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - -1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while x < lb:",
      "mutated_line": "while x <= lb:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x <= lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while x < lb:",
      "mutated_line": "while x >= lb:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x >= lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while x < lb:",
      "mutated_line": "while x != lb:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x != lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y >= 0:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y >= 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y <= 0:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y <= 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y != 0:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y != 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x or x <= y or y < lb:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x or x <= y or y < lb:\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lid += 1",
      "mutated_line": "lid += 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 2\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lid += 1",
      "mutated_line": "lid += 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 0\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lid += 1",
      "mutated_line": "lid += 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 0\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lid += 1",
      "mutated_line": "lid += -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += -1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rid -= 1",
      "mutated_line": "rid -= 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 2\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rid -= 1",
      "mutated_line": "rid -= 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 0\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rid -= 1",
      "mutated_line": "rid -= 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 0\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rid -= 1",
      "mutated_line": "rid -= -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= -1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for index, x in enumerate(a, 1):",
      "mutated_line": "for (index, x) in enumerate(a, 2):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 2):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for index, x in enumerate(a, 1):",
      "mutated_line": "for (index, x) in enumerate(a, 0):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 0):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for index, x in enumerate(a, 1):",
      "mutated_line": "for (index, x) in enumerate(a, 0):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 0):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for index, x in enumerate(a, 1):",
      "mutated_line": "for (index, x) in enumerate(a, -1):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, -1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x not in poslist:",
      "mutated_line": "if x in poslist:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if b[x] <= l:",
      "mutated_line": "if b[x] < l:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] < l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if b[x] <= l:",
      "mutated_line": "if b[x] > l:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] > l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if b[x] <= l:",
      "mutated_line": "if b[x] == l:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] == l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "x += 1",
      "mutated_line": "x -= 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x -= 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y > 1:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 1:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y > -1:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > -1:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while y > 0:",
      "mutated_line": "while y > 1:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 1:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r <= b[y]:",
      "mutated_line": "if r < b[y]:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r < b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r <= b[y]:",
      "mutated_line": "if r > b[y]:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r > b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r <= b[y]:",
      "mutated_line": "if r == b[y]:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r == b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y += 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 < x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 < x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 > x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 > x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 == x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 == x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x < y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x < y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x > y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x > y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x == y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x == y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x <= y and (y <= lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y <= lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x <= y and (y >= lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y >= lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 0 <= x and x <= y and (y != lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y != lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] or b[x] <= b[y] or b[y] < r:",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] or b[x] <= b[y] or b[y] < r:\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "all_lists.sort(key=lambda lst: len(lst), reverse=True)",
      "mutated_line": "all_lists.sort(key=lambda lst: len(lst), reverse=False)",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=False)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x += 1",
      "mutated_line": "x += 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 2\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 0\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 0\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x += 1",
      "mutated_line": "x += -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += -1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 2\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 0\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 0\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= -1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 1 <= x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 1 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if -1 <= x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if -1 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= x and x <= y and (y < lb):",
      "mutated_line": "if 1 <= x and x <= y and (y < lb):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 1 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l <= b[x] and b[x] <= b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l <= b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l >= b[x] and b[x] <= b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l >= b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l != b[x] and b[x] <= b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l != b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] < b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] < b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] > b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] > b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] == b[y] and (b[y] < r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] == b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] <= b[y] and (b[y] <= r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] <= r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] <= b[y] and (b[y] >= r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] >= r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if l < b[x] and b[x] <= b[y] and (b[y] < r):",
      "mutated_line": "if l < b[x] and b[x] <= b[y] and (b[y] != r):",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] != r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 1) - (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) - (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, (lid + 1 + (y - x + 1)) * (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, (lid + 1 + (y - x + 1)) * (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 - (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 - (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, (lid + 1) * (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, (lid + 1) * (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la + rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + (la + rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 1) + la * rid)",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 1) + la * rid)\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid - 1 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid - 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid * 1 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid * 1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x - 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x - 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x) * 1 + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x) * 1 + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 2 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 2 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 0 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 0 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 0 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 0 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + -1 + (y - x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + -1 + (y - x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y + x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y + x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y * x + 1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y * x + 1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 2) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 2) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 0) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 0) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + 0) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + 0) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subres = max(subres, lid + 1 + (y - x + 1) + (la - rid))",
      "mutated_line": "subres = max(subres, lid + 1 + (y - x + -1) + (la - rid))",
      "code": "def max_three_blocks_palindrome_length(test_cases):\n\n    def bestmatch(a, b):\n        if len(a) + len(b) < res:\n            return 0\n        subres = len(a)\n        lid = 0\n        rid = len(a) - 1\n        x = 0\n        y = len(b) - 1\n        la = len(a)\n        lb = len(b)\n        while lid < rid:\n            l = a[lid]\n            r = a[rid]\n            while x < lb:\n                if b[x] <= l:\n                    x += 1\n                else:\n                    break\n            while y > 0:\n                if r <= b[y]:\n                    y -= 1\n                else:\n                    break\n            if 0 <= x and x <= y and (y < lb):\n                if l < b[x] and b[x] <= b[y] and (b[y] < r):\n                    subres = max(subres, lid + 1 + (y - x + -1) + (la - rid))\n            lid += 1\n            rid -= 1\n        return subres\n    results = []\n    for (n, a) in test_cases:\n        poslist = {}\n        for (index, x) in enumerate(a, 1):\n            if x not in poslist:\n                poslist[x] = []\n            poslist[x].append(index)\n        res = 0\n        all_lists = list(poslist.values())\n        all_lists.sort(key=lambda lst: len(lst), reverse=True)\n        for id1 in range(len(all_lists)):\n            for id2 in range(len(all_lists)):\n                res = max(res, bestmatch(all_lists[id1], all_lists[id2]))\n        results.append(res)\n    return results"
    }
  ]
}