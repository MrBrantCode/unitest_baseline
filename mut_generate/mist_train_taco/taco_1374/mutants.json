{
  "task_id": "taco_1374",
  "entry_point": "count_unused_edges",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "unused_edges_count = 0",
      "mutated_line": "unused_edges_count = 1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 1\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "unused_edges_count = 0",
      "mutated_line": "unused_edges_count = -1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = -1\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "unused_edges_count = 0",
      "mutated_line": "unused_edges_count = 1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 1\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] / (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] + (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] ** (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] / (N + 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] / (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] + (N + 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] + (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] ** (N + 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] ** (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 1\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = -1\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 1\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(2, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(0, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(0, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(-1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N - 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N * 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N - 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N - 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N * 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N * 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance >= distances[current_vertex]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance >= distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance <= distances[current_vertex]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance <= distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance != distances[current_vertex]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance != distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i - 1, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i - 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i * 1, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i * 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N - 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N - 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N * 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N * 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] != float('inf') or graph[i][j] > shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') or graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "unused_edges_count += 1",
      "mutated_line": "unused_edges_count -= 1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count -= 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 2) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 0) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 0) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + -1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N - 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N * 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N + 2)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 2)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N + 0)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 0)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N + 0)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 0)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('inf')] * (N + -1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + -1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(1, start)]",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(1, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(-1, start)]",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(-1, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(1, start)]",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(1, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(2, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(2, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(0, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(0, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(0, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(0, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(-1, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(-1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N - 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N - 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N * 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N * 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cost[current_vertex][neighbor] == float('inf'):",
      "mutated_line": "if cost[current_vertex][neighbor] != float('inf'):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] != float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distance = current_distance + cost[current_vertex][neighbor]",
      "mutated_line": "distance = current_distance - cost[current_vertex][neighbor]",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance - cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distance = current_distance + cost[current_vertex][neighbor]",
      "mutated_line": "distance = current_distance * cost[current_vertex][neighbor]",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance * cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance <= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance >= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance != distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 2, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 2, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 0, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 0, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 0, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 0, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + -1, N + 1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + -1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N + 2):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 2):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N + 0):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 0):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N + 0):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 0):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(i + 1, N + 1):",
      "mutated_line": "for j in range(i + 1, N + -1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + -1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] == float('inf') and graph[i][j] > shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] == float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] != float('inf') and graph[i][j] >= shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] >= shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] != float('inf') and graph[i][j] <= shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] <= shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] != float('inf') and graph[i][j] != shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] != shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "unused_edges_count += 1",
      "mutated_line": "unused_edges_count += 2",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 2\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "unused_edges_count += 1",
      "mutated_line": "unused_edges_count += 0",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 0\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "unused_edges_count += 1",
      "mutated_line": "unused_edges_count += 0",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 0\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "unused_edges_count += 1",
      "mutated_line": "unused_edges_count += -1",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += -1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 2)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 0)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 0)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "for (a, b, c) in edges:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + -1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances = [float('inf')] * (N + 1)",
      "mutated_line": "distances = [float('')] * (N + 1)",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N + 2):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 2):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N + 0):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 0):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N + 0):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 0):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for neighbor in range(1, N + 1):",
      "mutated_line": "for neighbor in range(1, N + -1):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + -1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cost[current_vertex][neighbor] == float('inf'):",
      "mutated_line": "if cost[current_vertex][neighbor] == float(''):",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float(''):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if graph[i][j] != float('inf') and graph[i][j] > shortest_paths[j]:",
      "mutated_line": "if graph[i][j] != float('') and graph[i][j] > shortest_paths[j]:",
      "code": "def count_unused_edges(N, M, edges):\n    import heapq\n    graph = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for (a, b, c) in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dijkstra(start, cost):\n        distances = [float('inf')] * (N + 1)\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            (current_distance, current_vertex) = heapq.heappop(priority_queue)\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor in range(1, N + 1):\n                if cost[current_vertex][neighbor] == float('inf'):\n                    continue\n                distance = current_distance + cost[current_vertex][neighbor]\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances\n    unused_edges_count = 0\n    for i in range(1, N):\n        shortest_paths = dijkstra(i, graph)\n        for j in range(i + 1, N + 1):\n            if graph[i][j] != float('') and graph[i][j] > shortest_paths[j]:\n                unused_edges_count += 1\n    return unused_edges_count"
    }
  ]
}