{
  "task_id": "taco_1535",
  "entry_point": "legoBlocks",
  "mutant_count": 232,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MAX = 1000000007",
      "mutated_line": "MAX = 1000000008",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000008\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MAX = 1000000007",
      "mutated_line": "MAX = 1000000006",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000006\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MAX = 1000000007",
      "mutated_line": "MAX = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 0\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MAX = 1000000007",
      "mutated_line": "MAX = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MAX = 1000000007",
      "mutated_line": "MAX = -1000000007",
      "code": "def legoBlocks(n, m):\n    MAX = -1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][0] = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 2\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][0] = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 0\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][0] = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 0\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][0] = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = -1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 2\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 0\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 0\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = -1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p < M:",
      "mutated_line": "while p <= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p <= M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p < M:",
      "mutated_line": "while p >= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p >= M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p < M:",
      "mutated_line": "while p != M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p != M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p -= 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = 2",
      "mutated_line": "n = 3",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 3\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = 2",
      "mutated_line": "n = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 1\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = 2",
      "mutated_line": "n = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 0\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = 2",
      "mutated_line": "n = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 1\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = 2",
      "mutated_line": "n = -2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = -2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n < N:",
      "mutated_line": "while n <= N:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n <= N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n < N:",
      "mutated_line": "while n >= N:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n >= N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n < N:",
      "mutated_line": "while n != N:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n != N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "n += 1",
      "mutated_line": "n -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n -= 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if dp[N][M] != 0:",
      "mutated_line": "if dp[N][M] == 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] == 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 2\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 0\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 0\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = -1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while p < M:",
      "mutated_line": "while p <= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p <= M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while p < M:",
      "mutated_line": "while p >= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p >= M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while p < M:",
      "mutated_line": "while p != M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p != M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p -= 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n - 1, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n - 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n * 1, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n * 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m - 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m - 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m * 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m * 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n - 1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n - 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n * 1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n * 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][1] = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 2\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][1] = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 0\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][1] = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 0\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][1] = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = -1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m - 1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m - 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m * 1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m * 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][1] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][1] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][-1] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][-1] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[1][1] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][1] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 2\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 0\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 0\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = -1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 or p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 or p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i -= 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 2\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 0\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 0\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += -1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 2\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 0\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 0\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = -1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while p < M:",
      "mutated_line": "while p <= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p <= M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while p < M:",
      "mutated_line": "while p >= M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p >= M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while p < M:",
      "mutated_line": "while p != M:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p != M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p -= 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n += 1",
      "mutated_line": "n += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 2\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 0\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 0\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n += 1",
      "mutated_line": "n += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += -1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[N][M] != 0:",
      "mutated_line": "if dp[N][M] != 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 1:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[N][M] != 0:",
      "mutated_line": "if dp[N][M] != -1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != -1:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[N][M] != 0:",
      "mutated_line": "if dp[N][M] != 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 1:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if dp[N][p] == 0:",
      "mutated_line": "if dp[N][p] != 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] != 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) * MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) * MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = curTmp - dp[N][p] * levels[N][M - p] + MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = curTmp - dp[N][p] * levels[N][M - p] + MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 2\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 0\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 0\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += -1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[1 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[1 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[1 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[1 for _ in range(m + 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[1 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 2, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 2, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 0, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 0, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 0, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 0, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + -1, m + 1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + -1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m + 2)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 2)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m + 0)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 0)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m + 0)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 0)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "calcLevels(levels, n + 1, m + 1)",
      "mutated_line": "calcLevels(levels, n + 1, m + -1)",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + -1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 2):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 2):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 0):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 0):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 0):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 0):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + -1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + -1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][2] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][2] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][0] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][0] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[p][1] = 1",
      "mutated_line": "dp[p][-1] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][-1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m + 2):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 2):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m + 0):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 0):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m + 0):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 0):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for p in range(m + 1):",
      "mutated_line": "for p in range(m + -1):",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + -1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[2][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[2][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[0][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[0][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[0][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[0][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "levels[1][0] = 1",
      "mutated_line": "levels[-1][0] = 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[-1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i < 4 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i < 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i > 4 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i > 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i == 4 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i == 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i > 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i > 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i < 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i < 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i == 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i == 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) * MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) * MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = levels[1][p] + levels[1][p - i] + MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = levels[1][p] + levels[1][p - i] + MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 2\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 0\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 0\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += -1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] * MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] * MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] + MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] + MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 2\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 0\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 0\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += -1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dp[N][p] == 0:",
      "mutated_line": "if dp[N][p] == 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 1:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dp[N][p] == 0:",
      "mutated_line": "if dp[N][p] == -1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == -1:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dp[N][p] == 0:",
      "mutated_line": "if dp[N][p] == 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 1:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = 1",
      "mutated_line": "q = 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 2\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = 1",
      "mutated_line": "q = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 0\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = 1",
      "mutated_line": "q = 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 0\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = 1",
      "mutated_line": "q = -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = -1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while q < p:",
      "mutated_line": "while q <= p:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q <= p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while q < p:",
      "mutated_line": "while q >= p:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q >= p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while q < p:",
      "mutated_line": "while q != p:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q != p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "q += 1",
      "mutated_line": "q -= 1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q -= 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp + dp[N][p] * levels[N][M - p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp + dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = curTmp * (dp[N][p] * levels[N][M - p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = curTmp * (dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n - 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n - 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n * 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n * 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n - 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n - 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n * 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n * 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[2][p] = levels[1][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[2][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[0][p] = levels[1][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[0][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[0][p] = levels[1][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[0][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[-1][p] = levels[1][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[-1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[1][p] = levels[2][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[2][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[1][p] = levels[0][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[0][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[1][p] = levels[0][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[0][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[1][p] = levels[1][p]",
      "mutated_line": "dp[1][p] = levels[-1][p]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[-1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 5 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 5 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 3 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 3 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 0 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 0 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 1 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 1 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= -4 and p - i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= -4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p + i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p + i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p * i >= 0:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p * i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i >= 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 1:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i >= -1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= -1:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i <= 4 and p - i >= 0:",
      "mutated_line": "while i <= 4 and p - i >= 1:",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 1:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] - levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] - levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = levels[1][p] * levels[1][p - i] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = levels[1][p] * levels[1][p - i] % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] / levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] / levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = (levels[n - 1][p] + levels[1][p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = (levels[n - 1][p] + levels[1][p]) % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] ** levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] ** levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) * MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) * MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = curTmpLow - dp[N][q] * levels[N][p - q] + MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = curTmpLow - dp[N][q] * levels[N][p - q] + MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q += 1",
      "mutated_line": "q += 2",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 2\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q += 1",
      "mutated_line": "q += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 0\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q += 1",
      "mutated_line": "q += 0",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 0\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q += 1",
      "mutated_line": "q += -1",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += -1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - dp[N][p] / levels[N][M - p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] / levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - (dp[N][p] + levels[N][M - p])) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - (dp[N][p] + levels[N][M - p])) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - dp[N][p] ** levels[N][M - p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] ** levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m - 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m - 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m * 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m * 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 2)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 2)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 0)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 0)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 0)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 0)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + -1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + -1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m - 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m - 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m * 1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m * 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 2)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 2)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 0)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 0)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 0)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 0)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + -1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + -1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[2][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[2][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[0][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[0][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[0][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[0][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[-1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[-1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow + dp[N][q] * levels[N][p - q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow + dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = curTmpLow * (dp[N][q] * levels[N][p - q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = curTmpLow * (dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 2)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 2)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 0)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 0)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + 0)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 0)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "levels = [[0 for _ in range(m + -1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + -1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 2)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 2)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 0)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 0)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + 0)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 0)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[0 for _ in range(m + -1)] for _ in range(n + 1)]",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + -1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[1][p + i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p + i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[1][p * i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p * i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - dp[N][q] / levels[N][p - q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] / levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - (dp[N][q] + levels[N][p - q])) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - (dp[N][q] + levels[N][p - q])) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - dp[N][q] ** levels[N][p - q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] ** levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - dp[N][p] * levels[N][M + p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M + p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX",
      "mutated_line": "curTmp = (curTmp - dp[N][p] * levels[N][M * p]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M * p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[2][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[2][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[0][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[0][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[0][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[0][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[-1][p] + levels[1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[-1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[2][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[2][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[0][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[0][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[0][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[0][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX",
      "mutated_line": "levels[1][p] = (levels[1][p] + levels[-1][p - i]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[-1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n + 1][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n + 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n * 1][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n * 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[2][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[2][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[0][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[0][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[0][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[0][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 1][p] * levels[-1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[-1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 2][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 2][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 0][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 0][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - 0][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 0][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX",
      "mutated_line": "levels[n][p] = levels[n - -1][p] * levels[1][p] % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - -1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p + q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p + q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p - q]) % MAX",
      "mutated_line": "curTmpLow = (curTmpLow - dp[N][q] * levels[N][p * q]) % MAX",
      "code": "def legoBlocks(n, m):\n    MAX = 1000000007\n\n    def calcLevels(levels, N, M):\n        levels[1][0] = 1\n        p = 1\n        while p < M:\n            i = 1\n            while i <= 4 and p - i >= 0:\n                levels[1][p] = (levels[1][p] + levels[1][p - i]) % MAX\n                i += 1\n            p += 1\n        n = 2\n        while n < N:\n            p = 1\n            while p < M:\n                levels[n][p] = levels[n - 1][p] * levels[1][p] % MAX\n                p += 1\n            n += 1\n\n    def getDP(dp, levels, N, M):\n        if dp[N][M] != 0:\n            return dp[N][M]\n        curTmp = levels[N][M]\n        p = 1\n        while p < M:\n            if dp[N][p] == 0:\n                curTmpLow = levels[N][p]\n                q = 1\n                while q < p:\n                    curTmpLow = (curTmpLow - dp[N][q] * levels[N][p * q]) % MAX\n                    q += 1\n                dp[N][p] = curTmpLow\n            curTmp = (curTmp - dp[N][p] * levels[N][M - p]) % MAX\n            p += 1\n        dp[N][M] = curTmp\n        return dp[N][M]\n    levels = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    calcLevels(levels, n + 1, m + 1)\n    for p in range(n + 1):\n        dp[p][1] = 1\n    for p in range(m + 1):\n        dp[1][p] = levels[1][p]\n    result = getDP(dp, levels, n, m)\n    return result"
    }
  ]
}