{
  "task_id": "taco_1470",
  "entry_point": "find_int_inrange",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] - sorted(div_range[1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] - sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] * sorted(div_range[1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] * sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) + {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) + {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) * {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) * {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "div_range = [0]",
      "mutated_line": "div_range = [1]",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [1]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "div_range = [0]",
      "mutated_line": "div_range = [-1]",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [-1]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "div_range = [0]",
      "mutated_line": "div_range = [1]",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [1]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b - 1):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b - 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b * 1):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b * 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "common_divisors = divs(score1(n)) & divs(score2(n))",
      "mutated_line": "common_divisors = divs(score1(n)) | divs(score2(n))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) | divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) >= div_range[0]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) >= div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) <= div_range[0]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) <= div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) != div_range[0]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) != div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(common_divisors) == div_range[0]:",
      "mutated_line": "if len(common_divisors) != div_range[0]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) != div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b + 2):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 2):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b + 0):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 0):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b + 0):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 0):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for n in range(a, b + 1):",
      "mutated_line": "for n in range(a, b + -1):",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + -1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "score1 = score(__import__('itertools').combinations)",
      "mutated_line": "score1 = score(__import__('').combinations)",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {2, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {2, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {0, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {0, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {0, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {0, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {-1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {-1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) > div_range[1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[1]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) > div_range[-1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[-1]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(common_divisors) > div_range[0]:",
      "mutated_line": "if len(common_divisors) > div_range[1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[1]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(common_divisors) == div_range[0]:",
      "mutated_line": "if len(common_divisors) == div_range[1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[1]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(common_divisors) == div_range[0]:",
      "mutated_line": "if len(common_divisors) == div_range[-1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[-1]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(common_divisors) == div_range[0]:",
      "mutated_line": "if len(common_divisors) == div_range[1]:",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[1]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[1]] + sorted(div_range[1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[1]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[-1]] + sorted(div_range[1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[-1]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[1]] + sorted(div_range[1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[1]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] + sorted(div_range[2:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[2:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] + sorted(div_range[0:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[0:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] + sorted(div_range[0:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[0:])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [div_range[0]] + sorted(div_range[1:])",
      "mutated_line": "return [div_range[0]] + sorted(div_range[-1:])",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[-1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i - r] for i in range(len(s) - r + 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i - r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i * r] for i in range(len(s) - r + 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i * r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r - 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r - 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range((len(s) - r) * 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range((len(s) - r) * 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(2, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(2, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(0, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(0, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(0, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(0, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(-1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(-1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) - 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) - 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) * 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) * 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) + r + 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) + r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) * r + 1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) * r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 2)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 2)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 0)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 0)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 0)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 0)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))",
      "mutated_line": "score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + -1)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + -1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n / d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n / d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n * d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n * d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int('MUTATED'.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int('MUTATED'.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 2) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 2) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 0) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 0) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 0) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 0) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))",
      "mutated_line": "return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + -1) for sub in sub_gen(str(n), length)))",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + -1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(2, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(2, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(0, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(0, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(0, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(0, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(-1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(-1, int(n ** 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) - 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) - 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) * 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) * 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n * d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n * d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n + d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n + d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 2) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 2) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 0) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 0) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 0) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 0) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + -1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + -1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n * 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n * 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n + 0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n + 0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 1.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 1.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** -0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** -0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 0) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 1) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** 1) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return set.union(*({d, n // d} for d in range(1, int(n ** 0.5) + 1) if not n % d)) - {1, n}",
      "mutated_line": "return set.union(*({d, n // d} for d in range(1, int(n ** -0.5) + 1) if not n % d)) - {1, n}",
      "code": "def find_int_inrange(a, b):\n\n    def score(sub_gen):\n        return lambda n: sum((int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length)))\n    score1 = score(__import__('itertools').combinations)\n    score2 = score(lambda s, r: (s[i:i + r] for i in range(len(s) - r + 1)))\n\n    def divs(n):\n        return set.union(*({d, n // d} for d in range(1, int(n ** -0.5) + 1) if not n % d)) - {1, n}\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]:\n            div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]:\n            div_range.append(n)\n    return [div_range[0]] + sorted(div_range[1:])"
    }
  ]
}