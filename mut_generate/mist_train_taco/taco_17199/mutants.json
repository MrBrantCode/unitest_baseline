{
  "task_id": "taco_17199",
  "entry_point": "divide_into_zebra_subsequences",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if arr and zero and not one:",
      "mutated_line": "if arr or zero or (not one):",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr or zero or (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if s[i] == '0':",
      "mutated_line": "if s[i] != '0':",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] != '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if s[i] == '0':",
      "mutated_line": "if s[i] == '':",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return --1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return +1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i - 1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i - 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i * 1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i * 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i - 1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i - 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i * 1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i * 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -2\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -0\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -0\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return --1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 2)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 2)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 0)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 0)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 0)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 0)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + -1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + -1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 2)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 2)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 0)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 0)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + 0)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 0)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "arr[idx].append(i + 1)",
      "mutated_line": "arr[idx].append(i + -1)",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + -1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i - 1])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i - 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i * 1])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i * 1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i + 2])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 2])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i + 0])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 0])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i + 0])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + 0])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "arr.append([i + 1])",
      "mutated_line": "arr.append([i + -1])",
      "code": "def divide_into_zebra_subsequences(s: str) -> tuple:\n    (arr, zero, one) = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == '0':\n            if one:\n                idx = one.pop()\n                arr[idx].append(i + 1)\n                zero.append(idx)\n            else:\n                zero.append(len(arr))\n                arr.append([i + -1])\n        else:\n            if not zero:\n                return -1\n            idx = zero.pop()\n            one.append(idx)\n            arr[idx].append(i + 1)\n    if arr and zero and (not one):\n        result = []\n        for x in zero:\n            result.append([len(arr[x]), *arr[x]])\n        return (len(arr), result)\n    else:\n        return -1"
    }
  ]
}