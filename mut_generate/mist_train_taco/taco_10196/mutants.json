{
  "task_id": "taco_10196",
  "entry_point": "find_shortest_journey",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap /= 10",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap /= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap *= 11",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 11\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap *= 9",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 9\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap *= 0",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 0\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap *= 1",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 1\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cap *= 10  # Convert capacity to kilometers",
      "mutated_line": "cap *= -10",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= -10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[s, cap] = 0",
      "mutated_line": "d[s, cap] = 1",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 1\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[s, cap] = 0",
      "mutated_line": "d[s, cap] = -1",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = -1\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[s, cap] = 0",
      "mutated_line": "d[s, cap] = 1",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 1\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -1 if r is not None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is not None else r"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return +1 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return +1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v[u] = True",
      "mutated_line": "v[u] = False",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = False\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if u[0] == t:",
      "mutated_line": "if u[0] != t:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] != t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -2 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -2 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -0 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -0 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -0 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -0 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return --1 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return --1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(q, (0, (s, cap)))",
      "mutated_line": "heapq.heappush(q, (1, (s, cap)))",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (1, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(q, (0, (s, cap)))",
      "mutated_line": "heapq.heappush(q, (-1, (s, cap)))",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (-1, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(q, (0, (s, cap)))",
      "mutated_line": "heapq.heappush(q, (1, (s, cap)))",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (1, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[1] + ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] + ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[1] * ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] * ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc <= 0:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc <= 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc >= 0:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc >= 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc != 0:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc != 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if uv in cs:",
      "mutated_line": "if uv not in cs:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv not in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "vd = k + ud",
      "mutated_line": "vd = k - ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k - ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "vd = k + ud",
      "mutated_line": "vd = k * ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k * ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] >= vd:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] >= vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] <= vd:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] <= vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] != vd:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] != vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = collections.defaultdict(lambda: float('inf'))",
      "mutated_line": "d = collections.defaultdict(lambda : float(''))",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float(''))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if u[0] == t:",
      "mutated_line": "if u[1] == t:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[1] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if u[0] == t:",
      "mutated_line": "if u[-1] == t:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[-1] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if u[0] == t:",
      "mutated_line": "if u[1] == t:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[1] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for (uv, ud) in e[u[0]]:",
      "mutated_line": "for (uv, ud) in e[u[1]]:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[1]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for (uv, ud) in e[u[0]]:",
      "mutated_line": "for (uv, ud) in e[u[-1]]:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[-1]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for (uv, ud) in e[u[0]]:",
      "mutated_line": "for (uv, ud) in e[u[1]]:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[1]]:\n                uc = u[1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc < 1:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 1:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc < -1:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < -1:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if uc < 0:",
      "mutated_line": "if uc < 1:",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[1] - ud\n                if uc < 1:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[2] - ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[2] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[0] - ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[0] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[0] - ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[0] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "uc = u[1] - ud",
      "mutated_line": "uc = u[-1] - ud",
      "code": "import heapq\nimport collections\n\ndef find_shortest_journey(N, M, cap, src, dest, roads, stations):\n    cap *= 10\n    e = collections.defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n        e[b].append((a, c))\n    cs = set(stations)\n\n    def search(s, t):\n        d = collections.defaultdict(lambda : float('inf'))\n        d[s, cap] = 0\n        q = []\n        heapq.heappush(q, (0, (s, cap)))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n            if u[0] == t:\n                return k\n            for (uv, ud) in e[u[0]]:\n                uc = u[-1] - ud\n                if uc < 0:\n                    continue\n                if uv in cs:\n                    uc = cap\n                uv = (uv, uc)\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search(src, dest)\n    return -1 if r is None else r"
    }
  ]
}