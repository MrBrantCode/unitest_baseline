{
  "task_id": "taco_628",
  "entry_point": "minimum_operations_to_equalize",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) - 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) * 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) * 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) * (k - 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) * (k - 1) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) // (k - 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) // (k - 1) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) + 2)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) + 2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) + 0)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) + 0)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 1) + -1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 1) + -1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n + k) / (k - 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n + k) / (k - 1) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil(n * k / (k - 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil(n * k / (k - 1) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k + 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k + 1) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k * 1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k * 1) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 2) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 2) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 0) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 0) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - 0) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - 0) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil((n - k) / (k - 1) + 1)",
      "mutated_line": "return math.ceil((n - k) / (k - -1) + 1)",
      "code": "import math\n\ndef minimum_operations_to_equalize(n, k, sequence):\n    return math.ceil((n - k) / (k - -1) + 1)"
    }
  ]
}