{
  "task_id": "taco_15310",
  "entry_point": "find_shortest_paths",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[-1] != end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] != end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(i) == ml:",
      "mutated_line": "if len(i) != ml:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) != ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) >= 1 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) >= 1 else f"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) <= 1 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) <= 1 else f"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) != 1 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) != 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vrt = Q.pop(0)",
      "mutated_line": "vrt = Q.pop(1)",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(1)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vrt = Q.pop(0)",
      "mutated_line": "vrt = Q.pop(-1)",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(-1)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vrt = Q.pop(0)",
      "mutated_line": "vrt = Q.pop(1)",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(1)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if v not in vrt:",
      "mutated_line": "if v in vrt:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) > 2 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 2 else f"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) > 0 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 0 else f"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) > 0 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 0 else f"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return [sorted(i) for i in f] if len(f) > 1 else f",
      "mutated_line": "return [sorted(i) for i in f] if len(f) > -1 else f",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > -1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(Q, paths, d) = ([[0, start]], [], defaultdict(list))",
      "mutated_line": "(Q, paths, d) = ([[1, start]], [], defaultdict(list))",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[1, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(Q, paths, d) = ([[0, start]], [], defaultdict(list))",
      "mutated_line": "(Q, paths, d) = ([[-1, start]], [], defaultdict(list))",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[-1, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(Q, paths, d) = ([[0, start]], [], defaultdict(list))",
      "mutated_line": "(Q, paths, d) = ([[1, start]], [], defaultdict(list))",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[1, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[+1] == end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[+1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[-2] == end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-2] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[-0] == end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-0] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[-0] == end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-0] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if vrt[-1] == end:",
      "mutated_line": "if vrt[--1] == end:",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[--1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] + vrt[1:] - [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] - [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append(([vrt[0] + c] + vrt[1:]) * [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append(([vrt[0] + c] + vrt[1:]) * [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[0]].append(i[2:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[2:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[0]].append(i[0:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[0:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[0]].append(i[0:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[0:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[0]].append(i[-1:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[-1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for (v, c) in topology[vrt[-1]].items():",
      "mutated_line": "for (v, c) in topology[vrt[+1]].items():",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[+1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] - vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] - vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] * vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] * vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[1]].append(i[1:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[1]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[-1]].append(i[1:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[-1]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[i[0]].append(i[1:])",
      "mutated_line": "d[i[1]].append(i[1:])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[1]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (v, c) in topology[vrt[-1]].items():",
      "mutated_line": "for (v, c) in topology[vrt[-2]].items():",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-2]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (v, c) in topology[vrt[-1]].items():",
      "mutated_line": "for (v, c) in topology[vrt[-0]].items():",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-0]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (v, c) in topology[vrt[-1]].items():",
      "mutated_line": "for (v, c) in topology[vrt[-0]].items():",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-0]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (v, c) in topology[vrt[-1]].items():",
      "mutated_line": "for (v, c) in topology[vrt[--1]].items():",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[--1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] - c] + vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] - c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] * c] + vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] * c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] + vrt[2:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[2:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] + vrt[0:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[0:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] + vrt[0:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[0:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[0] + c] + vrt[-1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0] + c] + vrt[-1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[1] + c] + vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[1] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[-1] + c] + vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[-1] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Q.append([vrt[0] + c] + vrt[1:] + [v])",
      "mutated_line": "Q.append([vrt[1] + c] + vrt[1:] + [v])",
      "code": "from collections import defaultdict\n\ndef find_shortest_paths(topology, start, end):\n    (Q, paths, d) = ([[0, start]], [], defaultdict(list))\n    while Q:\n        vrt = Q.pop(0)\n        if vrt[-1] == end:\n            paths.append(vrt)\n            continue\n        for (v, c) in topology[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[1] + c] + vrt[1:] + [v])\n    for i in paths:\n        d[i[0]].append(i[1:])\n    (ml, f) = (len(min(d[min(d)], key=len)), [])\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 1 else f"
    }
  ]
}