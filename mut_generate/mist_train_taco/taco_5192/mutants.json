{
  "task_id": "taco_5192",
  "entry_point": "count_divisible_numbers",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 1\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = -1\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 1\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans -= sign * (k // val)",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans -= sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(2, 1 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(2, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(0, 1 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(0, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(0, 1 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(0, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(-1, 1 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(-1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 1\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = -1\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 1\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "val = 1",
      "mutated_line": "val = 2",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 2\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "val = 1",
      "mutated_line": "val = 0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 0\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "val = 1",
      "mutated_line": "val = 0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 0\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "val = 1",
      "mutated_line": "val = -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = -1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans += sign / (k // val)",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign / (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans += sign + k // val",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign + k // val\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans += sign ** (k // val)",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign ** (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(1, 2 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 2 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(1, 0 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 0 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(1, 0 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 0 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 1 << n):",
      "mutated_line": "for i in range(1, -1 << n):",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, -1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i | 1 << j:",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i | 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt -= 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt * 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt * 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt + 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt + 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 2 if cnt % 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 2 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 0 if cnt % 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 0 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 0 if cnt % 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 0 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = -1 if cnt % 2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = -1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 2 else +1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else +1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans += sign * (k / val)",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k / val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += sign * (k // val)",
      "mutated_line": "ans += sign * (k * val)",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k * val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 2\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 0\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 0\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += -1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val = val * nums[j] // math.gcd(val, nums[j])",
      "mutated_line": "val = val * nums[j] / math.gcd(val, nums[j])",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] / math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val = val * nums[j] // math.gcd(val, nums[j])",
      "mutated_line": "val = val * nums[j] * math.gcd(val, nums[j])",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] * math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 3 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 3 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 1 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 1 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 0 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 0 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 1 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 1 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % -2 else -1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % -2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 2 else -2",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -2\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 2 else -0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -0\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 2 else -0",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -0\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "sign = 1 if cnt % 2 else -1",
      "mutated_line": "sign = 1 if cnt % 2 else --1",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else --1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 2 << j:",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 2 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 0 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 0 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & -1 << j:",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & -1 << j:\n                cnt += 1\n                val = val * nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val = val * nums[j] // math.gcd(val, nums[j])",
      "mutated_line": "val = val / nums[j] // math.gcd(val, nums[j])",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val / nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val = val * nums[j] // math.gcd(val, nums[j])",
      "mutated_line": "val = (val + nums[j]) // math.gcd(val, nums[j])",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = (val + nums[j]) // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val = val * nums[j] // math.gcd(val, nums[j])",
      "mutated_line": "val = val ** nums[j] // math.gcd(val, nums[j])",
      "code": "import math\n\ndef count_divisible_numbers(nums, k):\n    ans = 0\n    n = len(nums)\n    for i in range(1, 1 << n):\n        cnt = 0\n        val = 1\n        for j in range(n):\n            if i & 1 << j:\n                cnt += 1\n                val = val ** nums[j] // math.gcd(val, nums[j])\n        sign = 1 if cnt % 2 else -1\n        ans += sign * (k // val)\n    return ans"
    }
  ]
}