{
  "task_id": "taco_12430",
  "entry_point": "find_shortest_closed_cycle_distance",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "odd_b = 0",
      "mutated_line": "odd_b = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 1\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "odd_b = 0",
      "mutated_line": "odd_b = -1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = -1\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "odd_b = 0",
      "mutated_line": "odd_b = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 1\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 1\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = -1\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 1\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ans += d",
      "mutated_line": "ans -= d",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans -= d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += mw[odd_b]",
      "mutated_line": "ans -= mw[odd_b]",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans -= mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "no_edge = float('inf')",
      "mutated_line": "no_edge = float('')",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj = [[no_edge] * V for _ in range(V)]",
      "mutated_line": "adj = [[no_edge] / V for _ in range(V)]",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] / V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj = [[no_edge] * V for _ in range(V)]",
      "mutated_line": "adj = [[no_edge] + V for _ in range(V)]",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] + V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj = [[no_edge] * V for _ in range(V)]",
      "mutated_line": "adj = [[no_edge] ** V for _ in range(V)]",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] ** V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[i][i] = 0",
      "mutated_line": "adj[i][i] = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 1\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[i][i] = 0",
      "mutated_line": "adj[i][i] = -1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = -1\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[i][i] = 0",
      "mutated_line": "adj[i][i] = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 1\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] / (odd_b + 1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] / (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] + (odd_b + 1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] + (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] ** (odd_b + 1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] ** (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[0] = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 1\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[0] = -1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = -1\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[0] = 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 1\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) + 2",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) + 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) * 2",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) * 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "odd_b ^= 1 << s",
      "mutated_line": "odd_b ^= 2 << s",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 2 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "odd_b ^= 1 << s",
      "mutated_line": "odd_b ^= 0 << s",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 0 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "odd_b ^= 1 << s",
      "mutated_line": "odd_b ^= 0 << s",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 0 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "odd_b ^= 1 << s",
      "mutated_line": "odd_b ^= -1 << s",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= -1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "odd_b ^= 1 << t",
      "mutated_line": "odd_b ^= 2 << t",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 2 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "odd_b ^= 1 << t",
      "mutated_line": "odd_b ^= 0 << t",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 0 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "odd_b ^= 1 << t",
      "mutated_line": "odd_b ^= 0 << t",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 0 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "odd_b ^= 1 << t",
      "mutated_line": "odd_b ^= -1 << t",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= -1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b - 1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b - 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b * 1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b * 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[1] = 0",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[1] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[-1] = 0",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[-1] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mw[0] = 0",
      "mutated_line": "mw[1] = 0",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[1] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) - 3",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 3\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) - 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 1\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) - 0",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 0\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) - 1",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 1\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "digits = len(bin(odd_b)) - 2",
      "mutated_line": "digits = len(bin(odd_b)) - -2",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - -2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b + 2)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 2)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b + 0)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 0)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b + 0)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 0)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mw = [no_edge] * (odd_b + 1)",
      "mutated_line": "mw = [no_edge] * (odd_b + -1)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + -1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i or odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i or odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i and odd_b | 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b | 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])",
      "mutated_line": "adj[i][j] = min(adj[i][j], adj[i][k] - adj[k][j])",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] - adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])",
      "mutated_line": "adj[i][j] = min(adj[i][j], adj[i][k] * adj[k][j])",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] * adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b | 1 << i and odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b | 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i - 1, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i - 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i * 1, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i * 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j or odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j or odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i and odd_b & 2 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 2 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i and odd_b & 0 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 0 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i and odd_b & 0 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 0 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 1 << i and odd_b & -1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & -1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i + 2, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 2, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i + 0, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 0, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i + 0, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 0, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, digits):",
      "mutated_line": "for j in range(i + -1, digits):",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + -1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j and odd_b | 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b | 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (1 << i) - (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) - (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = (b + (1 << i)) * (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = (b + (1 << i)) * (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if t_b == t_b & odd_b:",
      "mutated_line": "if t_b != t_b & odd_b:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b != t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 2 << i and odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 2 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 0 << i and odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 0 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & 0 << i and odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 0 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not b & 1 << i and odd_b & 1 << i:",
      "mutated_line": "if not b & -1 << i and odd_b & 1 << i:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & -1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b | 1 << j and odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b | 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b - (1 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b - (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b * (1 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b * (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if t_b == t_b & odd_b:",
      "mutated_line": "if t_b == t_b | odd_b:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b | odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j and odd_b & 2 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 2 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j and odd_b & 0 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 0 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j and odd_b & 0 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 0 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 1 << j and odd_b & -1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & -1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (1 << i) + (2 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (2 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (1 << i) + (0 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (0 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (1 << i) + (0 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (0 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (1 << i) + (-1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (-1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "mw[t_b] = min(t_w, mw[b] + adj[i][j])",
      "mutated_line": "mw[t_b] = min(t_w, mw[b] - adj[i][j])",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] - adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "mw[t_b] = min(t_w, mw[b] + adj[i][j])",
      "mutated_line": "mw[t_b] = min(t_w, mw[b] * adj[i][j])",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] * adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 2 << j and odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 2 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 0 << j and odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 0 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & 0 << j and odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 0 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not b & 1 << j and odd_b & 1 << j:",
      "mutated_line": "if not b & -1 << j and odd_b & 1 << j:",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & -1 << j and odd_b & 1 << j:\n                            t_b = b + (1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (2 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (2 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (0 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (0 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (0 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (0 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "t_b = b + (1 << i) + (1 << j)",
      "mutated_line": "t_b = b + (-1 << i) + (1 << j)",
      "code": "def find_shortest_closed_cycle_distance(V, E, edges):\n    no_edge = float('inf')\n    adj = [[no_edge] * V for _ in range(V)]\n    for i in range(V):\n        adj[i][i] = 0\n    odd_b = 0\n    ans = 0\n    for (s, t, d) in edges:\n        t_d = min(d, adj[s][t])\n        adj[s][t] = t_d\n        adj[t][s] = t_d\n        odd_b ^= 1 << s\n        odd_b ^= 1 << t\n        ans += d\n    if odd_b:\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n        mw = [no_edge] * (odd_b + 1)\n        mw[0] = 0\n        digits = len(bin(odd_b)) - 2\n        for b in range(odd_b):\n            for i in range(digits):\n                if not b & 1 << i and odd_b & 1 << i:\n                    for j in range(i + 1, digits):\n                        if not b & 1 << j and odd_b & 1 << j:\n                            t_b = b + (-1 << i) + (1 << j)\n                            if t_b == t_b & odd_b:\n                                t_w = mw[t_b]\n                                mw[t_b] = min(t_w, mw[b] + adj[i][j])\n        ans += mw[odd_b]\n        return ans\n    else:\n        return ans"
    }
  ]
}