{
  "task_id": "taco_1816",
  "entry_point": "calculate_max_spaciousness",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = 1.0",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 1.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = -1.0",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = -1.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = 1",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 1\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Circle = namedtuple('Circle', 'x y r')",
      "mutated_line": "Circle = namedtuple('', 'x y r')",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Circle = namedtuple('Circle', 'x y r')",
      "mutated_line": "Circle = namedtuple('Circle', '')",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', '')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x - scd.x, fst.y - scd.y) <= fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) <= fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x - scd.x, fst.y - scd.y) >= fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) >= fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x - scd.x, fst.y - scd.y) != fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) != fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi / circle.r ** 2",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi / circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi + circle.r ** 2",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi + circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi ** circle.r ** 2",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi ** circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if prev_left is None:",
      "mutated_line": "if prev_left is not None:",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is not None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "ans += area(cur)",
      "mutated_line": "ans -= area(cur)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans -= area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * (circle.r * 2)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * (circle.r * 2)\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * (circle.r + 2)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * (circle.r + 2)\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[cur] = True",
      "mutated_line": "counts[cur] = False",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = False\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif prev_right is None:",
      "mutated_line": "elif prev_right is not None:",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is not None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ans += area(cur)",
      "mutated_line": "ans -= area(cur)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans -= area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "cs = sorted(cs, key=lambda circle: -circle.r)",
      "mutated_line": "cs = sorted(cs, key=lambda circle: +circle.r)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: +circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x + scd.x, fst.y - scd.y) < fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x + scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x * scd.x, fst.y - scd.y) < fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x * scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x - scd.x, fst.y + scd.y) < fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y + scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r",
      "mutated_line": "return hypot(fst.x - scd.x, fst.y * scd.y) < fst.r",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y * scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * circle.r ** 3",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 3\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * circle.r ** 1",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 1\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * circle.r ** 0",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 0\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * circle.r ** 1",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 1\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return pi * circle.r ** 2",
      "mutated_line": "return pi * circle.r ** -2",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** -2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "counts[cur] = True",
      "mutated_line": "counts[cur] = False",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = False\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "ans -= area(cur)",
      "mutated_line": "ans += area(cur)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans += area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "ans += area(cur)",
      "mutated_line": "ans -= area(cur)",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans -= area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "counts[cur] = False",
      "mutated_line": "counts[cur] = True",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = True\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "counts[cur] = True",
      "mutated_line": "counts[cur] = False",
      "code": "from collections import namedtuple\nfrom math import hypot, pi\n\ndef calculate_max_spaciousness(n, circles):\n    Circle = namedtuple('Circle', 'x y r')\n    cs = [Circle(*circle) for circle in circles]\n    cs = sorted(cs, key=lambda circle: -circle.r)\n\n    def contains(fst, scd):\n        return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n    def area(circle):\n        return pi * circle.r ** 2\n\n    def find_prev(side, circle):\n        for prev in reversed(side):\n            if contains(prev, circle):\n                return prev\n        return None\n    ans = 0.0\n    counts = dict()\n    left = []\n    right = []\n    for (ind, cur) in enumerate(cs):\n        prev_left = find_prev(left, cur)\n        prev_right = find_prev(right, cur)\n        if prev_left is None:\n            left.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif prev_right is None:\n            right.append(cur)\n            counts[cur] = True\n            ans += area(cur)\n        elif counts[prev_left]:\n            left.append(cur)\n            counts[cur] = False\n            ans -= area(cur)\n        else:\n            left.append(cur)\n            counts[cur] = False\n            ans += area(cur)\n    return ans"
    }
  ]
}