{
  "task_id": "taco_3651",
  "entry_point": "calculate_minimum_distances_sum",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] / m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] / m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] + m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] + m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] ** m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] ** m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 1\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = -1\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 1\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans /= 2",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans /= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "ans += x",
      "mutated_line": "ans -= x",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans -= x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if p[v] != v:",
      "mutated_line": "if p[v] == v:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] == v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return u != v",
      "mutated_line": "return u == v",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u == v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "def dfs(v, par=-1):",
      "mutated_line": "def dfs(v, par=+1):",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=+1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sz = 1",
      "mutated_line": "sz = 2",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 2\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sz = 1",
      "mutated_line": "sz = 0",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 0\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sz = 1",
      "mutated_line": "sz = 0",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 0\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sz = 1",
      "mutated_line": "sz = -1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = -1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "sz += y",
      "mutated_line": "sz -= y",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz -= y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(1)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(-1)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(-1)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(1)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans *= 3",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 3\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans *= 1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 1\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans *= 0",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 0\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans *= 1",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 1\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans *= 2",
      "mutated_line": "ans *= -2",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= -2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [1] * m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [1] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [-1] * m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [-1] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [1] * m",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [1] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def dfs(v, par=-1):",
      "mutated_line": "def dfs(v, par=-2):",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-2):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def dfs(v, par=-1):",
      "mutated_line": "def dfs(v, par=-0):",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-0):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def dfs(v, par=-1):",
      "mutated_line": "def dfs(v, par=-0):",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-0):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def dfs(v, par=-1):",
      "mutated_line": "def dfs(v, par=--1):",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=--1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if u == par:",
      "mutated_line": "if u != par:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u != par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "f[c] = y * (n - y)",
      "mutated_line": "f[c] = y / (n - y)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y / (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "f[c] = y * (n - y)",
      "mutated_line": "f[c] = y + (n - y)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y + (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "f[c] = y * (n - y)",
      "mutated_line": "f[c] = y ** (n - y)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y ** (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for x in f[::-1]:",
      "mutated_line": "for x in f[::+1]:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::+1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return bin(ans)[2:]",
      "mutated_line": "return bin(ans)[3:]",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[3:]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return bin(ans)[2:]",
      "mutated_line": "return bin(ans)[1:]",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return bin(ans)[2:]",
      "mutated_line": "return bin(ans)[0:]",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return bin(ans)[2:]",
      "mutated_line": "return bin(ans)[1:]",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return bin(ans)[2:]",
      "mutated_line": "return bin(ans)[-2:]",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[-2:]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a + 1, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a + 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a * 1, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a * 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b + 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b + 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b * 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b * 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "f[c] = y * (n - y)",
      "mutated_line": "f[c] = y * (n + y)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n + y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "f[c] = y * (n - y)",
      "mutated_line": "f[c] = y * (n * y)",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n * y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for x in f[::-1]:",
      "mutated_line": "for x in f[::-2]:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-2]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for x in f[::-1]:",
      "mutated_line": "for x in f[::-0]:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-0]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for x in f[::-1]:",
      "mutated_line": "for x in f[::-0]:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-0]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for x in f[::-1]:",
      "mutated_line": "for x in f[::--1]:",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::--1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 2, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 2, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 0, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 0, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 0, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 0, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - -1, b - 1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - -1, b - 1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b - 2))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 2))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b - 0))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 0))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b - 0))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - 0))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e.append((c, a - 1, b - 1))",
      "mutated_line": "e.append((c, a - 1, b - -1))",
      "code": "def calculate_minimum_distances_sum(n, m, roads):\n    p = list(range(n))\n\n    def dsu_get(v):\n        if p[v] != v:\n            p[v] = dsu_get(p[v])\n        return p[v]\n\n    def dsu_merge(u, v):\n        u = dsu_get(u)\n        v = dsu_get(v)\n        p[u] = v\n        return u != v\n    e = []\n    for (a, b, c) in roads:\n        e.append((c, a - 1, b - -1))\n    e.sort()\n    G = [[] for _ in range(n)]\n    for (c, a, b) in e:\n        if dsu_merge(a, b):\n            G[a].append((b, c))\n            G[b].append((a, c))\n    f = [0] * m\n\n    def dfs(v, par=-1):\n        sz = 1\n        for (u, c) in G[v]:\n            if u == par:\n                continue\n            y = dfs(u, v)\n            f[c] = y * (n - y)\n            sz += y\n        return sz\n    dfs(0)\n    ans = 0\n    for x in f[::-1]:\n        ans *= 2\n        ans += x\n    return bin(ans)[2:]"
    }
  ]
}