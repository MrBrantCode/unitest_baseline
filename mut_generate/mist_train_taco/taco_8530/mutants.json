{
  "task_id": "taco_8530",
  "entry_point": "shortest_path",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -1): 1}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 1}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -1): -1}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): -1}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -1): 1}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 1}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if node == b:",
      "mutated_line": "if node != b:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node != b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return --1"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, +1): 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, +1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(1, -1, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(1, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(-1, -1, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(-1, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(1, -1, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(1, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(0, +1, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, +1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "scost = cost + w1",
      "mutated_line": "scost = cost - w1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost - w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "scost = cost + w1",
      "mutated_line": "scost = cost * w1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost * w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ccost = cost + w2",
      "mutated_line": "ccost = cost - w2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost - w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ccost = cost + w2",
      "mutated_line": "ccost = cost * w2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost * w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k != 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -2): 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -2): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -0): 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -0): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, -0): 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -0): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "costs = {(a, -1): 0}",
      "mutated_line": "costs = {(a, --1): 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, --1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(0, -2, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -2, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(0, -0, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -0, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(0, -0, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -0, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = [(0, -1, a)]",
      "mutated_line": "q = [(0, --1, a)]",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, --1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 1:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == -1:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 1:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs or costs[nbr, 0] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs or costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs or costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs or costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs and costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs and costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs and costs[nbr, 0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs and costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) not in costs and costs[nbr, 0] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) not in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, 0] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] <= scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, 0] >= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] >= scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, 0] != scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] != scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) not in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) not in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -1] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] < scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] > scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -1] == scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] == scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] >= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] >= scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] <= scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] != scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] != scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) in costs or costs[nbr, 0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, 0] >= ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] >= ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, 0] <= ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] <= ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, 0] != ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] != ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs and costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs and costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs[nbr, 0] = scost",
      "mutated_line": "costs[nbr, 1] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 1] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs[nbr, 0] = scost",
      "mutated_line": "costs[nbr, -1] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, -1] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs[nbr, 0] = scost",
      "mutated_line": "costs[nbr, 1] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 1] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (scost, 0, nbr))",
      "mutated_line": "heappush(q, (scost, 1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 1, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (scost, 0, nbr))",
      "mutated_line": "heappush(q, (scost, -1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, -1, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (scost, 0, nbr))",
      "mutated_line": "heappush(q, (scost, 1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 1, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] >= ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] >= ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] <= ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] <= ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -1] != ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] != ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 1) in costs and costs[nbr, 0] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 1) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, 0] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, -1) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 1) in costs and costs[nbr, 0] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 1) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, +1) in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, +1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, +1) not in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, +1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "costs[nbr, -1] = scost",
      "mutated_line": "costs[nbr, +1] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, +1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "heappush(q, (scost, -1, nbr))",
      "mutated_line": "heappush(q, (scost, +1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, +1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 1) not in costs or costs[nbr, 0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 1) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, 0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, -1) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 1) not in costs or costs[nbr, 0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 1) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, 1] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 1] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, -1] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, -1] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (nbr, 0) in costs and costs[nbr, 0] < scost:",
      "mutated_line": "if (nbr, 0) in costs and costs[nbr, 1] < scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 1] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -2) in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -2) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -0) in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -0) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -0) in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -0) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, --1) in costs and costs[nbr, -1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, --1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, +1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, +1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -2) not in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -2) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -0) not in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -0) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -0) not in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -0) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, --1) not in costs or costs[nbr, -1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, --1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, +1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, +1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "costs[nbr, -1] = scost",
      "mutated_line": "costs[nbr, -2] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -2] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "costs[nbr, -1] = scost",
      "mutated_line": "costs[nbr, -0] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -0] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "costs[nbr, -1] = scost",
      "mutated_line": "costs[nbr, -0] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -0] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "costs[nbr, -1] = scost",
      "mutated_line": "costs[nbr, --1] = scost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, --1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "heappush(q, (scost, -1, nbr))",
      "mutated_line": "heappush(q, (scost, -2, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -2, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "heappush(q, (scost, -1, nbr))",
      "mutated_line": "heappush(q, (scost, -0, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -0, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "heappush(q, (scost, -1, nbr))",
      "mutated_line": "heappush(q, (scost, -0, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -0, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "heappush(q, (scost, -1, nbr))",
      "mutated_line": "heappush(q, (scost, --1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, --1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, 1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 1] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, -1] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if (nbr, 0) not in costs or costs[nbr, 0] > ccost:",
      "mutated_line": "if (nbr, 0) not in costs or costs[nbr, 1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 1] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, +1) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, +1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "costs[nbr, 0] = ccost",
      "mutated_line": "costs[nbr, 1] = ccost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 1] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "costs[nbr, 0] = ccost",
      "mutated_line": "costs[nbr, -1] = ccost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, -1] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "costs[nbr, 0] = ccost",
      "mutated_line": "costs[nbr, 1] = ccost",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 1] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(q, (ccost, 0, nbr))",
      "mutated_line": "heappush(q, (ccost, 1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 1, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(q, (ccost, 0, nbr))",
      "mutated_line": "heappush(q, (ccost, -1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, -1, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(q, (ccost, 0, nbr))",
      "mutated_line": "heappush(q, (ccost, 1, nbr))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 1, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -2] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -2] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -0] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -0] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, -0] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -0] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (nbr, -1) in costs and costs[nbr, -1] <= scost:",
      "mutated_line": "if (nbr, -1) in costs and costs[nbr, --1] <= scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, --1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -2] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -2] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -0] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -0] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -0] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -0] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > scost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, --1] > scost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, --1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -2) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -2) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -0) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -0) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -0) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -0) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, --1) not in costs or costs[nbr, -1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, --1) not in costs or costs[nbr, -1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, +1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, +1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -2] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -2] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -0] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, -0] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, -0] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (nbr, -1) not in costs or costs[nbr, -1] > ccost:",
      "mutated_line": "if (nbr, -1) not in costs or costs[nbr, --1] > ccost:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef shortest_path(n, m, a, b, edges):\n    g = defaultdict(list)\n    for (x, y, w1, w2) in edges:\n        g[x].append((y, w1, w2))\n        g[y].append((x, w1, w2))\n    costs = {(a, -1): 0}\n    q = [(0, -1, a)]\n    while q:\n        (cost, k, node) = heappop(q)\n        if node == b:\n            return cost\n        for (nbr, w1, w2) in g[node]:\n            scost = cost + w1\n            ccost = cost + w2\n            if k == 0:\n                if (nbr, 0) in costs and costs[nbr, 0] < scost:\n                    continue\n                if (nbr, -1) in costs and costs[nbr, -1] <= scost:\n                    continue\n                costs[nbr, 0] = scost\n                heappush(q, (scost, 0, nbr))\n            else:\n                if (nbr, -1) not in costs or costs[nbr, -1] > scost:\n                    costs[nbr, -1] = scost\n                    heappush(q, (scost, -1, nbr))\n                if (nbr, 0) not in costs or costs[nbr, 0] > ccost:\n                    if (nbr, -1) not in costs or costs[nbr, --1] > ccost:\n                        costs[nbr, 0] = ccost\n                        heappush(q, (ccost, 0, nbr))\n    return -1"
    }
  ]
}