{
  "task_id": "taco_14440",
  "entry_point": "minimum_spell_casts",
  "mutant_count": 268,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if M == 1:",
      "mutated_line": "if M != 1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M != 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 * 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 + 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] / (M - logBi - 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] / (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] + (M - logBi - 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] + (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] ** (M - logBi - 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] ** (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [0] / N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] / N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [0] + N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] + N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [0] ** N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] ** N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 1\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = -1\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 1\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [0] / M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] / M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [0] + M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] + M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [0] ** M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] ** M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 58,
      "original_line": "ans += t1",
      "mutated_line": "ans -= t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans -= t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 2:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 2:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 0:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 0:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M == 1:",
      "mutated_line": "if M == -1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == -1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 and all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 and all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 11 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 9 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 0 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 1 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = -10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 19\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 17\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 0\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 1\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** -18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi + 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi + 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * ((M - logBi) * 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * ((M - logBi) * 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if t <= logB:",
      "mutated_line": "if t < logB:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t < logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if t <= logB:",
      "mutated_line": "if t > logB:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t > logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if t <= logB:",
      "mutated_line": "if t == logB:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t == logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N + 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N * 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a0 < b0:",
      "mutated_line": "if a0 <= b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 <= b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a0 < b0:",
      "mutated_line": "if a0 >= b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 >= b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a0 < b0:",
      "mutated_line": "if a0 != b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 != b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a0 > b0:",
      "mutated_line": "if a0 >= b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 >= b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a0 > b0:",
      "mutated_line": "if a0 <= b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 <= b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a0 > b0:",
      "mutated_line": "if a0 != b0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 != b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 >= 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 >= 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 <= 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 <= 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 != 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 != 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ans += t1",
      "mutated_line": "ans -= t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans -= t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "t1 = v // b0",
      "mutated_line": "t1 = v / b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v / b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "t1 = v // b0",
      "mutated_line": "t1 = v * b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v * b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if t0 <= t1:",
      "mutated_line": "if t0 < t1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 < t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if t0 <= t1:",
      "mutated_line": "if t0 > t1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 > t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if t0 <= t1:",
      "mutated_line": "if t0 == t1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 == t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N != 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N != 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 1\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return -1\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 1\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return +1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M + logBi - 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M + logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M * logBi - 2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M * logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi - 3)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 3)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi - 1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 1)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi - 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 0)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi - 1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 1)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INFL = [INF] * (M - logBi - 2)",
      "mutated_line": "INFL = [INF] * (M - logBi - -2)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - -2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi - 2, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi - 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi * 2, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi * 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [1] / L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] / L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [1] + L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] + L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [1] ** L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] ** L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] -= sum((P[j] * V[i - j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] -= sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 2 <= M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 <= M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 2 >= M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 >= M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 2 != M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 != M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [1] * N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [1] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [-1] * N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [-1] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "T = [0] * N",
      "mutated_line": "T = [1] * N",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [1] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [1] * M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [1] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [-1] * M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [-1] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "P = [0] * M",
      "mutated_line": "P = [1] * M",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [1] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 2):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 0):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 0):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - -1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return +1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 + a1 + b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 + b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max((t0 * a0 + a1) * b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max((t0 * a0 + a1) * b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 + a1 - b1, 1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 1)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 + a1 - b1, -1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, -1)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 + a1 - b1, 1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 1)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v * b0 > 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v * b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v + b0 > 0:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v + b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 > 1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 1:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 > -1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > -1:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v % b0 > 0:",
      "mutated_line": "if v % b0 > 1:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 1:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - 1) / b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) / b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - 1) * b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) * b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if P <= A[i]:",
      "mutated_line": "if P < A[i]:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P < A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if P <= A[i]:",
      "mutated_line": "if P > A[i]:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P > A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if P <= A[i]:",
      "mutated_line": "if P == A[i]:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P == A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "t1 += 1",
      "mutated_line": "t1 -= 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 -= 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 1] < P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] < P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 1] > P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] > P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 1] == P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] == P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "t1 += 1",
      "mutated_line": "t1 -= 1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 -= 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i - 1] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i - 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i * 1] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i * 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 2 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 2 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 0 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 0 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 0 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 0 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == -1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == -1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -2\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -0\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -0\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return --1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi + 3, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 3, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi + 1, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 1, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi + 0, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 0, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi + 1, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 1, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def gen(P, t, L=min(logBi + 2, M)):",
      "mutated_line": "def gen(P, t, L=min(logBi + -2, M)):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + -2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in range(1, L):",
      "mutated_line": "for k in range(2, L):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(2, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in range(1, L):",
      "mutated_line": "for k in range(0, L):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(0, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in range(1, L):",
      "mutated_line": "for k in range(0, L):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(0, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in range(1, L):",
      "mutated_line": "for k in range(-1, L):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(-1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - 1) / k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) / k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - 1) * k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) * k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L + 1, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L + 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L * 1, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L * 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 1, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 1, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, -1, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, -1, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 1, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 1, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 0, +1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, +1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi - 2 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi - 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi * 2 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi * 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(a0, a1) = A[i][:2]",
      "mutated_line": "(a0, a1) = A[i][:3]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:3]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(a0, a1) = A[i][:2]",
      "mutated_line": "(a0, a1) = A[i][:1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:1]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(a0, a1) = A[i][:2]",
      "mutated_line": "(a0, a1) = A[i][:0]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:0]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(a0, a1) = A[i][:2]",
      "mutated_line": "(a0, a1) = A[i][:1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:1]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(a0, a1) = A[i][:2]",
      "mutated_line": "(a0, a1) = A[i][:-2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:-2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i - 1][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i - 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i * 1][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i * 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 1][:3]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:3]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 1][:1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:1]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 1][:0]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:0]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 1][:1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:1]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 1][:-2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:-2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -2\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -0\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -0\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return --1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 - a1 - b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 - a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 * a0 * a1 - b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 * a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i - 1] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i - 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i * 1] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i * 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 + 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 + 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0) * 1 // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0) * 1 // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i - 1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i - 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i * 1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i * 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "gen(P, t1 - t0)",
      "mutated_line": "gen(P, t1 + t0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 + t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "gen(P, t1 - t0)",
      "mutated_line": "gen(P, t1 * t0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 * t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 2",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 2\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 0\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 0\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += -1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += -1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "gen(P, t0 - t1)",
      "mutated_line": "gen(P, t0 + t1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 + t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "gen(P, t0 - t1)",
      "mutated_line": "gen(P, t0 * t1)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 * t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 2",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 2\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 0\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += 0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 0\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "t1 += 1",
      "mutated_line": "t1 += -1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += -1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i + 2] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 2] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i + 0] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 0] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i + 0] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 0] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "T[i + 1] = t1",
      "mutated_line": "T[i + -1] = t1",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + -1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] <= A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] <= A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] >= A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] >= A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] != A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] != A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [2] * L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [2] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [0] * L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [0] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [0] * L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [0] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V = [1] * L",
      "mutated_line": "V = [-1] * L",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [-1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] / (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] / (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = (V[k - 1] + (t + k - 1)) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = (V[k - 1] + (t + k - 1)) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] ** (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] ** (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 2, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 2, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 0, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 0, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 0, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 0, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - -1, 0, -1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - -1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 0, -2):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -2):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 0, -0):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -0):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 0, -0):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -0):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(L - 1, 0, -1):",
      "mutated_line": "for i in range(L - 1, 0, --1):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, --1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 3 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 3 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 1 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 1 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 0 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 0 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + 1 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 1 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if logBi + 2 < M:",
      "mutated_line": "if logBi + -2 < M:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + -2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 2][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 2][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 0][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 0][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + 0][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 0][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(b0, b1) = A[i + 1][:2]",
      "mutated_line": "(b0, b1) = A[i + -1][:2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + -1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 / a0 + a1 - b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 / a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 + a0 + a1 - b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 + a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "v = max(t0 * a0 + a1 - b1, 0)",
      "mutated_line": "v = max(t0 ** a0 + a1 - b1, 0)",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 ** a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 2] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 2] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 0] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 0] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 0] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 0] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + -1] = t1 = (v + b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + -1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v - b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v - b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v * b0 - 1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v * b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - 2) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 2) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - 0) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 0) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - 0) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 0) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "T[i + 1] = t1 = (v + b0 - 1) // b0",
      "mutated_line": "T[i + 1] = t1 = (v + b0 - -1) // b0",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - -1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i + 2]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 2]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i + 0]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 0]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i + 0]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 0]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "P[:] = A[i + 1]",
      "mutated_line": "P[:] = A[i + -1]",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + -1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i - 1] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i - 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i * 1] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i * 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k + 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k + 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * ((t + k) * 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * ((t + k) * 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] += sum((P[j] / V[i - j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] / V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] += sum((P[j] + V[i - j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] + V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] += sum((P[j] ** V[i - j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] ** V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi - 2:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi - 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi * 2:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi * 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 2] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 2] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 0] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 0] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + 0] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 0] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if A[i + 1] <= P:",
      "mutated_line": "if A[i + -1] <= P:",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + -1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][1] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][1] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][-1] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][-1] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][1] < A[i + 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][1] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][1] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][1] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][-1] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][-1] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][1] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][1] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N + 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N + 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N * 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N * 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k + 1] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k + 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k * 1] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k * 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t - k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t - k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t * k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t * k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - 2) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 2) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - 0) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 0) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - 0) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 0) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 1] * (t + k - -1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - -1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi + 3:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 3:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi + 1:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 1:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi + 0:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 0:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi + 1:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 1:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "P[logBi + 2:] = INFL",
      "mutated_line": "P[logBi + -2:] = INFL",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + -2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i - 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i - 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i * 1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i * 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 2))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 2))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 0))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 0))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 0))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 0))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - -1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - -1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 2] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 2] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 0] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 0] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - 0] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 0] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "V[k] = V[k - 1] * (t + k - 1) // k",
      "mutated_line": "V[k] = V[k - -1] * (t + k - 1) // k",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - -1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] += sum((P[j] * V[i + j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i + j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "P[i] += sum((P[j] * V[i - j] for j in range(i)))",
      "mutated_line": "P[i] += sum((P[j] * V[i * j] for j in range(i)))",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i * j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 2][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 2][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 0][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 0][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + 0][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + 0][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if N == 1 or all((A[i][0] < A[i + 1][0] for i in range(N - 1))):",
      "mutated_line": "if N == 1 or all((A[i][0] < A[i + -1][0] for i in range(N - 1))):",
      "code": "from math import log2\nfrom itertools import accumulate\n\ndef minimum_spell_casts(N, M, A):\n    B = max((max(Ai) for Ai in A))\n    if M == 1:\n        if N == 1 or all((A[i][0] < A[i + -1][0] for i in range(N - 1))):\n            return 0\n        else:\n            return -1\n    logB = log2(B)\n    logBi = int(logB)\n    INF = 10 ** 18\n    INFL = [INF] * (M - logBi - 2)\n\n    def gen(P, t, L=min(logBi + 2, M)):\n        if t <= logB:\n            for k in range(t):\n                P[:] = accumulate(P)\n        else:\n            V = [1] * L\n            for k in range(1, L):\n                V[k] = V[k - 1] * (t + k - 1) // k\n            for i in range(L - 1, 0, -1):\n                P[i] += sum((P[j] * V[i - j] for j in range(i)))\n            if logBi + 2 < M:\n                P[logBi + 2:] = INFL\n    T = [0] * N\n    ans = 0\n    P = [0] * M\n    for i in range(N - 1):\n        (a0, a1) = A[i][:2]\n        (b0, b1) = A[i + 1][:2]\n        if a0 < b0:\n            continue\n        if a0 > b0:\n            return -1\n        t0 = T[i]\n        v = max(t0 * a0 + a1 - b1, 0)\n        if v % b0 > 0:\n            T[i + 1] = t1 = (v + b0 - 1) // b0\n            ans += t1\n            continue\n        t1 = v // b0\n        if t0 <= t1:\n            P[:] = A[i + 1]\n            gen(P, t1 - t0)\n            if P <= A[i]:\n                t1 += 1\n        else:\n            P[:] = A[i]\n            gen(P, t0 - t1)\n            if A[i + 1] <= P:\n                t1 += 1\n        T[i + 1] = t1\n        ans += t1\n    return ans"
    }
  ]
}