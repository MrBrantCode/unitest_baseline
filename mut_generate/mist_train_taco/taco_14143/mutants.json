{
  "task_id": "taco_14143",
  "entry_point": "max_actions_takahashi",
  "mutant_count": 121,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 * 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 * 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 + 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 + 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while False:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "pos_i += 1",
      "mutated_line": "pos_i -= 1",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i -= 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 11 ** 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 11 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 9 ** 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 9 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 0 ** 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 0 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 1 ** 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 1 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = -10 ** 18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = -10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 19",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 19\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 17",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 17\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 0",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 0\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 1",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 1\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** -18",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** -18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (2, 1)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (2, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (0, 1)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (0, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (0, 1)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (0, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (-1, 1)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (-1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (1, 2)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 2)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (1, 0)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 0)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (1, 0)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 0)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(pos_i, pos_j) = (1, 1)",
      "mutated_line": "(pos_i, pos_j) = (1, -1)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, -1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo and pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo and pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pos_i += 1",
      "mutated_line": "pos_i += 2",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 2\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pos_i += 1",
      "mutated_line": "pos_i += 0",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 0\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pos_i += 1",
      "mutated_line": "pos_i += 0",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 0\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pos_i += 1",
      "mutated_line": "pos_i += -1",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += -1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo and pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo and pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "pos_j += 1",
      "mutated_line": "pos_j -= 1",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j -= 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 6 - j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 - j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 6 * j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 * j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] + 1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] + 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] * 1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] * 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 6 + pos_j not in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j not in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i != H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i != H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 1) not in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) not in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j != W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j != W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos_j += 1",
      "mutated_line": "pos_j += 2",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 2\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos_j += 1",
      "mutated_line": "pos_j += 0",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 0\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos_j += 1",
      "mutated_line": "pos_j += 0",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 0\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos_j += 1",
      "mutated_line": "pos_j += -1",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += -1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i / 10 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i / 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i + 10 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i + 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i ** 10 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i ** 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W - 1)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W - 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W * 1)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W * 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "obstacles = sorted(obstacles, key=itemgetter(0))",
      "mutated_line": "obstacles = sorted(obstacles, key=itemgetter(1))",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(1))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "obstacles = sorted(obstacles, key=itemgetter(0))",
      "mutated_line": "obstacles = sorted(obstacles, key=itemgetter(-1))",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(-1))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "obstacles = sorted(obstacles, key=itemgetter(0))",
      "mutated_line": "obstacles = sorted(obstacles, key=itemgetter(1))",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(1))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 2, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 2, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 0, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 0, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 0, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 0, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - -1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - -1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 6 - pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 - pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 6 * pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 * pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 - (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 - (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 * (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 * (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * (10 * 6) + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * (10 * 6) + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * (10 + 6) + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * (10 + 6) + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W + 2)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 2)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W + 0)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 0)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W + 0)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 0)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pos = [[] for _ in range(W + 1)]",
      "mutated_line": "pos = [[] for _ in range(W + -1)]",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + -1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) / 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) / 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if pos_i + 1 + 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if pos_i + 1 + 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) ** 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) ** 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i / 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i / 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i + 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i + 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i ** 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i ** 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j - 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j - 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + pos_j * 1 in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + pos_j * 1 in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] + 1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] + 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] * 1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] * 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 11 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 11 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 9 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 9 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 0 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 0 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 1 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 1 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * -10 ** 6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * -10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 7 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 7 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 5 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 5 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 0 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 0 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** 1 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 1 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "memo.add(i * 10 ** 6 + j)",
      "mutated_line": "memo.add(i * 10 ** -6 + j)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** -6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i - 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i - 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if pos_i * 1 * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if pos_i * 1 * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * (10 * 6) + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * (10 * 6) + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * (10 + 6) + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * (10 + 6) + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * (10 * 6) + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * (10 * 6) + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * (10 + 6) + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * (10 + 6) + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 2) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 2) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 0) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 0) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + 0) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 0) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 6 + (pos_j + -1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + -1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 2, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 2, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 0, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 0, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - 0, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 0, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = min(pos[pos_j][ind] - 1, ans)",
      "mutated_line": "ans = min(pos[pos_j][ind] - -1, ans)",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - -1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 2) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 2) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 0) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 0) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 0) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 0) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + -1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + -1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 11 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 11 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 9 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 9 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 0 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 0 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 1 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 1 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * -10 ** 6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * -10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 7 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 7 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 5 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 5 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 0 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 0 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** 1 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 1 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:",
      "mutated_line": "if (pos_i + 1) * 10 ** -6 + pos_j in memo or pos_i == H:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** -6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 11 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 11 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 9 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 9 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 0 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 0 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 1 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 1 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * -10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * -10 ** 6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 7 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 7 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 5 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 5 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 0 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 0 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** 1 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** 1 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pos_i * 10 ** 6 + (pos_j + 1) in memo or pos_j == W:",
      "mutated_line": "if pos_i * 10 ** -6 + (pos_j + 1) in memo or pos_j == W:",
      "code": "from operator import itemgetter\nimport bisect\n\ndef max_actions_takahashi(H, W, N, obstacles):\n    memo = set()\n    for (i, j) in obstacles:\n        memo.add(i * 10 ** 6 + j)\n    pos = [[] for _ in range(W + 1)]\n    obstacles = sorted(obstacles, key=itemgetter(0))\n    for (i, j) in obstacles:\n        pos[j].append(i)\n    ans = 10 ** 18\n    (pos_i, pos_j) = (1, 1)\n    ind = bisect.bisect_right(pos[pos_j], pos_i)\n    try:\n        ans = min(pos[pos_j][ind] - 1, ans)\n    except:\n        pass\n    while True:\n        if (pos_i + 1) * 10 ** 6 + pos_j in memo or pos_i == H:\n            ans = min(ans, pos_i)\n            break\n        pos_i += 1\n        if pos_i * 10 ** -6 + (pos_j + 1) in memo or pos_j == W:\n            continue\n        else:\n            pos_j += 1\n            ind = bisect.bisect_right(pos[pos_j], pos_i)\n            try:\n                ans = min(pos[pos_j][ind] - 1, ans)\n            except:\n                pass\n    return ans"
    }
  ]
}