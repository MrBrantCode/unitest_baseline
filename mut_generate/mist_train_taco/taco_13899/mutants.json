{
  "task_id": "taco_13899",
  "entry_point": "count_divisible_concatenations",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 1\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = -1\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 1\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai % k] -= 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] -= 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 * j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 * j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 + j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 + j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if key not in rem:",
      "mutated_line": "if key in rem:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ai % k not in rem[key]:",
      "mutated_line": "if ai % k in rem[key]:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai % k] += 2",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 2\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai % k] += 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 0\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai % k] += 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 0\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai % k] += -1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += -1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) % k != 0:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k != 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ans -= 1",
      "mutated_line": "ans += 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [11 ** j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [11 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [9 ** j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [9 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [0 ** j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [0 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [1 ** j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [1 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [-10 ** j for j in range(11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [-10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if ai % k not in rem[key]:",
      "mutated_line": "if ai * k not in rem[key]:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai * k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if ai % k not in rem[key]:",
      "mutated_line": "if ai + k not in rem[key]:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai + k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem[key][ai % k] = 0",
      "mutated_line": "rem[key][ai % k] = 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 1\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem[key][ai % k] = 0",
      "mutated_line": "rem[key][ai % k] = -1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = -1\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem[key][ai % k] = 0",
      "mutated_line": "rem[key][ai % k] = 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 1\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai * k] += 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai * k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "rem[key][ai % k] += 1",
      "mutated_line": "rem[key][ai + k] += 1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai + k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(2, 11):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(2, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(0, 11):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(0, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(0, 11):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(0, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(-1, 11):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(-1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(1, 12):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 12):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(1, 10):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 10):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(1, 0):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 0):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(1, 1):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 1):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, 11):",
      "mutated_line": "for j in range(1, -11):",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, -11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j in rem:",
      "mutated_line": "if j not in rem:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j not in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) * k == 0:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) * k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) + k == 0:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) + k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) % k == 1:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 1:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) % k == -1:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == -1:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) + str(ai)) % k == 1:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 1:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 2",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= -1",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 ** j for j in range(12)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(12)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 ** j for j in range(10)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(10)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 ** j for j in range(0)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(0)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 ** j for j in range(1)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(1)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pow10 = [10 ** j for j in range(11)]",
      "mutated_line": "pow10 = [10 ** j for j in range(-11)]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(-11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rem[key][ai % k] = 0",
      "mutated_line": "rem[key][ai * k] = 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai * k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rem[key][ai % k] = 0",
      "mutated_line": "rem[key][ai + k] = 0",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai + k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = -(ai * pow10[j]) * k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) * k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = -(ai * pow10[j]) + k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) + k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if key in rem[j]:",
      "mutated_line": "if key not in rem[j]:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key not in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "ans += rem[j][key]",
      "mutated_line": "ans -= rem[j][key]",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans -= rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = +(ai * pow10[j]) % k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = +(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) - str(ai)) % k == 0:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) - str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(str(ai) + str(ai)) % k == 0:",
      "mutated_line": "if int(str(ai) * str(ai)) % k == 0:",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai * pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) * str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = -(ai / pow10[j]) % k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai / pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = -(ai + pow10[j]) % k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -(ai + pow10[j]) % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "key = -(ai * pow10[j]) % k",
      "mutated_line": "key = -ai ** pow10[j] % k",
      "code": "def count_divisible_concatenations(n, k, a):\n    rem = {}\n    pow10 = [10 ** j for j in range(11)]\n    ans = 0\n    for ai in a:\n        key = len(str(ai))\n        if key not in rem:\n            rem[key] = {}\n        if ai % k not in rem[key]:\n            rem[key][ai % k] = 0\n        rem[key][ai % k] += 1\n    for ai in a:\n        for j in range(1, 11):\n            if j in rem:\n                key = -ai ** pow10[j] % k\n                if key in rem[j]:\n                    ans += rem[j][key]\n    for ai in a:\n        if int(str(ai) + str(ai)) % k == 0:\n            ans -= 1\n    return ans"
    }
  ]
}