{
  "task_id": "taco_3257",
  "entry_point": "find_part_max_prod",
  "mutant_count": 141,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def find_part_max_prod(n):\n    if n != 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if r == 0:",
      "mutated_line": "if r != 0:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r != 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def find_part_max_prod(n):\n    if n == 2:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def find_part_max_prod(n):\n    if n == 0:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def find_part_max_prod(n):\n    if n == 0:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def find_part_max_prod(n):\n    if n == -1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(q, r) = divmod(n, 3)",
      "mutated_line": "(q, r) = divmod(n, 4)",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 4)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(q, r) = divmod(n, 3)",
      "mutated_line": "(q, r) = divmod(n, 2)",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 2)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(q, r) = divmod(n, 3)",
      "mutated_line": "(q, r) = divmod(n, 0)",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 0)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(q, r) = divmod(n, 3)",
      "mutated_line": "(q, r) = divmod(n, 1)",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 1)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(q, r) = divmod(n, 3)",
      "mutated_line": "(q, r) = divmod(n, -3)",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, -3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 1:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if r == 0:",
      "mutated_line": "if r == -1:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == -1:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 1:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 3 * q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 * q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 3 + q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 + q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r != 1:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r != 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[1]], 2]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 2]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[1]], 0]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 0]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[1]], 0]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 0]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[1]], -1]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], -1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 4 ** q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 4 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 2 ** q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 2 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 0 ** q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 0 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = 1 ** q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 1 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_product = 3 ** q",
      "mutated_line": "max_product = -3 ** q",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = -3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[3] / q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] / q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[3] + q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] + q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[3] ** q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] ** q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 2:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 2:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 0:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 0:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == -1:",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == -1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) / 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) / 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) + 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) + 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = (3 ** (q - 1)) ** 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = (3 ** (q - 1)) ** 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q / 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q / 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q + 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q + 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = (3 ** q) ** 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = (3 ** q) ** 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 * (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 * (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = (3 + (q - 1)) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = (3 + (q - 1)) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) * 5",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 5\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) * 3",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 3\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) * 0",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 0\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) * 1",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 1\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 1) * -4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * -4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] - [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] - [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] * ([3] * (q - 1)), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] * ([3] * (q - 1)), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) - [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) - [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) * [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) * [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 * q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 * q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = (3 + q) * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = (3 + q) * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q * 3",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 3\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q * 1",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 1\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q * 0",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 0\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q * 1",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 1\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 3 ** q * -2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * -2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q - [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q - [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q * [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q * [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[2]], 1]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[2]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[0]], 1]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[0]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[0]], 1]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[0]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [[[1]], 1]",
      "mutated_line": "return [[[-1]], 1]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[-1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[4] * q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[4] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[2] * q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[2] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[0] * q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[0] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[1] * q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[1] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partitions = [[3] * q]",
      "mutated_line": "partitions = [[-3] * q]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[-3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 4 ** (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 4 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 2 ** (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 2 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 0 ** (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 0 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 1 ** (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 1 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = -3 ** (q - 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = -3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q + 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q + 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q * 1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q * 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] / (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] / (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + ([3] + (q - 1)), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + ([3] + (q - 1)), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] ** (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] ** (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] / (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] / (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] + (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] + (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] ** (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] ** (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 4 ** q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 4 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 2 ** q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 2 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 0 ** q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 0 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = 1 ** q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 1 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_product = 3 ** q * 2",
      "mutated_line": "max_product = -3 ** q * 2",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = -3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] / q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] / q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] + q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] + q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] ** q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] ** q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 2) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 2) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 0) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 0) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - 0) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 0) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_product = 3 ** (q - 1) * 4",
      "mutated_line": "max_product = 3 ** (q - -1) * 4",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - -1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[5] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[5] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[3] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[3] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[0] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[0] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[1] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[1] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[-4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[-4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q + 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q + 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q * 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q * 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q + 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q + 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q * 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q * 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [3, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [3, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [1, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [1, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [0, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [0, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [1, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [1, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [-2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [-2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 3]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 3]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 1]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 1]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 0]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 0]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 1]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 1]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, -2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, -2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q + [3]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [3]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q + [1]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [1]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q + [0]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [0]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q + [1]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [1]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[3] * q + [-2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [-2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [4] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [4] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [2] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [2] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [0] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [0] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [1] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [1] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [-3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [-3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 2), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 2), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 0), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 0), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 0), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 0), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - -1), [3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - -1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [4] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [4] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [2] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [2] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [0] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [0] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [1] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [1] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [-3] * (q - 2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [-3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 3) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 3) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 1) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 1) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 0) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 0) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 1) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 1) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]",
      "mutated_line": "partitions = [[4] + [3] * (q - 1), [3] * (q - -2) + [2, 2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - -2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[3] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[4] * q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[4] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[2] * q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[2] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[0] * q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[0] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[1] * q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[1] * q + [2]]\n    return [partitions, max_product]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partitions = [[3] * q + [2]]",
      "mutated_line": "partitions = [[-3] * q + [2]]",
      "code": "def find_part_max_prod(n):\n    if n == 1:\n        return [[[1]], 1]\n    (q, r) = divmod(n, 3)\n    if r == 0:\n        max_product = 3 ** q\n        partitions = [[3] * q]\n    elif r == 1:\n        max_product = 3 ** (q - 1) * 4\n        partitions = [[4] + [3] * (q - 1), [3] * (q - 2) + [2, 2]]\n    else:\n        max_product = 3 ** q * 2\n        partitions = [[-3] * q + [2]]\n    return [partitions, max_product]"
    }
  ]
}