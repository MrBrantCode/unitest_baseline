{
  "task_id": "taco_12501",
  "entry_point": "count_directed_paths",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 - 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 * 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 1",
      "mutated_line": "while 2 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 2\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 1",
      "mutated_line": "while 2 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 0\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 1",
      "mutated_line": "while 2 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 0\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 1",
      "mutated_line": "while 2 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = -1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 2 ** i < K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i < K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 2 ** i > K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i > K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 2 ** i == K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i == K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i -= 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return result % mod",
      "mutated_line": "return result * mod",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result * mod"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return result % mod",
      "mutated_line": "return result + mod",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result + mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 * 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 + 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 8\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 6\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 0\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 1\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + -7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 2 * i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 * i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 2 + i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 + i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 2\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 0\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 0\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += -1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[0] / N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] / N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[0] + N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] + N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[0] ** N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] ** N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if K >> i & 1:",
      "mutated_line": "if K >> i | 1:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i | 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 11 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 9 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 0 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 1 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = -10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 10 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 8 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 0 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 1 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** -9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 3 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 3 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 1 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 1 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 0 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 0 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while 1 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 1 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 2**i <= K:",
      "mutated_line": "while -2 ** i <= K:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while -2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == j:",
      "mutated_line": "if i != j:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if K >> i & 1:",
      "mutated_line": "if K >> i & 2:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 2:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if K >> i & 1:",
      "mutated_line": "if K >> i & 0:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 0:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if K >> i & 1:",
      "mutated_line": "if K >> i & 0:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 0:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if K >> i & 1:",
      "mutated_line": "if K >> i & -1:",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & -1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 1\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = -1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = -1\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 1\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp -= A[-1][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp -= A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[1] * N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[1] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[-1] * N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [[0] * N for _ in range(N)]",
      "mutated_line": "ans = [[1] * N for _ in range(N)]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[1] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans[i][j] = 1",
      "mutated_line": "ans[i][j] = 2",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 2\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans[i][j] = 1",
      "mutated_line": "ans[i][j] = 0",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 0\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans[i][j] = 1",
      "mutated_line": "ans[i][j] = 0",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 0\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans[i][j] = 1",
      "mutated_line": "ans[i][j] = -1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = -1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = sum(map(lambda x: sum(x) % mod, ans))",
      "mutated_line": "result = sum(map(lambda x: sum(x) * mod, ans))",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) * mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = sum(map(lambda x: sum(x) % mod, ans))",
      "mutated_line": "result = sum(map(lambda x: sum(x) + mod, ans))",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) + mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] / A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] / A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] + A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] + A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] ** A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] ** A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "raw.append(tmp % mod)",
      "mutated_line": "raw.append(tmp * mod)",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp * mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "raw.append(tmp % mod)",
      "mutated_line": "raw.append(tmp + mod)",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp + mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 1\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = -1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = -1\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tmp = 0",
      "mutated_line": "tmp = 1",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 1\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "tmp += ans[j][k] * A[i][k][l]",
      "mutated_line": "tmp -= ans[j][k] * A[i][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp -= ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "tmp += ans[j][k] * A[i][k][l]",
      "mutated_line": "tmp += ans[j][k] / A[i][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] / A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "tmp += ans[j][k] * A[i][k][l]",
      "mutated_line": "tmp += ans[j][k] + A[i][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] + A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "tmp += ans[j][k] * A[i][k][l]",
      "mutated_line": "tmp += ans[j][k] ** A[i][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] ** A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "raw.append(tmp % mod)",
      "mutated_line": "raw.append(tmp * mod)",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp * mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "raw.append(tmp % mod)",
      "mutated_line": "raw.append(tmp + mod)",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp + mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[+1][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[+1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] * A[+1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[+1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-2][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-2][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-0][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-0][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-0][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-0][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[--1][j][k] * A[-1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[--1][j][k] * A[-1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] * A[-2][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-2][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] * A[-0][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-0][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] * A[-0][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[-0][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp += A[-1][j][k] * A[-1][k][l]",
      "mutated_line": "tmp += A[-1][j][k] * A[--1][k][l]",
      "code": "def count_directed_paths(N, K, a):\n    mod = 10 ** 9 + 7\n    A = [a]\n    i = 1\n    while 2 ** i <= K:\n        mtrix = []\n        for j in range(N):\n            raw = []\n            for l in range(N):\n                tmp = 0\n                for k in range(N):\n                    tmp += A[-1][j][k] * A[--1][k][l]\n                raw.append(tmp % mod)\n            mtrix.append(raw)\n        A.append(mtrix)\n        i += 1\n    bit_max = i\n    ans = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                ans[i][j] = 1\n    for i in range(bit_max):\n        if K >> i & 1:\n            mtrix = []\n            for j in range(N):\n                raw = []\n                for l in range(N):\n                    tmp = 0\n                    for k in range(N):\n                        tmp += ans[j][k] * A[i][k][l]\n                    raw.append(tmp % mod)\n                mtrix.append(raw)\n            ans = mtrix\n    result = sum(map(lambda x: sum(x) % mod, ans))\n    return result % mod"
    }
  ]
}