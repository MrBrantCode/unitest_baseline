{
  "task_id": "taco_12105",
  "entry_point": "longest_common_substring_length",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 358976445361682909",
      "mutated_line": "MOD = 358976445361682910",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682910\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 358976445361682909",
      "mutated_line": "MOD = 358976445361682908",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682908\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 358976445361682909",
      "mutated_line": "MOD = 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 0\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 358976445361682909",
      "mutated_line": "MOD = 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 1\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 358976445361682909",
      "mutated_line": "MOD = -358976445361682909",
      "code": "def longest_common_substring_length(S, T):\n    MOD = -358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "base = 31",
      "mutated_line": "base = 32",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 32\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "base = 31",
      "mutated_line": "base = 30",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 30\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "base = 31",
      "mutated_line": "base = 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 0\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "base = 31",
      "mutated_line": "base = 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 1\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "base = 31",
      "mutated_line": "base = -31",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = -31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 1\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = -1\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 1\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) - 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) - 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) * 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) * 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 <= right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 <= right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 >= right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 >= right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 != right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 != right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] / (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] / (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] + (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] + (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] ** (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] ** (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 1\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return -1\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 1\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) + 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 2\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) + 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 0\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) + 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 0\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right = min(L, M) + 1",
      "mutated_line": "right = min(L, M) + -1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + -1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left - 1 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left - 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left * 1 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left * 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) / 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) / 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) * 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) * 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l - 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l - 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l * 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l * 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = (h[i] * base + ord(string[i])) * MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) * MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = h[i] * base + ord(string[i]) + MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = h[i] * base + ord(string[i]) + MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L - l - 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l - 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range((L - l) * 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range((L - l) * 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M - l - 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l - 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range((M - l) * 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range((M - l) * 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] - rht[i] * v) % MOD not in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD not in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 2 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 2 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 0 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 0 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 0 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 0 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + -1 < right:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + -1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left - right) // 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left - right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = left * right // 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = left * right // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 3",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 3\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 1\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 0\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 1\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // -2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // -2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [1] * (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [1] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [-1] * (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [-1] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [1] * (l + 1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [1] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l + 2)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 2)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l + 0)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 0)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l + 0)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 0)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = [0] * (l + 1)",
      "mutated_line": "h = [0] * (l + -1)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + -1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i - 1] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i - 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i * 1] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i * 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = (h[i] * base - ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base - ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = h[i] * base * ord(string[i]) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = h[i] * base * ord(string[i]) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L + l + 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L + l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L * l + 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L * l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L - l + 2):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 2):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L - l + 0):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 0):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L - l + 0):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 0):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(L - l + 1):",
      "mutated_line": "for i in range(L - l + -1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + -1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i + l] - rhs[i] * v) * MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) * MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add(rhs[i + l] - rhs[i] * v + MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add(rhs[i + l] - rhs[i] * v + MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M + l + 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M + l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M * l + 1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M * l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M - l + 2):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 2):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M - l + 0):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 0):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M - l + 0):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 0):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(M - l + 1):",
      "mutated_line": "for i in range(M - l + -1):",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + -1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] - rht[i] * v) * MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) * MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if rht[i + l] - rht[i] * v + MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if rht[i + l] - rht[i] * v + MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 2\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 0\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 0\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return -1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 2] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 2] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 0] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 0] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 0] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 0] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + -1] = (h[i] * base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + -1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = (h[i] / base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] / base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = (h[i] + base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] + base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "h[i + 1] = (h[i] * base + ord(string[i])) % MOD",
      "mutated_line": "h[i + 1] = (h[i] ** base + ord(string[i])) % MOD",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] ** base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i + l] + rhs[i] * v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] + rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add(rhs[i + l] * (rhs[i] * v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add(rhs[i + l] * (rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] + rht[i] * v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] + rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if rht[i + l] * (rht[i] * v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if rht[i + l] * (rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i + l] - rhs[i] / v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] / v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i + l] - (rhs[i] + v)) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - (rhs[i] + v)) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i + l] - rhs[i] ** v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] ** v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] - rht[i] / v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] / v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] - (rht[i] + v)) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - (rht[i] + v)) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i + l] - rht[i] ** v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] ** v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i - l] - rhs[i] * v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i - l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "hs.add((rhs[i + l] - rhs[i] * v) % MOD)",
      "mutated_line": "hs.add((rhs[i * l] - rhs[i] * v) % MOD)",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i * l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i + l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i - l] - rht[i] * v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i - l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (rht[i + l] - rht[i] * v) % MOD in hs:",
      "mutated_line": "if (rht[i * l] - rht[i] * v) % MOD in hs:",
      "code": "def longest_common_substring_length(S, T):\n    MOD = 358976445361682909\n    base = 31\n\n    def rolling_hash(string, base, MOD):\n        l = len(string)\n        h = [0] * (l + 1)\n        for i in range(l):\n            h[i + 1] = (h[i] * base + ord(string[i])) % MOD\n        return h\n    rhs = rolling_hash(S, base, MOD)\n    rht = rolling_hash(T, base, MOD)\n    L = len(S)\n    M = len(T)\n\n    def solve(l):\n        v = pow(base, l, MOD)\n        hs = set()\n        for i in range(L - l + 1):\n            hs.add((rhs[i + l] - rhs[i] * v) % MOD)\n        for i in range(M - l + 1):\n            if (rht[i * l] - rht[i] * v) % MOD in hs:\n                return 1\n        return 0\n    left = 0\n    right = min(L, M) + 1\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    return left"
    }
  ]
}