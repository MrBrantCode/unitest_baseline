{
  "task_id": "taco_14091",
  "entry_point": "lexicographically_smallest_string",
  "mutant_count": 138,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] / (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] / (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] + (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] + (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] ** (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] ** (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [0] / n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] / n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [0] + n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] + n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [0] ** n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] ** n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] / 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] / 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] + 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] + 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] ** 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] ** 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-1] / n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] / n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-1] + n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] + n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-1] ** n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] ** n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] / 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] / 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] + 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] + 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] ** 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] ** 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k >= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k >= 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k <= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k <= 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k != 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k != 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ord(x) - ord('a')",
      "mutated_line": "return ord(x) + ord('a')",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) + ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ord(x) - ord('a')",
      "mutated_line": "return ord(x) * ord('a')",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) * ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n - 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n - 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n * 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n * 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= n:",
      "mutated_line": "while i < n:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i < n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= n:",
      "mutated_line": "while i > n:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i > n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i <= n:",
      "mutated_line": "while i == n:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i == n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "bit[i] += 1",
      "mutated_line": "bit[i] -= 1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] -= 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i -= i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 1\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = -1\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 1\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i >= 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i <= 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i != 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ret += bit[i]",
      "mutated_line": "ret -= bit[i]",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret -= bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i += i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] * 27",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 27\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] * 25",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 25\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] * 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 0\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] * 1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 1\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-1] * -26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * -26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] * 27",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 27\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] * 25",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 25\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] * 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 0\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] * 1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 1\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-1] * -26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * -26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] > 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] > 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] < 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] < 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] == 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] == 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] <= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] <= 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] >= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] >= 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] != 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] != 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 1:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k > -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > -1:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 1:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if z[i] == 0:",
      "mutated_line": "if z[i] != 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] != 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [1] * (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [1] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [-1] * (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [-1] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [1] * (n + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [1] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n + 2)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 2)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 0)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 0)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "bit = [0] * (n + 1)",
      "mutated_line": "bit = [0] * (n + -1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + -1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bit[i] += 1",
      "mutated_line": "bit[i] += 2",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 2\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bit[i] += 1",
      "mutated_line": "bit[i] += 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 0\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bit[i] += 1",
      "mutated_line": "bit[i] += 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 0\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bit[i] += 1",
      "mutated_line": "bit[i] += -1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += -1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i | -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 1:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > -1:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 1:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i | -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [1] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [1] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [-1] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [-1] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = [0] * n",
      "mutated_line": "z = [1] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [1] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [+1] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [+1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [+1] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [+1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [+1] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [+1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] >= 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 1:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] >= -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= -1:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bef[cv] >= 0:",
      "mutated_line": "if bef[cv] >= 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 1:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] < 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 1:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] < -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < -1:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if top[cv] < 0:",
      "mutated_line": "if top[cv] < 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 1:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(27):",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(27):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(25):",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(25):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(0):",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(0):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(1):",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(1):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(-26):",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(-26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] <= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] <= 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] >= 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] >= 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] != 0:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] != 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p + bit_sum(p + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p + bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p * bit_sum(p + 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p * bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if cost <= k:",
      "mutated_line": "if cost < k:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost < k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if cost <= k:",
      "mutated_line": "if cost > k:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost > k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if cost <= k:",
      "mutated_line": "if cost == k:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost == k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "k -= cost",
      "mutated_line": "k += cost",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k += cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if z[i] == 0:",
      "mutated_line": "if z[i] == 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 1:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if z[i] == 0:",
      "mutated_line": "if z[i] == -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == -1:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if z[i] == 0:",
      "mutated_line": "if z[i] == 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 1:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return ''.join(ans)",
      "mutated_line": "return 'MUTATED'.join(ans)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return 'MUTATED'.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ord(x) - ord('a')",
      "mutated_line": "return ord(x) - ord('')",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & +i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & +i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-2] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-2] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-0] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-0] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [-0] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-0] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = [-1] * 26",
      "mutated_line": "top = [--1] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [--1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-2] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-2] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-0] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-0] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [-0] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-0] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "nxt = [-1] * n",
      "mutated_line": "nxt = [--1] * n",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [--1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-2] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-2] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-0] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-0] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [-0] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-0] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "bef = [-1] * 26",
      "mutated_line": "bef = [--1] * 26",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [--1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] < 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 1:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] < -1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < -1:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if top[i] < 0:",
      "mutated_line": "if top[i] < 1:",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 1:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "z[top[i]] = 1",
      "mutated_line": "z[top[i]] = 2",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 2\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "z[top[i]] = 1",
      "mutated_line": "z[top[i]] = 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 0\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "z[top[i]] = 1",
      "mutated_line": "z[top[i]] = 0",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 0\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "z[top[i]] = 1",
      "mutated_line": "z[top[i]] = -1",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = -1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p - 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p - 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p * 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p * 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p - 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p - 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p * 1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p * 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p + 2)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 2)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 0)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 0)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cost = p - bit_sum(p + 1)",
      "mutated_line": "cost = p - bit_sum(p + -1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + -1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans.append(chr(ord('a') + i))",
      "mutated_line": "ans.append(chr(ord('a') - i))",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') - i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans.append(chr(ord('a') + i))",
      "mutated_line": "ans.append(chr(ord('a') * i))",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') * i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p + 2)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 2)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 0)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p + 0)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 0)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bit_add(p + 1)",
      "mutated_line": "bit_add(p + -1)",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('a') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + -1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans.append(chr(ord('a') + i))",
      "mutated_line": "ans.append(chr(ord('') + i))",
      "code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    n = len(s)\n\n    def conv(x):\n        return ord(x) - ord('a')\n    bit = [0] * (n + 1)\n\n    def bit_add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n\n    def bit_sum(i):\n        ret = 0\n        while i > 0:\n            ret += bit[i]\n            i -= i & -i\n        return ret\n    z = [0] * n\n    top = [-1] * 26\n    nxt = [-1] * n\n    bef = [-1] * 26\n    for i in range(n):\n        cv = conv(s[i])\n        if bef[cv] >= 0:\n            nxt[bef[cv]] = i\n        bef[cv] = i\n        if top[cv] < 0:\n            top[cv] = i\n    ans = []\n    while k > 0:\n        for i in range(26):\n            if top[i] < 0:\n                continue\n            p = top[i]\n            cost = p - bit_sum(p + 1)\n            if cost <= k:\n                ans.append(chr(ord('') + i))\n                z[top[i]] = 1\n                k -= cost\n                top[i] = nxt[top[i]]\n                bit_add(p + 1)\n                break\n        else:\n            break\n    for i in range(n):\n        if z[i] == 0:\n            ans.append(s[i])\n    return ''.join(ans)"
    }
  ]
}