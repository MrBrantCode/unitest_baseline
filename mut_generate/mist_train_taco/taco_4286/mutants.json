{
  "task_id": "taco_4286",
  "entry_point": "can_form_rectangular_parallelepiped",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(rec) == 1:",
      "mutated_line": "if len(rec) != 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) != 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 'no'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 2 != 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 != 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(rec) == 1:",
      "mutated_line": "if len(rec) == 2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 2:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(rec) == 1:",
      "mutated_line": "if len(rec) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 0:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(rec) == 1:",
      "mutated_line": "if len(rec) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 0:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(rec) == 1:",
      "mutated_line": "if len(rec) == -1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == -1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][1]) != 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) != 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) != 2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) != 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = lst[0]",
      "mutated_line": "x = lst[1]",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[1]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = lst[0]",
      "mutated_line": "x = lst[-1]",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[-1]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = lst[0]",
      "mutated_line": "x = lst[1]",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[1]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count * 2 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count * 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count + 2 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count + 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 2 == 2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 2:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 2 == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 0:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 2 == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 0:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 2 == -1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == -1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 'no'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return ''\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][1]) == 2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 2:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][1]) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 0:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][1]) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 0:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][1]) == -1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == -1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'yes'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return ''\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 'no'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return ''\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) == 3:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 1:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 0:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 1:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(rec) == 2:",
      "mutated_line": "elif len(rec) == -2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == -2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] != rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] != rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) != 3:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) != 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 3 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 3 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 1 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 1 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 0 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 0 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % 1 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 1 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if count % 2 == 1:",
      "mutated_line": "if count % -2 == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % -2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] | rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] | rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'yes'",
      "mutated_line": "return 'yes'",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return ''\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 'no'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return ''\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) == 4:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 4:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) == 2:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) == 0:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 0:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 1:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(rec) == 3:",
      "mutated_line": "elif len(rec) == -3:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == -3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 or rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 or rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][2]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][2]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][0]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][0]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][0]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][0]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[0][-1]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][-1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[0][2]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][2]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[0][0]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][0]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[0][0]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][0]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[0][-1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][-1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) != len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) != len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) != rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) != rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 'yes'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return ''\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 'no'",
      "mutated_line": "return ''",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return ''\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[1][1]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[1][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[-1][1]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[-1][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(rec[0][1]) == 1:",
      "mutated_line": "if len(rec[1][1]) == 1:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[1][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][2] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][2] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][0] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][0] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][0] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][0] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][-1] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][-1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][2] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][2] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][0] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][0] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][0] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][0] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][-1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][-1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[1][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[1][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[-1][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[-1][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[1][1] == rec[1][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[1][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 3 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 3 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 1 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 1 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 0 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 0 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 1 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 1 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == -2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == -2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] | (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] | (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[1][1] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[1][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[-1][1] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[-1][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[1][1] & rec[1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[1][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[2][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[2][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[0][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[0][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[0][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[0][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if rec[0][1] & rec[1][1] == rec[0][1]:",
      "mutated_line": "if rec[0][1] & rec[-1][1] == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[-1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] & rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] & rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] ^ rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] ^ rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][2]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][2]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][0]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][0]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][0]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][0]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][-1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][-1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][2]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][2]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][0]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][0]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][0]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][0]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][-1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][-1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][2]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][2]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][0]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][0]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][0]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][0]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][-1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][-1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][2]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][2]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][0]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][0]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][0]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][0]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][-1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][-1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][2] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][2] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][0] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][0] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][0] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][0] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][-1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][-1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[3][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[3][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[1][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[1][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[0][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[1][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[1][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[-2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[-2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[-1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[-1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[1][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[2][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[2][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[0][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[0][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[0][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[0][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[-1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[-1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[3][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[3][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[1][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[1][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[0][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[0][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[1][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[1][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[-2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[-2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[3][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[3][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[1][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[1][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[0][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[0][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[1][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[1][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[-2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[-2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][2] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][2] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][0] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][0] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][0] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][0] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][-1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][-1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][2]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][2]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][0]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][0]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][0]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][0]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][-1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[1][-1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[1][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[1][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[-1][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[-1][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[1][1] | rec[1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[1][1] | rec[1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[2][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[2][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[0][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[0][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[0][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[0][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rec[2][1] & (rec[0][1] | rec[1][1]) == rec[2][1]):",
      "mutated_line": "if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[-1][1]) == rec[2][1]:",
      "code": "def can_form_rectangular_parallelepiped(rectangles):\n    lst = [set(rect) for rect in rectangles]\n    rec = []\n    while lst:\n        x = lst[0]\n        count = lst.count(x)\n        if count % 2 == 1:\n            return 'no'\n        rec.append((count, x))\n        for _ in range(count):\n            lst.pop(lst.index(x))\n    if len(rec) == 1:\n        if len(rec[0][1]) == 1:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 2:\n        rec.sort()\n        if rec[0][1] & rec[1][1] == rec[0][1]:\n            return 'yes'\n        else:\n            return 'no'\n    elif len(rec) == 3:\n        if len(rec[0][1]) == len(rec[1][1]) == len(rec[2][1]) == 2 and rec[2][1] & (rec[0][1] | rec[-1][1]) == rec[2][1]:\n            return 'yes'\n        else:\n            return 'no'\n    return 'no'"
    }
  ]
}