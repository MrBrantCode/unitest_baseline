{
  "task_id": "taco_14028",
  "entry_point": "minimum_lines_for_recipe",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if limit == 0:",
      "mutated_line": "if limit != 0:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit != 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if u == t:",
      "mutated_line": "if u != t:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u != t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flow = 0",
      "mutated_line": "flow = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 1\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flow = 0",
      "mutated_line": "flow = -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = -1\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flow = 0",
      "mutated_line": "flow = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 1\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 1\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = -1\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 1\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while False:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "max_flow += augment(res, s, t, level, sum(res[s][v] for v in range(len(res))))",
      "mutated_line": "max_flow -= augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow -= augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if limit == 0:",
      "mutated_line": "if limit == 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 1:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if limit == 0:",
      "mutated_line": "if limit == -1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == -1:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if limit == 0:",
      "mutated_line": "if limit == 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 1:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 1\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return -1\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 1\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 or level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 or level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "res[u][v] -= aug",
      "mutated_line": "res[u][v] += aug",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] += aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "res[v][u] += aug",
      "mutated_line": "res[v][u] -= aug",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] -= aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "flow += aug",
      "mutated_line": "flow -= aug",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow -= aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "limit -= aug",
      "mutated_line": "limit += aug",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit += aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (1, len(res) - 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (1, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (-1, len(res) - 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (-1, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (1, len(res) - 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (1, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) + 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) * 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) * 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "level = [None] * len(res)",
      "mutated_line": "level = [None] / len(res)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] / len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "level = [None] * len(res)",
      "mutated_line": "level = [None] + len(res)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] + len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "level = [None] * len(res)",
      "mutated_line": "level = [None] ** len(res)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] ** len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "level[s] = 0",
      "mutated_line": "level[s] = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 1\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "level[s] = 0",
      "mutated_line": "level[s] = -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = -1\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "level[s] = 0",
      "mutated_line": "level[s] = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 1\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if level[t] is None:",
      "mutated_line": "if level[t] is not None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is not None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (1, 2 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (1, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (-1, 2 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (-1, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (1, 2 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (1, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N - 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N - 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N * 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N * 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] / (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] / (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] + (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] + (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] ** (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] ** (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if A != B:",
      "mutated_line": "if A == B:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A == B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "results.append(N - max_flow)",
      "mutated_line": "results.append(N + max_flow)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N + max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "results.append(N - max_flow)",
      "mutated_line": "results.append(N * max_flow)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N * max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] >= 0 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] >= 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] <= 0 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] <= 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] != 0 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] != 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] != level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] != level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) - 2)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 2)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) - 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 0)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) - 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 0)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s, t = 0, len(res) - 1",
      "mutated_line": "(s, t) = (0, len(res) - -1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - -1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 / N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 / N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 + N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 + N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 ** N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 ** N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N + 2)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 2)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N + 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 0)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N + 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 0)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 2 * N + -1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + -1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t - 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t - 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t * 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t * 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (2, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (2, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (0, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (0, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (0, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (0, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (-1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (-1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (1, 2)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 2)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (1, 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 0)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (1, 0)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 0)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 + N][t]) = (1, -1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, -1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B + N] = 2",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 2\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B + N] = 0",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 0\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B + N] = 0",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 0\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B + N] = -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = -1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 1 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 1 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > -1 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > -1 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 1 and level[v] == level[u] + 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 1 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] - 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] - 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] * 1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] * 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "LCR",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] > 0 or level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 or level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 3 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 3 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 1 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 1 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 0 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 0 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, 1 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 1 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s, t = 0, 2 * N + 1",
      "mutated_line": "(s, t) = (0, -2 * N + 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, -2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[1] * (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[1] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[-1] * (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[-1] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[1] * (t + 1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[1] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 2) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 2) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 0) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 0) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 0) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 0) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + -1) for _ in range(t + 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + -1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t - 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t - 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t * 1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t * 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i - 1], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i - 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i * 1], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i * 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B - N] = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B - N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[A][B + N] = 1",
      "mutated_line": "res[A][B * N] = 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B * N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] + 2:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 2:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] + 0:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 0:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] + 0:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 0:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if res[u][v] > 0 and level[v] == level[u] + 1:",
      "mutated_line": "if res[u][v] > 0 and level[v] == level[u] + -1:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + -1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] >= 0 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] >= 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] <= 0 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] <= 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] != 0 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] != 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] > 0 and level[v] is not None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is not None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] - 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] - 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] * 1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] * 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t + 2)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 2)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t + 0)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 0)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t + 0)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 0)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [[0] * (t + 1) for _ in range(t + 1)]",
      "mutated_line": "res = [[0] * (t + 1) for _ in range(t + -1)]",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + -1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 2], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 2], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 0], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 0], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 0], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 0], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + -1], res[i + 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + -1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 1 - N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 - N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[(i + 1) * N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[(i + 1) * N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] > 1 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 1 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] > -1 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > -1 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if res[u][v] > 0 and level[v] is None:",
      "mutated_line": "if res[u][v] > 1 and level[v] is None:",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 1 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] + 2",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 2\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] + 0",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 0\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] + 0",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 0\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "level[v] = level[u] + 1",
      "mutated_line": "level[v] = level[u] + -1",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + -1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i - 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i - 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i * 1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i * 1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 2 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 2 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 0 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 0 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + 0 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + 0 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res[s][i + 1], res[i + 1 + N][t] = 1, 1",
      "mutated_line": "(res[s][i + 1], res[i + -1 + N][t]) = (1, 1)",
      "code": "def minimum_lines_for_recipe(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, relations) = case\n        (s, t) = (0, 2 * N + 1)\n        res = [[0] * (t + 1) for _ in range(t + 1)]\n        for i in range(N):\n            (res[s][i + 1], res[i + -1 + N][t]) = (1, 1)\n        for (A, B) in relations:\n            if A != B:\n                res[A][B + N] = 1\n        max_flow = dinic(res)\n        results.append(N - max_flow)\n    return results\n\ndef augment(res, u, t, level, limit):\n    if limit == 0:\n        return 0\n    if u == t:\n        return limit\n    flow = 0\n    for v in range(len(res)):\n        if res[u][v] > 0 and level[v] == level[u] + 1:\n            aug = augment(res, v, t, level, min(limit, res[u][v]))\n            res[u][v] -= aug\n            res[v][u] += aug\n            flow += aug\n            limit -= aug\n    if not flow:\n        level[u] = None\n    return flow\n\ndef dinic(res):\n    from collections import deque\n    q = deque()\n    max_flow = 0\n    (s, t) = (0, len(res) - 1)\n    while True:\n        q.append(s)\n        level = [None] * len(res)\n        level[s] = 0\n        while q:\n            u = q.popleft()\n            for v in range(len(res)):\n                if res[u][v] > 0 and level[v] is None:\n                    level[v] = level[u] + 1\n                    q.append(v)\n        if level[t] is None:\n            return max_flow\n        max_flow += augment(res, s, t, level, sum((res[s][v] for v in range(len(res)))))"
    }
  ]
}