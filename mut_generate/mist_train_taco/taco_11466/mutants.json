{
  "task_id": "taco_11466",
  "entry_point": "min_cost_to_equalize_binary_strings",
  "mutant_count": 148,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 2 == 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 == 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(zs) == 0:",
      "mutated_line": "if len(zs) != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) != 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if x >= y:",
      "mutated_line": "if x > y:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x > y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if x >= y:",
      "mutated_line": "if x < y:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x < y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if x >= y:",
      "mutated_line": "if x == y:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x == y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] / 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] / 2"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] * 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] * 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) * 2 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) * 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) + 2 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) + 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 2 != 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 1:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 2 != -1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != -1:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 2 != 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 1:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return +1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(zs) == 0:",
      "mutated_line": "if len(zs) == 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 1:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(zs) == 0:",
      "mutated_line": "if len(zs) == -1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == -1:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(zs) == 0:",
      "mutated_line": "if len(zs) == 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 1:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 1\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return -1\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 1\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 or zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 or zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i != 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] // 3",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] // 1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] // 0",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] // 1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-1] // -2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // -2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "zs = [i for i, (c, d) in enumerate(zip(a, b)) if c != d]",
      "mutated_line": "zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c == d]",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c == d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 3 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 3 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 1 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 1 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 0 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 0 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % 1 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 1 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(zs) % 2 != 0:",
      "mutated_line": "if len(zs) % -2 != 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % -2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -2\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -0\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -0\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return --1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) != 2 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) != 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 1 != zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 != zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 2 / y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 / y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 2 + y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 + y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return (len(zs) // 2) ** y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return (len(zs) // 2) ** y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 1:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == -1:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 1:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif i == 1:",
      "mutated_line": "elif i != 1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i != 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[+1] // 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[+1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 3 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 3 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 1 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 1 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 0 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 0 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 1 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 1 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == -2 and zs[0] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == -2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] - 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] - 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] * 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] * 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 2 / y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 / y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 2 + y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 + y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 2 ** y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 ** y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) / 2 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) / 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) * 2 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) * 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif i == 1:",
      "mutated_line": "elif i == 2:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 2:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif i == 1:",
      "mutated_line": "elif i == 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 0:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif i == 1:",
      "mutated_line": "elif i == 0:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 0:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif i == 1:",
      "mutated_line": "elif i == -1:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == -1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-2] // 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-2] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-0] // 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[-0] // 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return f[-1] // 2",
      "mutated_line": "return f[--1] // 2",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[--1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 2 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 2 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 0 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 0 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 0 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 0 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + -1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + -1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 1 == zs[2]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[2]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 1 == zs[0]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[0]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 1 == zs[0]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[0]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[0] + 1 == zs[-1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[-1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 3 * y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 3 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 1 * y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 1 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 0 * y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 0 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, 1 * y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 1 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(x, 2 * y)",
      "mutated_line": "return min(x, -2 * y)",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, -2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 3 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 3 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 1 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 1 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 0 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 0 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // 1 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 1 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(zs) // 2 * y",
      "mutated_line": "return len(zs) // -2 * y",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // -2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 / y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 / y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 + y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 + y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 ** y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 ** y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x / (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x / (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x + (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x + (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, (2 * x) ** (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, (2 * x) ** (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) - f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) - f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) * f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) * f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y - f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y - f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y * f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y * f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[1] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[1] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[-1] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[-1] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(zs) == 2 and zs[0] + 1 == zs[1]:",
      "mutated_line": "if len(zs) == 2 and zs[1] + 1 == zs[1]:",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[1] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(3 * y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(3 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(1 * y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(1 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(0 * y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(0 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(1 * y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(1 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(-2 * y, 2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(-2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 / x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 / x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, (2 + x) * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, (2 + x) * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 ** x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 ** x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x * (z + zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z + zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x * (z * zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z * zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x / (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x / (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x + (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x + (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min((2 * x) ** (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min((2 * x) ** (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 3 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 3 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 1 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 1 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 0 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 0 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 1 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 1 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, -2 * x * (z - zs[0]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, -2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 / x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 / x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min((2 + x) * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min((2 + x) * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 ** x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 ** x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z + zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z + zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z * zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z * zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i + 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i + 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i * 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i * 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i + 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i + 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i * 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i * 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x * (z - zs[1]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[1]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x * (z - zs[-1]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[-1]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur = min(2 * y, 2 * x * (z - zs[0]))",
      "mutated_line": "cur = min(2 * y, 2 * x * (z - zs[1]))",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[1]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(3 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(3 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(1 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(1 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(0 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(0 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(1 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(1 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(-2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(-2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 3], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 3], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 1], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 1], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 0], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 0], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 1], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 1], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - -2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - -2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 2])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 2])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 0])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 0])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 0])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 0])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - -1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - -1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i + 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i + 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i * 1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i * 1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 2]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 2]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 0]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 0]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - 0]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - 0]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cur = min(2 * x * (z - zs[i - 1]) + f[i - 2], y + f[i - 1])",
      "mutated_line": "cur = min(2 * x * (z - zs[i - -1]) + f[i - 2], y + f[i - 1])",
      "code": "def min_cost_to_equalize_binary_strings(n, x, y, a, b):\n    \"\"\"\n    Calculate the minimum cost needed to make binary string `a` equal to binary string `b`\n    using the specified operations.\n\n    Parameters:\n    - n (int): The length of the binary strings.\n    - x (int): The cost for an operation where `l + 1 = r`.\n    - y (int): The cost for an operation where `l + 1 != r`.\n    - a (str): The first binary string.\n    - b (str): The second binary string.\n\n    Returns:\n    - int: The minimum cost needed to make `a` equal to `b`, or `-1` if it's not possible.\n    \"\"\"\n    zs = [i for (i, (c, d)) in enumerate(zip(a, b)) if c != d]\n    if len(zs) % 2 != 0:\n        return -1\n    if len(zs) == 0:\n        return 0\n    if x >= y:\n        if len(zs) == 2 and zs[0] + 1 == zs[1]:\n            return min(x, 2 * y)\n        else:\n            return len(zs) // 2 * y\n    f = []\n    for (i, z) in enumerate(zs):\n        if i == 0:\n            cur = y\n        elif i == 1:\n            cur = min(2 * y, 2 * x * (z - zs[0]))\n        else:\n            cur = min(2 * x * (z - zs[i - -1]) + f[i - 2], y + f[i - 1])\n        f.append(cur)\n    return f[-1] // 2"
    }
  ]
}