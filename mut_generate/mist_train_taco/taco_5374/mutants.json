{
  "task_id": "taco_5374",
  "entry_point": "merge_intervals",
  "mutant_count": 13,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "current_start, current_end = intervals[0]",
      "mutated_line": "(current_start, current_end) = intervals[1]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[1]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "current_start, current_end = intervals[0]",
      "mutated_line": "(current_start, current_end) = intervals[-1]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[-1]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "current_start, current_end = intervals[0]",
      "mutated_line": "(current_start, current_end) = intervals[1]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[1]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if start <= current_end:",
      "mutated_line": "if start < current_end:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start < current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if start <= current_end:",
      "mutated_line": "if start > current_end:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start > current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if start <= current_end:",
      "mutated_line": "if start == current_end:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start == current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for start, end in intervals[1:]:",
      "mutated_line": "for (start, end) in intervals[2:]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[2:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for start, end in intervals[1:]:",
      "mutated_line": "for (start, end) in intervals[0:]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[0:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for start, end in intervals[1:]:",
      "mutated_line": "for (start, end) in intervals[0:]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[0:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for start, end in intervals[1:]:",
      "mutated_line": "for (start, end) in intervals[-1:]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[-1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[1])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[-1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[-1])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[1])\n    merged = []\n    (current_start, current_end) = intervals[0]\n    for (start, end) in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            (current_start, current_end) = (start, end)\n    merged.append([current_start, current_end])\n    return merged"
    }
  ]
}