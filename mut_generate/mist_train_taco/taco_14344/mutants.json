{
  "task_id": "taco_14344",
  "entry_point": "count_distinct_arrays",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "MOD = 10 ** 9 - 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "MOD = 10 ** 9 * 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "MOD = 10 * 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "MOD = 10 + 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "MOD = 10 ** 9 + 8\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "MOD = 10 ** 9 + 6\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "MOD = 10 ** 9 + 0\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "MOD = 10 ** 9 + 1\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "MOD = 10 ** 9 + -7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 and next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 and next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "MOD = 11 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "MOD = 9 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "MOD = 0 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "MOD = 1 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "MOD = -10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "MOD = 10 ** 10 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "MOD = 10 ** 8 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "MOD = 10 ** 0 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "MOD = 10 ** 1 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "MOD = 10 ** -9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 0): 2}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 2}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 0): 0}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 0}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 0): 0}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 0}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 0): -1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): -1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) >= 1 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) >= 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) <= 1 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) <= 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) != 1 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) != 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) == (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) == (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if next1 not in ln:",
      "mutated_line": "if next1 in ln:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while lnp < K:",
      "mutated_line": "while lnp <= K:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp <= K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while lnp < K:",
      "mutated_line": "while lnp >= K:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp >= K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while lnp < K:",
      "mutated_line": "while lnp != K:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp != K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "lastm += 1",
      "mutated_line": "lastm -= 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm -= 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "next1 -= 1",
      "mutated_line": "next1 += 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 += 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "next2 += 1",
      "mutated_line": "next2 -= 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 -= 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(1, 0): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(1, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(-1, 0): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(-1, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(1, 0): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(1, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 1): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 1): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, -1): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, -1): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = {(0, 0): 1}",
      "mutated_line": "p = {(0, 1): 1}",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 1): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 2 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 2 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 0 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 0 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 0 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 0 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > -1 or next(iter(p.keys())) != (0, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > -1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = process(p, 0)",
      "mutated_line": "p = process(p, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 1)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = process(p, 0)",
      "mutated_line": "p = process(p, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, -1)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = process(p, 0)",
      "mutated_line": "p = process(p, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 1)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[1, 0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[-1, 0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[-1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[1, 0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[0, 1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[0, -1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, -1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return p[0, 0]",
      "mutated_line": "return p[0, 1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[1] - num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] - num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[1] * num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] * num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (1, 0, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (1, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (-1, 0, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (-1, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (1, 0, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (1, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, 1, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 1, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, -1, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, -1, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, 1, 0, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 1, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, 0, 1, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 1, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, 0, -1, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, -1, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(lnp, lastm, next2, K) = (0, 0, 0, len(ln1))",
      "mutated_line": "(lnp, lastm, next2, K) = (0, 0, 1, len(ln1))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 1, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = (g.get(nkey, 0) + lns) * MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) * MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = g.get(nkey, 0) + lns + MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = g.get(nkey, 0) + lns + MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K or lastm >= ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K or lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "lns -= ln1[lnp][1]",
      "mutated_line": "lns += ln1[lnp][1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns += ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "lnp += 1",
      "mutated_line": "lnp -= 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp -= 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if next1 == 0:",
      "mutated_line": "if next1 != 0:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 != 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lastm += 1",
      "mutated_line": "lastm += 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 2\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lastm += 1",
      "mutated_line": "lastm += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 0\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lastm += 1",
      "mutated_line": "lastm += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 0\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lastm += 1",
      "mutated_line": "lastm += -1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += -1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next1 -= 1",
      "mutated_line": "next1 -= 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 2\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next1 -= 1",
      "mutated_line": "next1 -= 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 0\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next1 -= 1",
      "mutated_line": "next1 -= 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 0\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next1 -= 1",
      "mutated_line": "next1 -= -1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= -1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next2 += 1",
      "mutated_line": "next2 += 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 2\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next2 += 1",
      "mutated_line": "next2 += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 0\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next2 += 1",
      "mutated_line": "next2 += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 0\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next2 += 1",
      "mutated_line": "next2 += -1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += -1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (1, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (1, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (-1, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (-1, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (1, 0):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (1, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 1):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 1):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (0, -1):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, -1):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 0):",
      "mutated_line": "while len(p) > 1 or next(iter(p.keys())) != (0, 1):",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 1):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[1], key[1] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[1], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[-1], key[1] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[-1], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[1], key[1] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[1], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = (g.get(nkey, 0) - lns) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) - lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = g.get(nkey, 0) * lns % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = g.get(nkey, 0) * lns % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp <= K and lastm >= ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp <= K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp >= K and lastm >= ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp >= K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp != K and lastm >= ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp != K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm > ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm > ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm < ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm < ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm == ln1[lnp][0]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm == ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lnp += 1",
      "mutated_line": "lnp += 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 2\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lnp += 1",
      "mutated_line": "lnp += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 0\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lnp += 1",
      "mutated_line": "lnp += 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 0\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lnp += 1",
      "mutated_line": "lnp += -1",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += -1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if next1 == 0:",
      "mutated_line": "if next1 == 1:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 1:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if next1 == 0:",
      "mutated_line": "if next1 == -1:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == -1:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if next1 == 0:",
      "mutated_line": "if next1 == 1:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 1:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[2] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[2] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[0] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[0] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[0] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[0] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(last1, next1) = (key[0], key[1] + num)",
      "mutated_line": "(last1, next1) = (key[0], key[-1] + num)",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[-1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lns = sum((p[1] for p in ln[next1]))",
      "mutated_line": "lns = sum((p[2] for p in ln[next1]))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[2] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lns = sum((p[1] for p in ln[next1]))",
      "mutated_line": "lns = sum((p[0] for p in ln[next1]))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[0] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lns = sum((p[1] for p in ln[next1]))",
      "mutated_line": "lns = sum((p[0] for p in ln[next1]))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[0] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lns = sum((p[1] for p in ln[next1]))",
      "mutated_line": "lns = sum((p[-1] for p in ln[next1]))",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[-1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lns -= ln1[lnp][1]",
      "mutated_line": "lns -= ln1[lnp][2]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][2]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lns -= ln1[lnp][1]",
      "mutated_line": "lns -= ln1[lnp][0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][0]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lns -= ln1[lnp][1]",
      "mutated_line": "lns -= ln1[lnp][0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][0]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lns -= ln1[lnp][1]",
      "mutated_line": "lns -= ln1[lnp][-1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][-1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = (g.get(nkey, 1) + lns) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 1) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = (g.get(nkey, -1) + lns) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, -1) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[nkey] = (g.get(nkey, 0) + lns) % MOD",
      "mutated_line": "g[nkey] = (g.get(nkey, 1) + lns) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 1) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][0]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm >= ln1[lnp][1]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][1]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm >= ln1[lnp][-1]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][-1]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while lnp < K and lastm >= ln1[lnp][0]:",
      "mutated_line": "while lnp < K and lastm >= ln1[lnp][1]:",
      "code": "MOD = 10 ** 9 + 7\n\ndef count_distinct_arrays(N, A):\n\n    def process(p, num):\n        (g, ln) = ({}, {})\n        for (key, value) in p.items():\n            (last1, next1) = (key[0], key[1] + num)\n            if next1 not in ln:\n                ln[next1] = [(last1, value)]\n            else:\n                ln[next1].append((last1, value))\n            ln[next1].sort()\n        for (next1, ln1) in ln.items():\n            lns = sum((p[1] for p in ln[next1]))\n            (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n            while lnp < K:\n                nkey = (next1, next2)\n                g[nkey] = (g.get(nkey, 0) + lns) % MOD\n                while lnp < K and lastm >= ln1[lnp][1]:\n                    lns -= ln1[lnp][1]\n                    lnp += 1\n                if next1 == 0:\n                    break\n                lastm += 1\n                next1 -= 1\n                next2 += 1\n        return g\n    p = {(0, 0): 1}\n    for num in A:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    return p[0, 0]"
    }
  ]
}