{
  "task_id": "taco_15736",
  "entry_point": "find_final_sequence",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while False:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "loop = new_index // N",
      "mutated_line": "loop = new_index / N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index / N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "loop = new_index // N",
      "mutated_line": "loop = new_index * N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index * N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if K == 0:",
      "mutated_line": "if K != 0:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K != 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "empty_index = [0]",
      "mutated_line": "empty_index = [1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [1]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "empty_index = [0]",
      "mutated_line": "empty_index = [-1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [-1]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "empty_index = [0]",
      "mutated_line": "empty_index = [1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [1]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(indices_of_elem[look_for_elem]) == index_of_indices:",
      "mutated_line": "if len(indices_of_elem[look_for_elem]) != index_of_indices:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) != index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index - 1",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index - 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index * 1",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index * 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index % N != 0:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N != 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 1:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if K == 0:",
      "mutated_line": "if K == -1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == -1:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 1:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] * N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] * N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] + N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if elem in index_for_tmp_ans:",
      "mutated_line": "if elem not in index_for_tmp_ans:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem not in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] / (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] / (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] + (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] + (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] ** (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] ** (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "cur_index = empty_index[-1]",
      "mutated_line": "cur_index = empty_index[+1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[+1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "look_for_elem = A[cur_index % N]",
      "mutated_line": "look_for_elem = A[cur_index * N]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index * N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "look_for_elem = A[cur_index % N]",
      "mutated_line": "look_for_elem = A[cur_index + N]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index + N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)",
      "mutated_line": "index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index * N)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index * N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)",
      "mutated_line": "index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index + N)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index + N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] - N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] - N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = (cur_index // N * N + indices_of_elem[look_for_elem][0]) * N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = (cur_index // N * N + indices_of_elem[look_for_elem][0]) * N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index // N * N - indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N - indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index // N * N * indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N * indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index + 2",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 2\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index + 0",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 0\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index + 0",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 0\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_index = pair_end_index + 1",
      "mutated_line": "new_index = pair_end_index + -1",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + -1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index * N == 0:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index * N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index + N == 0:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index + N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index % N == 1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 1:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index % N == -1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == -1:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if new_index % N == 0:",
      "mutated_line": "if new_index % N == 1:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 1:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while False:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end - start - 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start - 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * ((end - start) * 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * ((end - start) * 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans == -1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans == -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cur_index = empty_index[-1]",
      "mutated_line": "cur_index = empty_index[-2]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-2]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cur_index = empty_index[-1]",
      "mutated_line": "cur_index = empty_index[-0]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-0]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cur_index = empty_index[-1]",
      "mutated_line": "cur_index = empty_index[-0]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-0]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cur_index = empty_index[-1]",
      "mutated_line": "cur_index = empty_index[--1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[--1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N - indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N - indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N * indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N * indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index // N / N + indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N / N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index // N + N + indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N + N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = (cur_index // N) ** N + indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = (cur_index // N) ** N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) + 1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) + 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) * 1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) * 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if k == elem:",
      "mutated_line": "if k != elem:",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k != elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end - 1] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end - 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end * 1] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end * 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [+1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [+1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end + start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end + start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end * start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end * start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 2)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 2)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 0)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 0)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 0)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 0)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-1] * (end - start + -1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + -1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans != +1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != +1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N / N + indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N / N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N + N + indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N + N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = (cur_index // N) ** N + indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = (cur_index // N) ** N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index / N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index / N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "mutated_line": "pair_end_index = cur_index * N * N + indices_of_elem[look_for_elem][index_of_indices]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index * N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - 2] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 2] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - 0] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 0] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - 0] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 0] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K * N) - -1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - -1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 2] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 2] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 0] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 0] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 0] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 0] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + -1] = [-1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + -1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-2] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-2] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-0] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-0] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [-0] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-0] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tmp_ans[start:end + 1] = [-1] * (end - start + 1)",
      "mutated_line": "tmp_ans[start:end + 1] = [--1] * (end - start + 1)",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [--1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans != -2]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -2]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans != -0]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -0]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans != -0]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -0]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "final_sequence = [ans for ans in tmp_ans if ans != -1]",
      "mutated_line": "final_sequence = [ans for ans in tmp_ans if ans != --1]",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != --1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index / N * N + indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index / N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index * N * N + indices_of_elem[look_for_elem][0] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index * N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][1] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][1] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][-1] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][-1] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N",
      "mutated_line": "pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][1] + N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][1] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K * N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K / N) - 1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K / N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K + N) - 1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K + N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "start = empty_index[bisect_right(empty_index, K * N) - 1] % N",
      "mutated_line": "start = empty_index[bisect_right(empty_index, K ** N) - 1] % N",
      "code": "from bisect import bisect_right\nfrom collections import defaultdict\n\ndef find_final_sequence(N, K, A):\n    indices_of_elem = defaultdict(list)\n    for (i, A_val) in enumerate(A):\n        indices_of_elem[A_val].append(i)\n    empty_index = [0]\n    while True:\n        cur_index = empty_index[-1]\n        look_for_elem = A[cur_index % N]\n        index_of_indices = bisect_right(indices_of_elem[look_for_elem], cur_index % N)\n        if len(indices_of_elem[look_for_elem]) == index_of_indices:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][0] + N\n        else:\n            pair_end_index = cur_index // N * N + indices_of_elem[look_for_elem][index_of_indices]\n        new_index = pair_end_index + 1\n        empty_index.append(new_index)\n        if new_index % N == 0:\n            break\n    loop = new_index // N\n    K %= loop\n    if K == 0:\n        return []\n    else:\n        start = empty_index[bisect_right(empty_index, K ** N) - 1] % N\n        tmp_ans = A[start:]\n    index_for_tmp_ans = dict()\n    split = []\n    for (i, elem) in enumerate(tmp_ans):\n        if elem in index_for_tmp_ans:\n            split.append((index_for_tmp_ans[elem], i))\n            while True:\n                (k, v) = index_for_tmp_ans.popitem()\n                if k == elem:\n                    break\n        else:\n            index_for_tmp_ans[elem] = i\n    for (start, end) in split:\n        tmp_ans[start:end + 1] = [-1] * (end - start + 1)\n    final_sequence = [ans for ans in tmp_ans if ans != -1]\n    return final_sequence"
    }
  ]
}