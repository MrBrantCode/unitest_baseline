{
  "task_id": "taco_16114",
  "entry_point": "nck",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "from math import factorial, sqrt\nMOD = 1000000008\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "from math import factorial, sqrt\nMOD = 1000000006\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "from math import factorial, sqrt\nMOD = 0\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "from math import factorial, sqrt\nMOD = 1\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "from math import factorial, sqrt\nMOD = -1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 1\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = -1\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 1\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res -= factorial(n) // (factorial(i) * factorial(n - i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res -= factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if N == 1:",
      "mutated_line": "if N != 1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N != 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "is_periodic = False",
      "mutated_line": "is_periodic = True",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = True\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (total - is_periodic) % MOD",
      "mutated_line": "return (total - is_periodic) * MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (total - is_periodic) % MOD",
      "mutated_line": "return total - is_periodic + MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return total - is_periodic + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k - 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k - 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k * 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k * 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) / (factorial(i) * factorial(n - i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) / (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) * (factorial(i) * factorial(n - i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) * (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d1 = [1]",
      "mutated_line": "d1 = [2]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [2]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d1 = [1]",
      "mutated_line": "d1 = [0]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [0]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d1 = [1]",
      "mutated_line": "d1 = [0]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [0]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d1 = [1]",
      "mutated_line": "d1 = [-1]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [-1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(3, int(sqrt(n)) + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(3, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(1, int(sqrt(n)) + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(0, int(sqrt(n)) + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(0, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(1, int(sqrt(n)) + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(-2, int(sqrt(n)) + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(-2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) - 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) - 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) * 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) * 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i != 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i != 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 2:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 2:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 0:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 0:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if N == 1:",
      "mutated_line": "if N == -1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == -1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (N + K) % MOD",
      "mutated_line": "return (N + K) * MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) * MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (N + K) % MOD",
      "mutated_line": "return N + K + MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return N + K + MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] / (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] / (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] + (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] + (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] ** (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] ** (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][0] = 2",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 2\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][0] = 0",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 0\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][0] = 0",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 0\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][0] = -1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = -1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "total -= dp[i][k]",
      "mutated_line": "total += dp[i][k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total += dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (total - is_periodic) % MOD",
      "mutated_line": "return (total + is_periodic) % MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total + is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (total - is_periodic) % MOD",
      "mutated_line": "return total * is_periodic % MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return total * is_periodic % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 2):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 2):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 0):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 0):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + -1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + -1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) // (factorial(i) / factorial(n - i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) / factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) // (factorial(i) + factorial(n - i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) + factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) // factorial(i) ** factorial(n - i)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // factorial(i) ** factorial(n - i)\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 2):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 2):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 0):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 0):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + -1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + -1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n * i == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n * i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n + i == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n + i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 1:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == -1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == -1:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 1:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i * i != n:",
      "mutated_line": "if i * i == n:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i == n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (N + K) % MOD",
      "mutated_line": "return (N - K) % MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N - K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (N + K) % MOD",
      "mutated_line": "return N * K % MOD",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return N * K % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N + K - 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K - 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * ((N + K) * 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * ((N + K) * 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][1] = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][1] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][-1] = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][-1] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i][0] = 1",
      "mutated_line": "dp[i][1] = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][1] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "zeros = 0",
      "mutated_line": "zeros = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 1\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "zeros = 0",
      "mutated_line": "zeros = -1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = -1\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "zeros = 0",
      "mutated_line": "zeros = 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 1\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ones = N // d - zeros",
      "mutated_line": "ones = N // d + zeros",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d + zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ones = N // d - zeros",
      "mutated_line": "ones = N // d * zeros",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d * zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] / (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] / (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] + (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] + (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] ** (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] ** (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[i][0]:",
      "mutated_line": "if dp[i][1]:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][1]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[i][0]:",
      "mutated_line": "if dp[i][-1]:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][-1]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[i][0]:",
      "mutated_line": "if dp[i][1]:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][1]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "is_periodic = True",
      "mutated_line": "is_periodic = False",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = False\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d % d2 != 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 != 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(2, K + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(2, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(0, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(0, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(-1, K + 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(-1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K - 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K - 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K * 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K * 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if i * i != n:",
      "mutated_line": "if i / i != n:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i / i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if i * i != n:",
      "mutated_line": "if i + i != n:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i + i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if i * i != n:",
      "mutated_line": "if i ** i != n:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i ** i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "d1.extend(d2[::-1])",
      "mutated_line": "d1.extend(d2[::+1])",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::+1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[1] * (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[1] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[-1] * (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[-1] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[1] * (N + K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[1] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N - K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N - K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N * K + 1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N * K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N + K + 2) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 2) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N + K + 0) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 0) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N + K + 0) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 0) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [[0] * (N + K + 1) for i in range(len(div))]",
      "mutated_line": "dp = [[0] * (N + K + -1) for i in range(len(div))]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + -1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if S[j] == '0':",
      "mutated_line": "if S[j] != '0':",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] != '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "zeros += 1",
      "mutated_line": "zeros -= 1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros -= 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ones = N // d - zeros",
      "mutated_line": "ones = N / d - zeros",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N / d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ones = N // d - zeros",
      "mutated_line": "ones = N * d - zeros",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N * d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N + K - 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K - 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * ((N + K) * 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * ((N + K) * 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K - 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K - 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K * 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K * 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "dp[i][k + zeros] += prev[k]",
      "mutated_line": "dp[i][k + zeros] -= prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] -= prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "dp[i][k + ones] += prev[k]",
      "mutated_line": "dp[i][k + ones] -= prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] -= prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d * d2 == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d * d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d + d2 == 0:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d + d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d % d2 == 1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 1:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d % d2 == -1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == -1:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if d % d2 == 0:",
      "mutated_line": "if d % d2 == 1:",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 1:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "dp[i][k] -= dp[i2][k]",
      "mutated_line": "dp[i][k] += dp[i2][k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] += dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 2):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 2):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 0):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 0):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + -1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + -1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) // (factorial(i) * factorial(n + i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n + i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res += factorial(n) // (factorial(i) * factorial(n - i))",
      "mutated_line": "res += factorial(n) // (factorial(i) * factorial(n * i))",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n * i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d2.append(n // i)",
      "mutated_line": "d2.append(n / i)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n / i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d2.append(n // i)",
      "mutated_line": "d2.append(n * i)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n * i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d1.extend(d2[::-1])",
      "mutated_line": "d1.extend(d2[::-2])",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-2])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d1.extend(d2[::-1])",
      "mutated_line": "d1.extend(d2[::-0])",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-0])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d1.extend(d2[::-1])",
      "mutated_line": "d1.extend(d2[::-0])",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-0])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d1.extend(d2[::-1])",
      "mutated_line": "d1.extend(d2[::--1])",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::--1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if S[j] == '0':",
      "mutated_line": "if S[j] == '':",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "zeros += 1",
      "mutated_line": "zeros += 2",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 2\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "zeros += 1",
      "mutated_line": "zeros += 0",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 0\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "zeros += 1",
      "mutated_line": "zeros += 0",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 0\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "zeros += 1",
      "mutated_line": "zeros += -1",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += -1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [1] * (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [1] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [-1] * (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [-1] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [1] * (N + K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [1] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N - K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N - K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N * K + 1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N * K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N + K + 2)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 2)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N + K + 0)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 0)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N + K + 0)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 0)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i][:] = [0] * (N + K + 1)",
      "mutated_line": "dp[i][:] = [0] * (N + K + -1)",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + -1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 2):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 2):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 0):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 0):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + -1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + -1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K - 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K - 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K * 1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K * 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i][k + zeros] += prev[k]",
      "mutated_line": "dp[i][k - zeros] += prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k - zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i][k + zeros] += prev[k]",
      "mutated_line": "dp[i][k * zeros] += prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k * zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i][k + ones] += prev[k]",
      "mutated_line": "dp[i][k - ones] += prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k - ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i][k + ones] += prev[k]",
      "mutated_line": "dp[i][k * ones] += prev[k]",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k * ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 2):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 2):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 0):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + 0):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + 0):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for k in range(K + 1):",
      "mutated_line": "for k in range(K + -1):",
      "code": "from math import factorial, sqrt\nMOD = 1000000007\n\ndef nck(n, k):\n    res = 0\n    for i in range(k + 1):\n        res += factorial(n) // (factorial(i) * factorial(n - i))\n    return res\n\ndef divisors(n):\n    d1 = [1]\n    d2 = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            d1.append(i)\n            if i * i != n:\n                d2.append(n // i)\n    d1.extend(d2[::-1])\n    return d1\n\ndef count_possible_strings(N, K, S):\n    if N == 1:\n        return (N + K) % MOD\n    total = nck(N, K)\n    div = divisors(N)\n    dp = [[0] * (N + K + 1) for i in range(len(div))]\n    is_periodic = False\n    for (i, d) in enumerate(div):\n        dp[i][0] = 1\n        for offset in range(d):\n            zeros = 0\n            for j in range(offset, N, d):\n                if S[j] == '0':\n                    zeros += 1\n            ones = N // d - zeros\n            prev = list(dp[i])\n            dp[i][:] = [0] * (N + K + 1)\n            for k in range(K + 1):\n                if prev[k]:\n                    dp[i][k + zeros] += prev[k]\n                    dp[i][k + ones] += prev[k]\n        if dp[i][0]:\n            is_periodic = True\n        for i2 in range(i):\n            d2 = div[i2]\n            if d % d2 == 0:\n                for k in range(K + -1):\n                    dp[i][k] -= dp[i2][k]\n        for k in range(1, K + 1):\n            total -= dp[i][k]\n    return (total - is_periodic) % MOD"
    }
  ]
}