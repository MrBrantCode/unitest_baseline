{
  "task_id": "taco_13592",
  "entry_point": "find_valid_coloring",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [2] / n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] / n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [2] + n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] + n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [2] ** n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] ** n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 1\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "flag = 0",
      "mutated_line": "flag = -1",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = -1\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 1\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if flag == 0:",
      "mutated_line": "if flag != 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag != 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(11):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(11):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(9):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(9):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(0):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(0):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(1):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(1):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(-10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(-10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) >= 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) >= 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) <= 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) <= 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) != 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) != 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i - 1, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i - 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i * 1, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i * 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 1, 11):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 11):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 1, 9):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 9):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 1, 0):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 0):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 1, 1):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 1):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 1, -10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, -10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(indexes[j]) == 0:",
      "mutated_line": "if len(indexes[j]) != 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) != 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "nodes[item] = 1",
      "mutated_line": "nodes[item] = 2",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 2\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "nodes[item] = 1",
      "mutated_line": "nodes[item] = 0",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 0\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "nodes[item] = 1",
      "mutated_line": "nodes[item] = 0",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 0\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "nodes[item] = 1",
      "mutated_line": "nodes[item] = -1",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = -1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if nodes[i] == 1:",
      "mutated_line": "if nodes[i] != 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] != 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(2, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(0, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(0, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(-1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] <= left[i - 1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] <= left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] >= left[i - 1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] >= left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] != left[i - 1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] != left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if flag == 0:",
      "mutated_line": "if flag == 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 1:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if flag == 0:",
      "mutated_line": "if flag == -1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == -1:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if flag == 0:",
      "mutated_line": "if flag == 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 1:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return '-'",
      "mutated_line": "return ''",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) > 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 1:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) > -1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > -1:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(indexes[i]) > 0:",
      "mutated_line": "if len(indexes[i]) > 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 1:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 2, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 2, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 0, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 0, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + 0, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 0, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, 10):",
      "mutated_line": "for j in range(i + -1, 10):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + -1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(indexes[j]) == 0:",
      "mutated_line": "if len(indexes[j]) == 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 1:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(indexes[j]) == 0:",
      "mutated_line": "if len(indexes[j]) == -1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == -1:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(indexes[j]) == 0:",
      "mutated_line": "if len(indexes[j]) == 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 1:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if idx < len(indexes[j]):",
      "mutated_line": "if idx <= len(indexes[j]):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx <= len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if idx < len(indexes[j]):",
      "mutated_line": "if idx >= len(indexes[j]):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx >= len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if idx < len(indexes[j]):",
      "mutated_line": "if idx != len(indexes[j]):",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx != len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [3] * n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [3] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [1] * n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [1] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [0] * n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [0] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [1] * n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [1] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nodes = [2] * n",
      "mutated_line": "nodes = [-2] * n",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [-2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if nodes[i] == 1:",
      "mutated_line": "if nodes[i] == 2:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 2:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if nodes[i] == 1:",
      "mutated_line": "if nodes[i] == 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 0:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if nodes[i] == 1:",
      "mutated_line": "if nodes[i] == 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 0:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if nodes[i] == 1:",
      "mutated_line": "if nodes[i] == -1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == -1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "flag = 1",
      "mutated_line": "flag = 2",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 2\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 0\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 0\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "flag = 1",
      "mutated_line": "flag = -1",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = -1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "indexes = [[] for _ in range(10)]",
      "mutated_line": "indexes = [[] for _ in range(11)]",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(11)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "indexes = [[] for _ in range(10)]",
      "mutated_line": "indexes = [[] for _ in range(9)]",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(9)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "indexes = [[] for _ in range(10)]",
      "mutated_line": "indexes = [[] for _ in range(0)]",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(0)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "indexes = [[] for _ in range(10)]",
      "mutated_line": "indexes = [[] for _ in range(1)]",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(1)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "indexes = [[] for _ in range(10)]",
      "mutated_line": "indexes = [[] for _ in range(-10)]",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(-10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if idx != 0:",
      "mutated_line": "if idx == 0:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx == 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i + 1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i + 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i * 1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i * 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return ''.join(map(str, nodes))",
      "mutated_line": "return 'MUTATED'.join(map(str, nodes))",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return 'MUTATED'.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indexes[ord(digits[j]) - ord('0')].append(j)",
      "mutated_line": "indexes[ord(digits[j]) + ord('0')].append(j)",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) + ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indexes[ord(digits[j]) - ord('0')].append(j)",
      "mutated_line": "indexes[ord(digits[j]) * ord('0')].append(j)",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) * ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "idx = bisect.bisect_left(indexes[j], stack[-1])",
      "mutated_line": "idx = bisect.bisect_left(indexes[j], stack[+1])",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[+1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if idx != 0:",
      "mutated_line": "if idx != 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 1:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if idx != 0:",
      "mutated_line": "if idx != -1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != -1:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if idx != 0:",
      "mutated_line": "if idx != 1:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 1:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i - 2]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 2]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i - 0]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 0]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i - 0]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 0]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if left[i] < left[i - 1]:",
      "mutated_line": "if left[i] < left[i - -1]:",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - -1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "idx = bisect.bisect_left(indexes[j], stack[-1])",
      "mutated_line": "idx = bisect.bisect_left(indexes[j], stack[-2])",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-2])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "idx = bisect.bisect_left(indexes[j], stack[-1])",
      "mutated_line": "idx = bisect.bisect_left(indexes[j], stack[-0])",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-0])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "idx = bisect.bisect_left(indexes[j], stack[-1])",
      "mutated_line": "idx = bisect.bisect_left(indexes[j], stack[-0])",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-0])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "idx = bisect.bisect_left(indexes[j], stack[-1])",
      "mutated_line": "idx = bisect.bisect_left(indexes[j], stack[--1])",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('0')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[--1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indexes[ord(digits[j]) - ord('0')].append(j)",
      "mutated_line": "indexes[ord(digits[j]) - ord('')].append(j)",
      "code": "import bisect\n\ndef find_valid_coloring(n, digits):\n    indexes = [[] for _ in range(10)]\n    for j in range(n):\n        indexes[ord(digits[j]) - ord('')].append(j)\n    for i in range(10):\n        if len(indexes[i]) > 0:\n            break\n    stack = []\n    stack.extend(indexes[i])\n    for j in range(i + 1, 10):\n        if len(indexes[j]) == 0:\n            continue\n        else:\n            idx = bisect.bisect_left(indexes[j], stack[-1])\n            if idx < len(indexes[j]):\n                stack.extend(indexes[j][idx:])\n                if idx != 0:\n                    break\n            else:\n                break\n    nodes = [2] * n\n    for item in stack:\n        nodes[item] = 1\n    left = []\n    right = []\n    for i in range(n):\n        if nodes[i] == 1:\n            left.append(digits[i])\n        else:\n            right.append(digits[i])\n    left.extend(right)\n    flag = 0\n    for i in range(1, n):\n        if left[i] < left[i - 1]:\n            flag = 1\n            break\n    if flag == 0:\n        return ''.join(map(str, nodes))\n    else:\n        return '-'"
    }
  ]
}