{
  "task_id": "taco_11484",
  "entry_point": "process_multi_map_operations",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if op == 0:",
      "mutated_line": "(key, value) = params",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op != 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if key in self.mm:",
      "mutated_line": "if key not in self.mm:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key not in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if key in self.mm and self.mm[key] != []:",
      "mutated_line": "if key in self.mm or self.mm[key] != []:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm or self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if key in self.mm:",
      "mutated_line": "if key not in self.mm:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key not in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if op == 0:",
      "mutated_line": "(key, value) = params",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 1:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if op == 0:",
      "mutated_line": "(key, value) = params",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == -1:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if op == 0:",
      "mutated_line": "(key, value) = params",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 1:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif op == 1:",
      "mutated_line": "elif op != 1:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op != 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if key in self.mm and self.mm[key] != []:",
      "mutated_line": "if key not in self.mm and self.mm[key] != []:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key not in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if key in self.mm and self.mm[key] != []:",
      "mutated_line": "if key in self.mm and self.mm[key] == []:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] == []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif op == 1:",
      "mutated_line": "elif op == 2:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 2:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif op == 1:",
      "mutated_line": "elif op == 0:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 0:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif op == 1:",
      "mutated_line": "elif op == 0:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 0:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif op == 1:",
      "mutated_line": "elif op == -1:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == -1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op != 2:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op != 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[1]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[-1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[-1]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[1]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op == 3:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 3:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op == 1:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 1:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op == 0:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 0:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op == 1:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 1:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif op == 2:",
      "mutated_line": "elif op == -2:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == -2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op != 3:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op != 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[1]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[-1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[-1]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "key = params[0]",
      "mutated_line": "key = params[1]",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[1]\n            mm.delete(key)\n        elif op == 3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op == 4:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 4:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op == 2:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 2:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op == 0:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 0:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op == 1:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == 1:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif op == 3:",
      "mutated_line": "elif op == -3:",
      "code": "from bisect import insort, bisect_right, bisect_left\n\ndef process_multi_map_operations(operations):\n\n    class Multi_map:\n\n        def __init__(self):\n            self.mm = dict()\n            self.lr = []\n\n        def insert(self, key, value):\n            if key in self.mm:\n                self.mm[key].append(value)\n            else:\n                self.mm[key] = [value]\n                insort(self.lr, key)\n\n        def get(self, key):\n            if key in self.mm and self.mm[key] != []:\n                return self.mm[key]\n            return []\n\n        def delete(self, key):\n            if key in self.mm:\n                self.mm[key] = []\n\n        def dump(self, l, r):\n            lb = bisect_left(self.lr, l)\n            ub = bisect_right(self.lr, r)\n            result = []\n            for i in range(lb, ub):\n                k = self.lr[i]\n                for v in self.mm[k]:\n                    result.append((k, v))\n            return result\n    mm = Multi_map()\n    results = {}\n    for (idx, (op, *params)) in enumerate(operations):\n        if op == 0:\n            (key, value) = params\n            mm.insert(key, int(value))\n        elif op == 1:\n            key = params[0]\n            results[idx] = mm.get(key)\n        elif op == 2:\n            key = params[0]\n            mm.delete(key)\n        elif op == -3:\n            (l, r) = params\n            results[idx] = mm.dump(l, r)\n    return results"
    }
  ]
}