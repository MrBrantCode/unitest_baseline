{
  "task_id": "taco_4510",
  "entry_point": "count_transformable_pairs",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 1\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = -1\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 1\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[0]] -= 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] / (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] / (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] + (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] + (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] ** (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] ** (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] / (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] / (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] + (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] + (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] ** (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] ** (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 1\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "v = 0",
      "mutated_line": "v = -1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = -1\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 1\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 1",
      "mutated_line": "v = 2",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 2\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 1",
      "mutated_line": "v = 0",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 0\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 1",
      "mutated_line": "v = 0",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 0\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 1",
      "mutated_line": "v = -1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = -1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) * self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) * self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return self.h[r] - self.h[l] * self.pw[r - l] + self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return self.h[r] - self.h[l] * self.pw[r - l] + self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[0]] += 2",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[0]] += 0",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[0]] += 0",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[0]] += -1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) - 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) - 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) * 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) * 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l - 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l - 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l * 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l * 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = (v * base + ord(s[i])) * mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) * mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = v * base + ord(s[i]) + mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = v * base + ord(s[i]) + mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 1] = v = v * base * mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base * mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 1] = v = v * base + mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base + mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] + self.h[l] * self.pw[r - l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] + self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return self.h[r] * (self.h[l] * self.pw[r - l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return self.h[r] * (self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 38, 10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 38, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 36, 10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 36, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 0, 10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 0, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 1, 10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 1, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, -37, 10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, -37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 - 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 - 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 * 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 * 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [2] * (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [2] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [0] * (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [0] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [0] * (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [0] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [-1] * (len(s) + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [-1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) + 2)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 2)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) + 0)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 0)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) + 0)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 0)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.pw = pw = [1] * (len(s) + 1)",
      "mutated_line": "self.pw = pw = [1] * (len(s) + -1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + -1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [1] * (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [1] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [-1] * (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [-1] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [1] * (l + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [1] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l + 2)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 2)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l + 0)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 0)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l + 0)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 0)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.h = h = [0] * (l + 1)",
      "mutated_line": "self.h = h = [0] * (l + -1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + -1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i - 1] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i - 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i * 1] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i * 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = (v * base - ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base - ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = v * base * ord(s[i]) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = v * base * ord(s[i]) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i - 1] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i - 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i * 1] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i * 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 1] = v = v / base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v / base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 1] = v = (v + base) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = (v + base) % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 1] = v = v ** base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v ** base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - self.h[l] / self.pw[r - l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] / self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - (self.h[l] + self.pw[r - l])) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - (self.h[l] + self.pw[r - l])) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - self.h[l] ** self.pw[r - l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] ** self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 * 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 * 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 + 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 + 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 + 10)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 10)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 + 8)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 8)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 + 0)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 0)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 + 1)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 1)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 18 + -9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + -9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if X in alp:",
      "mutated_line": "if X not in alp:",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X not in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += alpdic[X]",
      "mutated_line": "ans -= alpdic[X]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans -= alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[1]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[1]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[-1]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[-1]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(1, l)][S[1]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[1]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 2] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 2] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 0] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 0] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 0] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 0] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + -1] = v = (v * base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + -1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = (v / base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v / base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = (v + base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v + base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "h[i + 1] = v = (v * base + ord(s[i])) % mod",
      "mutated_line": "h[i + 1] = v = (v ** base + ord(s[i])) % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v ** base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 2] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 2] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 0] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 0] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + 0] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 0] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pw[i + 1] = v = v * base % mod",
      "mutated_line": "pw[i + -1] = v = v * base % mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + -1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 11 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 11 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 9 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 9 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 0 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 0 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 1 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 1 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, -10 ** 18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, -10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 19 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 19 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 17 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 17 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 0 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 0 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** 1 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 1 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "RH = RollingHash(S, 37, 10 ** 18 + 9)",
      "mutated_line": "RH = RollingHash(S, 37, 10 ** -18 + 9)",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** -18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i - 1, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i - 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i * 1, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i * 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(2, l)][S[0]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(2, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(0, l)][S[0]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(0, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(0, l)][S[0]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(0, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dic[RH.get(1, l)][S[0]] += 1",
      "mutated_line": "dic[RH.get(-1, l)][S[0]] += 1",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(-1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - self.h[l] * self.pw[r + l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r + l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod",
      "mutated_line": "return (self.h[r] - self.h[l] * self.pw[r * l]) % self.mod",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r * l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i + 2, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 2, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i + 0, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 0, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i + 0, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + 0, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alpdic = dic[RH.get(i + 1, l)]",
      "mutated_line": "alpdic = dic[RH.get(i + -1, l)]",
      "code": "from collections import defaultdict\n\nclass RollingHash:\n\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1] * (len(s) + 1)\n        l = len(s)\n        self.h = h = [0] * (l + 1)\n        v = 0\n        for i in range(l):\n            h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i + 1] = v = v * base % mod\n\n    def get(self, l, r):\n        return (self.h[r] - self.h[l] * self.pw[r - l]) % self.mod\n\ndef count_transformable_pairs(N, Slist):\n    Slist.sort(key=len)\n    dic = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for S in Slist:\n        alp = set()\n        l = len(S)\n        RH = RollingHash(S, 37, 10 ** 18 + 9)\n        for i in range(len(S)):\n            alp.add(S[i])\n            alpdic = dic[RH.get(i + -1, l)]\n            for X in alpdic.keys():\n                if X in alp:\n                    ans += alpdic[X]\n        dic[RH.get(1, l)][S[0]] += 1\n    return ans"
    }
  ]
}