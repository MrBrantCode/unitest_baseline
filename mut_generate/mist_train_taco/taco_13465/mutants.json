{
  "task_id": "taco_13465",
  "entry_point": "sieve_of_eratosthenes",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] / (limit + 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] / (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] + (limit + 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] + (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] ** (limit + 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] ** (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[0] = sieve[1] = True",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = True\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 and n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 and n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 1\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = -1\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 1\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit - 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit - 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit * 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit * 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[1] = sieve[1] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[1] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[-1] = sieve[1] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[-1] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[1] = sieve[1] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[1] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[0] = sieve[2] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[2] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[0] = sieve[0] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[0] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[0] = sieve[0] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[0] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sieve[0] = sieve[1] = False",
      "mutated_line": "sieve[0] = sieve[-1] = False",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[-1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(3, int(limit ** 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(3, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(1, int(limit ** 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(1, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(0, int(limit ** 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(0, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(1, int(limit ** 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(1, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(-2, int(limit ** 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(-2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) - 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) - 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) * 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) * 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n <= 4 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n <= 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n >= 4 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n >= 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n != 4 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n != 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n >= 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n >= 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n <= 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n <= 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n != 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n != 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime >= n // 2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime >= n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime <= n // 2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime <= n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime != n // 2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime != n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (n - prime) in prime_set:",
      "mutated_line": "if n - prime not in prime_set:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime not in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count -= 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [False] * (limit + 1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [False] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit + 2)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 2)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit + 0)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 0)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit + 0)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 0)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sieve = [True] * (limit + 1)",
      "mutated_line": "sieve = [True] * (limit + -1)",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + -1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) + 2):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 2):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) + 0):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 0):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) + 0):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 0):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0.5) + -1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + -1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 5 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 5 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 3 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 3 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 0 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 0 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 1 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 1 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < -4 or n > 50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < -4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n > 50001:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50001:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n > 49999:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 49999:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n > 0:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 0:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n > 1:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 1:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n < 4 or n > 50000:",
      "mutated_line": "if n < 4 or n > -50000:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > -50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "raise ValueError(\"n must be between 4 and 50000 inclusive.\")",
      "mutated_line": "raise ValueError('')",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n / 2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n / 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n * 2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n * 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if (n - prime) in prime_set:",
      "mutated_line": "if n + prime in prime_set:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n + prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if (n - prime) in prime_set:",
      "mutated_line": "if n * prime in prime_set:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n * prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += -1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit * 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit * 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit + 0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit + 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start / start, limit + 1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start / start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start + start, limit + 1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start + start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start ** start, limit + 1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start ** start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit - 1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit - 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit * 1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit * 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sieve[multiple] = False",
      "mutated_line": "sieve[multiple] = True",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = True\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n // 3:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 3:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n // 1:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 1:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n // 0:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 0:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n // 1:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 1:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prime > n // 2:",
      "mutated_line": "if prime > n // -2:",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // -2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 1.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 1.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** -0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** -0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 0) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** 1) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 1) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for start in range(2, int(limit**0.5) + 1):",
      "mutated_line": "for start in range(2, int(limit ** -0.5) + 1):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** -0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit + 2, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 2, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit + 0, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 0, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit + 0, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + 0, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(start*start, limit + 1, start):",
      "mutated_line": "for multiple in range(start * start, limit + -1, start):",
      "code": "import bisect\nfrom itertools import compress\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to the given limit using the Sieve of Eratosthenes.\"\"\"\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for start in range(2, int(limit ** 0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start * start, limit + -1, start):\n                sieve[multiple] = False\n    return [num for (num, is_prime) in enumerate(sieve) if is_prime]\n\ndef count_goldbach_combinations(n):\n    \"\"\"\n    Count the number of combinations of two prime numbers that sum up to the given integer n.\n    \n    Parameters:\n    n (int): The integer for which to count the combinations.\n    \n    Returns:\n    int: The number of combinations of two prime numbers that sum up to n.\n    \"\"\"\n    if n < 4 or n > 50000:\n        raise ValueError('n must be between 4 and 50000 inclusive.')\n    primes = sieve_of_eratosthenes(n)\n    prime_set = set(primes)\n    count = 0\n    for prime in primes:\n        if prime > n // 2:\n            break\n        if n - prime in prime_set:\n            count += 1\n    return count"
    }
  ]
}