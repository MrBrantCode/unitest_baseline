{
  "task_id": "taco_2402",
  "entry_point": "count_coprime_integers",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] - [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] - [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] * [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] * [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pfs_ab = pfs_a | pfs_b",
      "mutated_line": "pfs_ab = pfs_a & pfs_b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a & pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pfs_ab = pfs_a | pfs_b",
      "mutated_line": "pfs_ab = pfs_a ^ pfs_b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a ^ pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "mutated_line": "return copr(L, R, pfs_a) + copr(L, R, pfs_b) + copr(L, R, pfs_ab)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) + copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "mutated_line": "return (copr(L, R, pfs_a) + copr(L, R, pfs_b)) * copr(L, R, pfs_ab)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return (copr(L, R, pfs_a) + copr(L, R, pfs_b)) * copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - 1) / b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) / b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - 1) * b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) * b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n >= 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n <= 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n != 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "mutated_line": "return copr(L, R, pfs_a) - copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) - copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "mutated_line": "return copr(L, R, pfs_a) * copr(L, R, pfs_b) - copr(L, R, pfs_ab)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) * copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [3, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [3, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [1, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [1, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [0, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [0, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [1, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [1, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [-2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [-2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 4] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 4] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 2] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 2] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 0] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 0] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 1] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 1] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, -3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, -3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x - d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x - d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x * d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x * d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b + 1) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b + 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b) * 1 // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b) * 1 // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p != 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p != 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p >= n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p >= n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p <= n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p <= n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p != n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p != n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 2:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 0:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 0:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > -1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return copr(l, r, y) - copr(ceilq(l, p), r // p, y)",
      "mutated_line": "return copr(l, r, y) + copr(ceilq(l, p), r // p, y)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) + copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return copr(l, r, y) - copr(ceilq(l, p), r // p, y)",
      "mutated_line": "return copr(l, r, y) * copr(ceilq(l, p), r // p, y)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) * copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r - l - 1",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l - 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return (r - l) * 1",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return (r - l) * 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 / x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 / x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 + x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 + x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 ** x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 ** x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a - b - 1) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a - b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a * b - 1) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a * b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - 2) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 2) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - 0) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 0) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - 0) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 0) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (a + b - 1) // b",
      "mutated_line": "return (a + b - -1) // b",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - -1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n * p == 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n * p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n + p == 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n + p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 1:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == -1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == -1:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % p == 0:",
      "mutated_line": "if n % p == 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 1:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p != 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p != 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p / p > n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p / p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p + p > n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p + p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > n:",
      "mutated_line": "if p ** p > n:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p ** p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r + l + 1",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r + l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r * l + 1",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r * l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r - l + 2",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 2\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r - l + 0",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 0\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r - l + 0",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 0\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return r - l + 1",
      "mutated_line": "return r - l + -1",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + -1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [7 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [7 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [5 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [5 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [0 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [0 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [1 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [1 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [-6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [-6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(2, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(2, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(0, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(0, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(0, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(0, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(-1, 5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(-1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5272) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5272) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5270) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5270) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 0) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 0) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 1) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 1) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, -5271) for d in [-1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, -5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [+1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [+1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 2]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 2]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 0]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 0]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 0]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 0]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, -1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, -1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n * p == 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n * p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n + p == 0:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n + p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 1:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == -1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == -1:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 1:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return copr(l, r, y) - copr(ceilq(l, p), r // p, y)",
      "mutated_line": "return copr(l, r, y) - copr(ceilq(l, p), r / p, y)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r / p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return copr(l, r, y) - copr(ceilq(l, p), r // p, y)",
      "mutated_line": "return copr(l, r, y) - copr(ceilq(l, p), r * p, y)",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r * p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-2, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-2, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-0, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-0, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-0, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-0, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]",
      "mutated_line": "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [--1, 1]]",
      "code": "def count_coprime_integers(A, B, L, R):\n    possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [--1, 1]]\n\n    def ceilq(a, b):\n        return (a + b - 1) // b\n\n    def prime_factors(n):\n        pfs = set({})\n        for p in possible_pfs:\n            if n % p == 0:\n                pfs.add(p)\n                while n % p == 0:\n                    n //= p\n            if p * p > n:\n                break\n        if n > 1:\n            pfs.add(n)\n        return pfs\n\n    def copr(l, r, x):\n        if x:\n            y = x.copy()\n            p = y.pop()\n            return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n        else:\n            return r - l + 1\n    pfs_a = prime_factors(A)\n    pfs_b = prime_factors(B)\n    pfs_ab = pfs_a | pfs_b\n    return copr(L, R, pfs_a) + copr(L, R, pfs_b) - copr(L, R, pfs_ab)"
    }
  ]
}