{
  "task_id": "taco_20",
  "entry_point": "maximize_total_coins",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = X + Y + Z",
      "mutated_line": "N = X + Y - Z",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y - Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = X + Y + Z",
      "mutated_line": "N = (X + Y) * Z",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = (X + Y) * Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "GB = [None] * N",
      "mutated_line": "GB = [None] / N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] / N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "GB = [None] * N",
      "mutated_line": "GB = [None] + N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] + N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "GB = [None] * N",
      "mutated_line": "GB = [None] ** N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] ** N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs -= -heappushpop(Q, a - c) + a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs -= -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "SB = [None] * N",
      "mutated_line": "SB = [None] / N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] / N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "SB = [None] * N",
      "mutated_line": "SB = [None] + N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] + N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "SB = [None] * N",
      "mutated_line": "SB = [None] ** N",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] ** N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss -= -heappushpop(Q, b - c) + b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss -= -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = X + Y + Z",
      "mutated_line": "N = X - Y + Z",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X - Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = X + Y + Z",
      "mutated_line": "N = X * Y + Z",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X * Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Q = [a - c for (a, _, c) in ABC[:X]]",
      "mutated_line": "Q = [a + c for (a, _, c) in ABC[:X]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a + c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Q = [a - c for (a, _, c) in ABC[:X]]",
      "mutated_line": "Q = [a * c for (a, _, c) in ABC[:X]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a * c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X + 1] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X + 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X * 1] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X * 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs += -heappushpop(Q, a - c) - a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) - a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs += -heappushpop(Q, a - c) * a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) * a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Q = [b - c for (_, b, c) in ABC[X + Z:]]",
      "mutated_line": "Q = [b + c for (_, b, c) in ABC[X + Z:]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b + c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Q = [b - c for (_, b, c) in ABC[X + Z:]]",
      "mutated_line": "Q = [b * c for (_, b, c) in ABC[X + Z:]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b * c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y + 1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y + 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y * 1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y * 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 2):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 2):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 0):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 0):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 0):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 0):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], -1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], -1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i = -Y - i",
      "mutated_line": "i = -Y + i",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y + i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i = -Y - i",
      "mutated_line": "i = -Y * i",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y * i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss += -heappushpop(Q, b - c) - b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) - b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss += -heappushpop(Q, b - c) * b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) * b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=False)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=False)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X - 2] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 2] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X - 0] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 0] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X - 0] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 0] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "GB[X - 1] = gs",
      "mutated_line": "GB[X - -1] = gs",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - -1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs += +heappushpop(Q, a - c) + a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += +heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[+Y - 1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[+Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y - 2] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 2] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y - 0] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 0] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y - 0] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 0] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "SB[-Y - 1] = ss",
      "mutated_line": "SB[-Y - -1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - -1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "i = -Y - i",
      "mutated_line": "i = +Y - i",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = +Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss += +heappushpop(Q, b - c) + b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += +heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i + 1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i + 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i * 1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i * 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i - j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i - j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i * j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i * j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] + x[1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] + x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] * x[1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] * x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X:X - Z], X):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X - Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X:X * Z], X):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X * Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z + 1:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z + 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[(X + Z) * 1:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[(X + Z) * 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X + 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X + 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X * 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X * 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:+1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:+1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i - 2] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 2] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i - 0] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 0] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i - 0] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 0] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SB[i - 1] = ss",
      "mutated_line": "SB[i - -1] = ss",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - -1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs += -heappushpop(Q, a + c) + a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a + c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "gs += -heappushpop(Q, a - c) + a",
      "mutated_line": "gs += -heappushpop(Q, a * c) + a",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a * c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Q = [b - c for (_, b, c) in ABC[X + Z:]]",
      "mutated_line": "Q = [b - c for (_, b, c) in ABC[X - Z:]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X - Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Q = [b - c for (_, b, c) in ABC[X + Z:]]",
      "mutated_line": "Q = [b - c for (_, b, c) in ABC[X * Z:]]",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X * Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X - Z - 1:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X - Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X * Z - 1:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X * Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 2:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 2:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 0:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 0:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 0:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 0:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - -1:X - 1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - -1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 2:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 2:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 0:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 0:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 0:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 0:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - -1:-1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - -1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-2], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-2], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-0], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-0], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-0], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-0], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):",
      "mutated_line": "for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:--1], 1):",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:--1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss += -heappushpop(Q, b + c) + b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b + c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ss += -heappushpop(Q, b - c) + b",
      "mutated_line": "ss += -heappushpop(Q, b * c) + b",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b * c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[1] - x[1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[1] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[-1] - x[1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[-1] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[1] - x[1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[1] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] - x[2], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[2], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] - x[0], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[0], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] - x[0], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[0], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ABC.sort(key=lambda x: x[0] - x[1], reverse=True)",
      "mutated_line": "ABC.sort(key=lambda x: x[0] - x[-1], reverse=True)",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[-1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ss = sum((b for (_, b, _) in ABC[X + Z:]))",
      "mutated_line": "ss = sum((b for (_, b, _) in ABC[X - Z:]))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X - Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ss = sum((b for (_, b, _) in ABC[X + Z:]))",
      "mutated_line": "ss = sum((b for (_, b, _) in ABC[X * Z:]))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X * Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X + 1:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X + 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X * 1:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X * 1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X - Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X - Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X * Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X * Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X + 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X + 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X * 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X * 1:X + Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X - Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X - Z])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X * Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X * Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 2:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 2:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 0:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 0:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 0:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 0:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - -1:X + Z], SB[X - 1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - -1:X + Z], SB[X - 1:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 2:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 2:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 0:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 0:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 0:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 0:X + Z])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - 1:X + Z])))",
      "mutated_line": "return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - -1:X + Z])))",
      "code": "from heapq import heappushpop\n\ndef maximize_total_coins(X, Y, Z, ABC):\n    N = X + Y + Z\n    ABC.sort(key=lambda x: x[0] - x[1], reverse=True)\n    GB = [None] * N\n    Q = [a - c for (a, _, c) in ABC[:X]]\n    Q.sort()\n    gs = sum((a for (a, _, _) in ABC[:X]))\n    GB[X - 1] = gs\n    for (i, (a, b, c)) in enumerate(ABC[X:X + Z], X):\n        gs += -heappushpop(Q, a - c) + a\n        GB[i] = gs\n    SB = [None] * N\n    Q = [b - c for (_, b, c) in ABC[X + Z:]]\n    Q.sort()\n    ss = sum((b for (_, b, _) in ABC[X + Z:]))\n    SB[-Y - 1] = ss\n    for (i, (a, b, c)) in enumerate(ABC[X + Z - 1:X - 1:-1], 1):\n        i = -Y - i\n        ss += -heappushpop(Q, b - c) + b\n        SB[i - 1] = ss\n    return max((i + j for (i, j) in zip(GB[X - 1:X + Z], SB[X - -1:X + Z])))"
    }
  ]
}