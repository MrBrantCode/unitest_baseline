{
  "task_id": "taco_15829",
  "entry_point": "calculate_expected_inversions",
  "mutant_count": 212,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thirdSum = 0",
      "mutated_line": "thirdSum = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 1\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thirdSum = 0",
      "mutated_line": "thirdSum = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = -1\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thirdSum = 0",
      "mutated_line": "thirdSum = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 1\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum -= i * (i - 1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum -= i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 - thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 - thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = (InvCount - InvCountAdv / (n * (n + 1)) * 2) * (thirdSum / (n * (n + 1)))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = (InvCount - InvCountAdv / (n * (n + 1)) * 2) * (thirdSum / (n * (n + 1)))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sum = 0",
      "mutated_line": "sum = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 1\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sum = 0",
      "mutated_line": "sum = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = -1\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sum = 0",
      "mutated_line": "sum = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 1\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index >= 0:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index >= 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index <= 0:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index <= 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index != 0:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index != 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "sum += BITree[index]",
      "mutated_line": "sum -= BITree[index]",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum -= BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "index -= index & -index",
      "mutated_line": "index += index & -index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index += index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index <= n:",
      "mutated_line": "while index < n:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index < n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index <= n:",
      "mutated_line": "while index > n:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index > n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index <= n:",
      "mutated_line": "while index == n:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index == n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "BITree[index] += val",
      "mutated_line": "BITree[index] -= val",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] -= val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "index += index & -index",
      "mutated_line": "index -= index & -index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index -= index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = -1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] / (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] / (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] + (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] + (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] ** (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] ** (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount -= getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount -= getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = -1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "invcount = 0",
      "mutated_line": "invcount = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 1\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] / (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] / (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] + (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] + (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] ** (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] ** (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount -= (i + 1) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount -= (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(2, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(0, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(0, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(-1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n - 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n * 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) * 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) * 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) // 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) // 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount + InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount + InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount * (InvCountAdv / (n * (n + 1)) * 2) + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount * (InvCountAdv / (n * (n + 1)) * 2) + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum * (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum * (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum // (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum // (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index > 1:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 1:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index > -1:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > -1:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while index > 0:",
      "mutated_line": "while index > 1:",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 1:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "index -= index & -index",
      "mutated_line": "index -= index | -index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index | -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index += index & -index",
      "mutated_line": "index += index | -index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index | -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement - 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement * 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement * 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(2, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(2, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(0, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(0, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(0, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(0, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(-1, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(-1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement - 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement - 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement * 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement * 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 1\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = -1\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 1\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n + 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n * 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, +1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, +1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement - 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement * 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement * 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(2, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(2, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(0, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(0, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(0, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(0, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(-1, maxElement + 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(-1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement - 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement - 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement * 1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement * 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 1\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = -1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = -1\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "BIT[i] = 0",
      "mutated_line": "BIT[i] = 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 1\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n + 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n * 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, +1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, +1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) / getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) / getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += i + 1 + getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += i + 1 + getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) ** getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) ** getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 2):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 0):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 0):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + -1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) / (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) / (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += (i * (i - 1) + (n - i + 1)) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += (i * (i - 1) + (n - i + 1)) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += (i * (i - 1)) ** (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += (i * (i - 1)) ** (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) / 3",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 3\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) / 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 1\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) / 0",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 0\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) / 1",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 1\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 1) / -2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / -2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) / 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) / 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - (InvCountAdv / (n * (n + 1)) + 2) + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - (InvCountAdv / (n * (n + 1)) + 2) + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - (InvCountAdv / (n * (n + 1))) ** 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - (InvCountAdv / (n * (n + 1))) ** 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n / (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n / (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n + (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n + (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / n ** (n + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / n ** (n + 1)\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "index -= index & -index",
      "mutated_line": "index -= index & +index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & +index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "index += index & -index",
      "mutated_line": "index += index & +index",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & +index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [-1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [-1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 2)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 2)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 0)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 0)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + -1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + -1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 2):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 2):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 0):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 0):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + -1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 2, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 0, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 0, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - -1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -2, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -0, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -0, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, --1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -2):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -0):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -0):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, --1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] + 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] * 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] * 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "updateBIT(BIT, maxElement, arr[i], 1)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], 2)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 2)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "updateBIT(BIT, maxElement, arr[i], 1)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 0)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "updateBIT(BIT, maxElement, arr[i], 1)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 0)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "updateBIT(BIT, maxElement, arr[i], 1)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], -1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], -1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [-1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [-1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [1] * (maxElement + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [1] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 2)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 2)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 0)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 0)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "BIT = [0] * (maxElement + 1)",
      "mutated_line": "BIT = [0] * (maxElement + -1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + -1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 2):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 2):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 0):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + 0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 0):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, maxElement + 1):",
      "mutated_line": "for i in range(1, maxElement + -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + -1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 2, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 0, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 0, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - -1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -2, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -0, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -0, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, --1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -2):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -0):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -0):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, --1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i - 1) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i - 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += i * 1 * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += i * 1 * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "updateBIT(BIT, maxElement, arr[i], n - i)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], n + i)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n + i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "updateBIT(BIT, maxElement, arr[i], n - i)",
      "mutated_line": "updateBIT(BIT, maxElement, arr[i], n * i)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n * i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i / (i - 1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i / (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += (i + (i - 1)) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += (i + (i - 1)) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i ** (i - 1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i ** (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i - 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i - 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * ((n - i) * 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * ((n - i) * 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv * (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv * (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv // (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv // (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 3 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 3 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 1 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 1 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 0 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 0 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 1 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 1 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * -2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * -2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n - 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n - 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n * 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n * 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] - 2)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 2)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] - 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 0)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] - 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 0)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "invcount += getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += getSum(BIT, arr[i] - -1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - -1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 2) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 2) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 0) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 0) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 0) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 0) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + -1) * getSum(BIT, arr[i] - 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + -1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] + 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] + 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] * 1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] * 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i + 1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i + 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i * 1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i * 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n + i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n + i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n * i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n * i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 2) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 2) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 0) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 0) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + 0) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 0) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 1) * (n - i + -1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + -1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n / (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n / (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n + (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n + (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / n ** (n + 1) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / n ** (n + 1) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 2))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 2))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 0))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 0))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 0))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 0))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + -1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + -1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 2)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 2)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 0)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 0)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 0)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "invcount += (i + 1) * getSum(BIT, arr[i] - 1)",
      "mutated_line": "invcount += (i + 1) * getSum(BIT, arr[i] - -1)",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - -1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 2) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 2) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 0) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 0) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - 0) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 0) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "thirdSum += i * (i - 1) * (n - i + 1) / 2",
      "mutated_line": "thirdSum += i * (i - -1) * (n - i + 1) / 2",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - -1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n - 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n - 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n * 1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n * 1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 2)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 2)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 0)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 0)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 0)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + 0)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1))",
      "mutated_line": "expected_inversions = InvCount - InvCountAdv / (n * (n + -1)) * 2 + thirdSum / (n * (n + 1))",
      "code": "def calculate_expected_inversions(n, permutation):\n\n    def getSum(BITree, index):\n        sum = 0\n        while index > 0:\n            sum += BITree[index]\n            index -= index & -index\n        return sum\n\n    def updateBIT(BITree, n, index, val):\n        while index <= n:\n            BITree[index] += val\n            index += index & -index\n\n    def getInvCount(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], 1)\n        return invcount\n\n    def getInvCountAdv(arr, n):\n        invcount = 0\n        maxElement = max(arr)\n        BIT = [0] * (maxElement + 1)\n        for i in range(1, maxElement + 1):\n            BIT[i] = 0\n        for i in range(n - 1, -1, -1):\n            invcount += (i + 1) * getSum(BIT, arr[i] - 1)\n            updateBIT(BIT, maxElement, arr[i], n - i)\n        return invcount\n    InvCount = getInvCount(permutation, n)\n    InvCountAdv = getInvCountAdv(permutation, n)\n    thirdSum = 0\n    for i in range(1, n + 1):\n        thirdSum += i * (i - 1) * (n - i + 1) / 2\n    expected_inversions = InvCount - InvCountAdv / (n * (n + -1)) * 2 + thirdSum / (n * (n + 1))\n    return expected_inversions"
    }
  ]
}