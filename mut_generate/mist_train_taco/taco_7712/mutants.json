{
  "task_id": "taco_7712",
  "entry_point": "longest_almost_increasing_subsequence",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n < 2:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n < 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n > 2:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n > 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n == 2:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n == 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 3:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 3:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 1:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 0:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 0:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 1:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= -2:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= -2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if k == len(m):",
      "mutated_line": "if k != len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k != len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] < v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] > v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] == v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 1 <= len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 <= len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 1 >= len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 >= len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 1 != len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 != len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "stack = [a[0]]",
      "mutated_line": "stack = [a[1]]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[1]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "stack = [a[0]]",
      "mutated_line": "stack = [a[-1]]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[-1]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "stack = [a[0]]",
      "mutated_line": "stack = [a[1]]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[1]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(1000001, 0)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000001, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(999999, 0)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(999999, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(0, 0)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(0, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(1, 0)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(-1000000, 0)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(-1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(1000000, 1)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 1)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(1000000, -1)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, -1)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = [(1000000, 0)]",
      "mutated_line": "p = [(1000000, 1)]",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 1)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for v in a[1:]:",
      "mutated_line": "for v in a[2:]:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[2:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for v in a[1:]:",
      "mutated_line": "for v in a[0:]:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[0:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for v in a[1:]:",
      "mutated_line": "for v in a[0:]:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[0:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for v in a[1:]:",
      "mutated_line": "for v in a[-1:]:",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[-1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k - 1 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k - 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k * 1 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k * 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k - 1] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k - 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k * 1] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k * 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][1] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][-1] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][1] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk - 1] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk - 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk * 1] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk * 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 2 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 2 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 0 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 0 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + 0 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 0 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 < len(m):",
      "mutated_line": "if k + -1 < len(m):",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + -1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k + 2] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 2] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k + 0] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 0] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k + 0] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 0] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack[k + 1] = m[k] = v",
      "mutated_line": "stack[k + -1] = m[k] = v",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + -1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[+1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 2] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 2] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 0] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 0] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 0] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 0] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + -1] = min(stack[kk + 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + -1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk - 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk - 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk * 1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk * 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k - 1))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k - 1))\n    return len(stack)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k * 1))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k * 1))\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[+1], stack[-2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[+1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[+2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[+2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-2][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-0][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-0][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while p[-1][0] <= v:",
      "mutated_line": "(vv, kk) = p.pop()",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[--1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk + 2], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 2], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk + 0], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 0], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk + 0], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 0], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack[kk + 1] = min(stack[kk + 1], v)",
      "mutated_line": "stack[kk + 1] = min(stack[kk + -1], v)",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + -1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k + 2))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 2))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k + 0))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 0))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k + 0))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 0))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p.append((v, k + 1))",
      "mutated_line": "p.append((v, k + -1))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + -1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-2], stack[-2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-2], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-0], stack[-2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-0], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-0], stack[-2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-0], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[--1], stack[-2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[--1], stack[-2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[-3]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-3]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[-1]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-1]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[-0]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-0]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[-1]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[-1]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m.append(min(stack[-1], stack[-2]))",
      "mutated_line": "m.append(min(stack[-1], stack[--2]))",
      "code": "import bisect as bs\n\ndef longest_almost_increasing_subsequence(a):\n    n = len(a)\n    if n <= 2:\n        return n\n    stack = [a[0]]\n    m = []\n    p = [(1000000, 0)]\n    for v in a[1:]:\n        k = bs.bisect_right(m, v)\n        if k == len(m):\n            stack.append(v)\n            m.append(min(stack[-1], stack[--2]))\n        else:\n            stack[k + 1] = m[k] = v\n        while p[-1][0] <= v:\n            (vv, kk) = p.pop()\n            m[kk] = min(m[kk], vv)\n            stack[kk + 1] = min(stack[kk + 1], v)\n        if k + 1 < len(m):\n            p.append((v, k + 1))\n    return len(stack)"
    }
  ]
}