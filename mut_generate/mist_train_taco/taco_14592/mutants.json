{
  "task_id": "taco_14592",
  "entry_point": "minimum_cost_path",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[x][y] > dist[i][j] + e:",
      "mutated_line": "if dist[x][y] >= dist[i][j] + e:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] >= dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[x][y] > dist[i][j] + e:",
      "mutated_line": "if dist[x][y] <= dist[i][j] + e:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] <= dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[x][y] > dist[i][j] + e:",
      "mutated_line": "if dist[x][y] != dist[i][j] + e:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] != dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][1] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][1] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][-1] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][-1] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][1] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][1] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[0][1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][1]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[0][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][-1]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[0][1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][1]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i >= 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i >= 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i <= 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i <= 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i != 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i != 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i <= m - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i <= m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i >= m - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i >= m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i != m - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i != m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j >= 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j <= 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j != 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j <= n - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j <= n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j >= n - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j >= n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j != n - 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j != n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-1][+1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][+1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if dist[x][y] > dist[i][j] + e:",
      "mutated_line": "if dist[x][y] > dist[i][j] - e:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] - e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if dist[x][y] > dist[i][j] + e:",
      "mutated_line": "if dist[x][y] > dist[i][j] * e:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] * e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[x][y] = dist[i][j] + e",
      "mutated_line": "dist[x][y] = dist[i][j] - e",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] - e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[x][y] = dist[i][j] + e",
      "mutated_line": "dist[x][y] = dist[i][j] * e",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] * e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[1])",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[1])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[-1])",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[-1])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[1])",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[1])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[1][0] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[1][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[-1][0] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[-1][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[1][0] = grid[0][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[1][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[1][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[1][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[-1][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[-1][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[0][0] = grid[0][0]",
      "mutated_line": "dist[0][0] = grid[1][0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[1][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 1:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i > -1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > -1:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 1:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m + 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m + 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m * 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m * 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 1:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > -1:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 1:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n + 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n + 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n * 1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n * 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[+1][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[+1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-1][-2]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-2]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-1][-0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-0]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-1][-0]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-0]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-1][--1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][--1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][1], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][1], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][-1], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][-1], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][1], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][1], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (1, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (1, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (-1, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (-1, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (1, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (1, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (0, 1)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 1)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (0, -1)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, -1)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[0][0], (0, 1)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 1)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = [[float('inf') for j in range(n)] for i in range(m)]",
      "mutated_line": "dist = [[float('') for j in range(n)] for i in range(m)]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m - 2:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 2:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m - 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 0:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m - 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 0:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i < m - 1:",
      "mutated_line": "if i < m - -1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - -1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n - 2:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 2:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n - 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 0:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n - 0:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 0:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j < n - 1:",
      "mutated_line": "if j < n - -1:",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - -1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-2][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-2][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-0][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-0][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[-0][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-0][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dist[-1][-1]",
      "mutated_line": "return dist[--1][-1]",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[--1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[1][0], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[1][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[-1][0], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[-1][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "heappush(min_heap, (grid[0][0], (0, 0)))",
      "mutated_line": "heappush(min_heap, (grid[1][0], (0, 0)))",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[1][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i + 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i * 1, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i * 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i - 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i * 1, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i * 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j + 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j * 1), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j * 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j + 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j * 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j * 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j - 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j * 1), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j * 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j - 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j * 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j * 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 2, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 2, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 0, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 0, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 0, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 0, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - -1, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - -1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i + 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i * 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i * 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 2, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 2, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 0, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 0, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 0, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 0, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + -1, j), grid[i + 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + -1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i - 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i - 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i * 1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i * 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 2), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 2), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 0), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 0), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 0), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 0), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - -1), grid[i][j - 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - -1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j - 2], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 2], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j - 0], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 0], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j - 0], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 0], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j - 1), grid[i][j - -1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - -1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 2), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 2), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 0), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 0), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 0), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 0), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + -1), grid[i][j + 1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + -1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j + 2], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 2], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j + 0], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 0], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j + 0], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 0], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)",
      "mutated_line": "relax((i, j), (i, j + 1), grid[i][j + -1], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + -1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i - 2][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 2][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i - 0][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 0][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i - 0][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 0][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i - 1, j), grid[i - -1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - -1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i + 2][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 2][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i + 0][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 0][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i + 0][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + 0][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "relax((i, j), (i + 1, j), grid[i + 1][j], dist, min_heap)",
      "mutated_line": "relax((i, j), (i + 1, j), grid[i + -1][j], dist, min_heap)",
      "code": "from heapq import heappush, heappop\n\ndef minimum_cost_path(grid):\n    m = len(grid)\n    n = len(grid[0])\n    min_heap = []\n    heappush(min_heap, (grid[0][0], (0, 0)))\n    dist = [[float('inf') for j in range(n)] for i in range(m)]\n    dist[0][0] = grid[0][0]\n    while min_heap:\n        (d, (i, j)) = heappop(min_heap)\n        if i > 0:\n            relax((i, j), (i - 1, j), grid[i - 1][j], dist, min_heap)\n        if i < m - 1:\n            relax((i, j), (i + 1, j), grid[i + -1][j], dist, min_heap)\n        if j > 0:\n            relax((i, j), (i, j - 1), grid[i][j - 1], dist, min_heap)\n        if j < n - 1:\n            relax((i, j), (i, j + 1), grid[i][j + 1], dist, min_heap)\n    return dist[-1][-1]\n\ndef relax(u, v, e, dist, min_heap):\n    (i, j) = u\n    (x, y) = v\n    if dist[x][y] > dist[i][j] + e:\n        dist[x][y] = dist[i][j] + e\n        heappush(min_heap, (dist[x][y], v))"
    }
  ]
}