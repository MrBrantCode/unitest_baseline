{
  "task_id": "taco_17211",
  "entry_point": "maximum_match",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[s] = True",
      "mutated_line": "visited[s] = False",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = False\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return True\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while parent[vertex] is not None:",
      "mutated_line": "while parent[vertex] is None:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while parent[vertex] is not None:",
      "mutated_line": "while parent[vertex] is None:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "G[parent[vertex]][vertex] -= bottle_neck",
      "mutated_line": "G[parent[vertex]][vertex] += bottle_neck",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] += bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "G[vertex][parent[vertex]] += bottle_neck",
      "mutated_line": "G[vertex][parent[vertex]] -= bottle_neck",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] -= bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 1\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = -1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = -1\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 1\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "max_flow += bottle_neck",
      "mutated_line": "max_flow -= bottle_neck",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow -= bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m - 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m - 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = (n + m) * 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = (n + m) * 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "visited = [False for _ in range(n)]",
      "mutated_line": "visited = [True for _ in range(n)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [True for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "bottle_neck = float('inf')",
      "mutated_line": "bottle_neck = float('')",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n - m + 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n - m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n * m + 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n * m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m + 3",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 3\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m + 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 1\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m + 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 0\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m + 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 1\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size = n + m + 2",
      "mutated_line": "size = n + m + -2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + -2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 2][guy] = 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 2\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 2][guy] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 0\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 2][guy] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 0\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 2][guy] = -1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = -1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 1] = 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 2\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 1] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 0\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 1] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 0\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 1] = -1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = -1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size + 2, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size + 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size * 2, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size * 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size + 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size + 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size * 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size * 1)\n    return create_vertices(G)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] or G[vertex][neighbour] > 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] or G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "n = len(Graph[0])",
      "mutated_line": "n = len(Graph[1])",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[1])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "n = len(Graph[0])",
      "mutated_line": "n = len(Graph[-1])",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[-1])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "n = len(Graph[0])",
      "mutated_line": "n = len(Graph[1])",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[1])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[-1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[-1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[1 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if Graph[guy][machine] == 1:",
      "mutated_line": "if Graph[guy][machine] != 1:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] != 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size + 1] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size + 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size * 1] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size * 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 3, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 3, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 1, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 1, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 0, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 0, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 1, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 1, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - -2, size - 1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - -2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size - 2)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 2)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size - 0)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 0)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size - 0)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 0)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return ford_fulkerson(G, size - 2, size - 1)",
      "mutated_line": "return ford_fulkerson(G, size - 2, size - -1)",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - -1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] >= 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] >= 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] <= 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] <= 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] != 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] != 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited[neighbour] = True",
      "mutated_line": "visited[neighbour] = False",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = False\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if neighbour == t:",
      "mutated_line": "if neighbour != t:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour != t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m - 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m - 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range((n + m) * 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range((n + m) * 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size + 2][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size + 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size * 2][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size * 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if Graph[guy][machine] == 1:",
      "mutated_line": "if Graph[guy][machine] == 2:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 2:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if Graph[guy][machine] == 1:",
      "mutated_line": "if Graph[guy][machine] == 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 0:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if Graph[guy][machine] == 1:",
      "mutated_line": "if Graph[guy][machine] == 0:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 0:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if Graph[guy][machine] == 1:",
      "mutated_line": "if Graph[guy][machine] == -1:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == -1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m + machine] = 2",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 2\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m + machine] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 0\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m + machine] = 0",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 0\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m + machine] = -1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = -1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m - machine][size - 1] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m - machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m * machine][size - 1] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m * machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 2] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 2] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 0] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 0] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - 0] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 0] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "G[m + machine][size - 1] = 1",
      "mutated_line": "G[m + machine][size - -1] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - -1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] > 1:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 1:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] > -1:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > -1:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not visited[neighbour] and G[vertex][neighbour] > 0:",
      "mutated_line": "if not visited[neighbour] and G[vertex][neighbour] > 1:",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 1:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return False\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m - 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m - 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range((n + m) * 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range((n + m) * 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n - m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n - m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n * m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n * m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 3)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 3)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 1)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 1)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 0)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 0)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 1)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 1)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + -2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + -2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 3][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 3][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 1][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 1][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 0][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 0][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - 1][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 1][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "G[size - 2][guy] = 1",
      "mutated_line": "G[size - -2][guy] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - -2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m - machine] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m - machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "G[guy][m + machine] = 1",
      "mutated_line": "G[guy][m * machine] = 1",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m * machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n - m + 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n - m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n * m + 2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n * m + 2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 3)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 3)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 1)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 1)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 0)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 0)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + 1)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + 1)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "G = [[0 for _ in range(n + m + 2)] for _ in range(n + m + 2)]",
      "mutated_line": "G = [[0 for _ in range(n + m + -2)] for _ in range(n + m + 2)]",
      "code": "def maximum_match(G):\n\n    def BFS(G, parent, s, t):\n        n = len(G)\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in range(n):\n                if not visited[neighbour] and G[vertex][neighbour] > 0:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n                    parent[neighbour] = vertex\n                    if neighbour == t:\n                        return True\n        return False\n\n    def augment_the_path(G, parent, vertex):\n        bottle_neck = float('inf')\n        help_variable = vertex\n        while parent[vertex] is not None:\n            bottle_neck = min(bottle_neck, G[parent[vertex]][vertex])\n            vertex = parent[vertex]\n        vertex = help_variable\n        while parent[vertex] is not None:\n            G[parent[vertex]][vertex] -= bottle_neck\n            G[vertex][parent[vertex]] += bottle_neck\n            vertex = parent[vertex]\n        return bottle_neck\n\n    def ford_fulkerson(M, s, t):\n        n = len(M)\n        max_flow = 0\n        parent = [None for _ in range(n)]\n        while BFS(M, parent, s, t):\n            bottle_neck = augment_the_path(M, parent, t)\n            max_flow += bottle_neck\n        return max_flow\n\n    def create_vertices(Graph):\n        n = len(Graph[0])\n        m = len(Graph)\n        size = n + m + 2\n        G = [[0 for _ in range(n + m + -2)] for _ in range(n + m + 2)]\n        for guy in range(m):\n            G[size - 2][guy] = 1\n            for machine in range(n):\n                if Graph[guy][machine] == 1:\n                    G[guy][m + machine] = 1\n        for machine in range(n):\n            G[m + machine][size - 1] = 1\n        return ford_fulkerson(G, size - 2, size - 1)\n    return create_vertices(G)"
    }
  ]
}