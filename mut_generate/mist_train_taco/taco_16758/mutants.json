{
  "task_id": "taco_16758",
  "entry_point": "count_fox_sequences",
  "mutant_count": 233,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 - 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 - 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 * 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 * 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 * 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 * 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 + 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 + 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 + 8",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 8\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 + 6",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 6\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 + 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 0\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 + 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 1\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 9 + -7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + -7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [2]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [2]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [0]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [0]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [-1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [-1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(2, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(2, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(0, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(0, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(0, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(0, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(-1, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(-1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(1, 200002):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200002):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(1, 200000):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200000):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 0):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 1):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, 200001):",
      "mutated_line": "for i in range(1, -200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, -200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [1, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [-1, 1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [-1, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [1, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 2]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 2]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 0]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 0]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, -1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, -1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(3, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(3, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(1, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(1, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(0, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(0, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(1, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(1, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(-2, 200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(-2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(2, 200002):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200002):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(2, 200000):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200000):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(2, 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 0):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(2, 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 1):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, 200001):",
      "mutated_line": "for i in range(2, -200001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, -200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [2]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [2]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [0]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [0]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [0]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [-1]",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [-1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(2, 100001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(2, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(0, 100001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(0, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(0, 100001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(0, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(-1, 100001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(-1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 100002):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100002):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 100000):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100000):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 0):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 1):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, -100001):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, -100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -(-a // b)",
      "mutated_line": "return +(-a // b)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return +(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k != 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 1\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = -1\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 1\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret -= sign * part(sum - i * b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret -= sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 1\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = -1\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 1\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret -= g(n - max, k - 1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret -= g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return ret * k % P",
      "mutated_line": "return ret * k * P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k * P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return ret * k % P",
      "mutated_line": "return ret * k + P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k + P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi - lo - 1)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, (hi - lo) * 1)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, (hi - lo) * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 11 ** 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 11 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 9 ** 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 9 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 0 ** 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 0 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 1 ** 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 1 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = -10 ** 9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = -10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 10 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 10 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 8 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 8 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 0 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 0 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** 1 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 1 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "P = 10 ** 9 + 7",
      "mutated_line": "P = 10 ** -9 + 7",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** -9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-1] * i * P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i * P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-1] * i + P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i + P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P + P // i * inv[P % i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P + P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P * (P // i * inv[P % i] % P))",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P * (P // i * inv[P % i] % P))\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-1] * inv[i] * P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] * P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-1] * inv[i] + P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] + P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return -(-a // b)",
      "mutated_line": "return -(-a / b)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a / b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return -(-a // b)",
      "mutated_line": "return -(-a * b)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a * b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 1:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == -1:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 1:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n + k + 1, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k + 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C((n + k) * 1, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C((n + k) * 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 or k >= 0 or k <= n else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 or k >= 0 or k <= n else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] * P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] * P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] + P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] + P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 1\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else -1\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 1\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b - 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b - 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b * 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b * 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - i * b, n) * C(n, i) * P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) * P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - i * b, n) * C(n, i) + P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) + P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n - 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n - 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n * 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n * 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return ret * k % P",
      "mutated_line": "return ret / k % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret / k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return ret * k % P",
      "mutated_line": "return (ret + k) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return (ret + k) % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return ret * k % P",
      "mutated_line": "return ret ** k % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret ** k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi + lo + 1)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi + lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi * lo + 1)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi * lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi - lo + 2)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi - lo + 0)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi - lo + 0)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(n, hi - lo + 1)",
      "mutated_line": "return f(n, hi - lo + -1)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + -1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-1] / i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] / i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append((fact[-1] + i) % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append((fact[-1] + i) % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-1] ** i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] ** i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P // i * inv[P % i] * P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] * P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - (P // i * inv[P % i] + P))",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - (P // i * inv[P % i] + P))\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-1] / inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] / inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append((inv_fact[-1] + inv[i]) % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append((inv_fact[-1] + inv[i]) % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-1] ** inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] ** inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -(-a // b)",
      "mutated_line": "return -(+a // b)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(+a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n != 0 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n != 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 2 if n == 0 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 2 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 0 if n == 0 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 0 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 0 if n == 0 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 0 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return -1 if n == 0 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return -1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == 0 else 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 1\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else -1\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == 0 else 1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 1\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n - k - 1, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n - k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n * k - 1, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n * k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n + k - 2, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 2, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n + k - 0, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 0, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n + k - 0, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 0, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return C(n + k - 1, n)",
      "mutated_line": "return C(n + k - -1, n)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - -1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n > 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n > 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n < 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n < 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n == 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n == 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k > 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k > 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k < 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k < 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k == 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k == 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k < n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k < n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k > n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k > n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k == n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k == n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P / inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P / inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return (fact[n] * inv_fact[k] % P + inv_fact[n - k]) % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return (fact[n] * inv_fact[k] % P + inv_fact[n - k]) % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return (fact[n] * inv_fact[k] % P) ** inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return (fact[n] * inv_fact[k] % P) ** inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum / b + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum / b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum * b + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum * b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b + 2):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 2):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b + 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 0):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b + 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 0):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(sum // b + 1):",
      "mutated_line": "for i in range(sum // b + -1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + -1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 != 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 != 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 2 if i & 1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 2 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 0 if i & 1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 0 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 0 if i & 1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 0 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = -1 if i & 1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = -1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 0 else +1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else +1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - i * b, n) / C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) / C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += (sign * part(sum - i * b, n) + C(n, i)) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += (sign * part(sum - i * b, n) + C(n, i)) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += (sign * part(sum - i * b, n)) ** C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += (sign * part(sum - i * b, n)) ** C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k + 1, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k + 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div((n + k) * 1, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div((n + k) * 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n + 2):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 2):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n + 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 0):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n + 0):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 0):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 1, k), n + -1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + -1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n + max, k - 1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n + max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n * max, k - 1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n * max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k + 1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k + 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k * 1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k * 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P // i / inv[P % i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i / inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - (P // i + inv[P % i]) % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - (P // i + inv[P % i]) % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - (P // i) ** inv[P % i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - (P // i) ** inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == 1 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 1 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == -1 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == -1 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1 if n == 0 else 0",
      "mutated_line": "return 1 if n == 1 else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 1 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 1 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 1 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= -1 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= -1 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 1 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 1 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 1 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 1 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= -1 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= -1 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 1 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 1 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] * P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] * P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return (fact[n] * inv_fact[k] + P) * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return (fact[n] * inv_fact[k] + P) * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i | 1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i | 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 1 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 1 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == -1 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == -1 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 1 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 1 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 0 else -2",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -2\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 0 else -0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -0\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 0 else -0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -0\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 1 == 0 else --1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else --1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign / part(sum - i * b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign / part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += (sign + part(sum - i * b, n)) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += (sign + part(sum - i * b, n)) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign ** part(sum - i * b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign ** part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n - k - 1, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n - k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n * k - 1, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n * k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 2, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 2, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 0, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 0, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - 0, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 0, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for max in range(ceil_div(n + k - 1, k), n + 1):",
      "mutated_line": "for max in range(ceil_div(n + k - -1, k), n + 1):",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - -1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k - 2, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 2, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k - 0, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 0, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k - 0, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 0, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ret += g(n - max, k - 1, max)",
      "mutated_line": "ret += g(n - max, k - -1, max)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - -1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[+1] * i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[+1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P / i * inv[P % i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P / i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P * i * inv[P % i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P * i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[+1] * inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[+1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] / inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] / inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return (fact[n] + inv_fact[k]) % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return (fact[n] + inv_fact[k]) % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] ** inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] ** inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n + k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n + k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "mutated_line": "return fact[n] * inv_fact[k] % P * inv_fact[n * k] % P if n >= 0 and k >= 0 and (k <= n) else 0",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n * k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 2 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 2 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 0 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 0 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & 0 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 0 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sign = 1 if i & 1 == 0 else -1",
      "mutated_line": "sign = 1 if i & -1 == 0 else -1",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & -1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-2] * i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-2] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-0] * i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-0] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[-0] * i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-0] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % P)",
      "mutated_line": "fact.append(fact[--1] * i % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[--1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P // i * inv[P * i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P * i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv.append(P - P // i * inv[P % i] % P)",
      "mutated_line": "inv.append(P - P // i * inv[P + i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P + i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-2] * inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-2] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-0] * inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-0] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[-0] * inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-0] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % P)",
      "mutated_line": "inv_fact.append(inv_fact[--1] * inv[i] % P)",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[--1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum + i * b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum + i * b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum * (i * b), n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum * (i * b), n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - i / b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i / b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - (i + b), n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - (i + b), n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret += sign * part(sum - i * b, n) * C(n, i) % P",
      "mutated_line": "ret += sign * part(sum - i ** b, n) * C(n, i) % P",
      "code": "def count_fox_sequences(n: int, lo: int, hi: int) -> int:\n    P = 10 ** 9 + 7\n    fact = [1]\n    for i in range(1, 200001):\n        fact.append(fact[-1] * i % P)\n    inv = [0, 1]\n    for i in range(2, 200001):\n        inv.append(P - P // i * inv[P % i] % P)\n    inv_fact = [1]\n    for i in range(1, 100001):\n        inv_fact.append(inv_fact[-1] * inv[i] % P)\n\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def part(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        return C(n + k - 1, n)\n\n    def C(n, k):\n        return fact[n] * inv_fact[k] % P * inv_fact[n - k] % P if n >= 0 and k >= 0 and (k <= n) else 0\n\n    def g(sum, n, b):\n        ret = 0\n        for i in range(sum // b + 1):\n            sign = 1 if i & 1 == 0 else -1\n            ret += sign * part(sum - i ** b, n) * C(n, i) % P\n            ret %= P\n        return ret\n\n    def f(n, k):\n        ret = 0\n        for max in range(ceil_div(n + k - 1, k), n + 1):\n            ret += g(n - max, k - 1, max)\n            ret %= P\n        return ret * k % P\n    return f(n, hi - lo + 1)"
    }
  ]
}