{
  "task_id": "taco_12166",
  "entry_point": "is_graph_possible",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res = 'Yes'",
      "mutated_line": "res = ''",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = ''\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [0] / n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] / n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [0] + n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] + n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [0] ** n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] ** n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if max(c_list) == 0:",
      "mutated_line": "if max(c_list) != 0:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) != 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if m < min_m:",
      "mutated_line": "if m <= min_m:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m <= min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if m < min_m:",
      "mutated_line": "if m >= min_m:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m >= min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if m < min_m:",
      "mutated_line": "if m != min_m:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m != min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n + 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n * 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n * 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if c_list[i] == 0:",
      "mutated_line": "if c_list[i] != 0:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] != 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if c_list[i] == 1:",
      "mutated_line": "if c_list[i] != 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] != 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if max(c_list) == 0:",
      "mutated_line": "if max(c_list) == 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 1:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if max(c_list) == 0:",
      "mutated_line": "if max(c_list) == -1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == -1:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if max(c_list) == 0:",
      "mutated_line": "if max(c_list) == 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 1:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n + 1",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n + 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n * 1",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n * 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "res = 'No'",
      "mutated_line": "res = ''",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = ''\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m >= n + k * (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m >= n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m <= n + k * (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m <= n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m != n + k * (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m != n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] / (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] / (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] + (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] + (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] ** (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] ** (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if self.par[x] == x:",
      "mutated_line": "if self.par[x] != x:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] != x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] <= self.rank[y]:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] <= self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] >= self.rank[y]:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] >= self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] != self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "return self.find(x) == self.find(y)",
      "mutated_line": "return self.find(x) != self.find(y)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) != self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n - 2)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 2)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n - 0)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 0)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n - 0)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 0)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n - 1)",
      "mutated_line": "uf = UnionFind(n - -1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - -1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c_list[i] == 0:",
      "mutated_line": "if c_list[i] == 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 1:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c_list[i] == 0:",
      "mutated_line": "if c_list[i] == -1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == -1:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c_list[i] == 0:",
      "mutated_line": "if c_list[i] == 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 1:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if c_list[i] == 1:",
      "mutated_line": "if c_list[i] == 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 2:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if c_list[i] == 1:",
      "mutated_line": "if c_list[i] == 0:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 0:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if c_list[i] == 1:",
      "mutated_line": "if c_list[i] == 0:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 0:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if c_list[i] == 1:",
      "mutated_line": "if c_list[i] == -1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == -1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [1] * n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [1] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [-1] * n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [-1] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "par_list = [0] * n",
      "mutated_line": "par_list = [1] * n",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [1] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n - 2",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 2\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n - 0",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 0\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n - 0",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 0\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "min_m = n - 1",
      "mutated_line": "min_m = n - -1",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - -1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n - k * (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n - k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n * (k * (k - 3) // 2):",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n * (k * (k - 3) // 2):\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "res = 'No'",
      "mutated_line": "res = ''",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = ''\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n - 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n - 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n * 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n * 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if self.rank[x] == self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] != self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] -= 1",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] -= 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = 'No'",
      "mutated_line": "res = ''",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = ''\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) / 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) / 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) * 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) * 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [1] * (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [-1] * (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [1] * (n + 1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 2)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 2)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 0)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 0)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 0)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 0)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + -1)",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + -1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 2",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 2\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 0\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 0\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += -1",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += -1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k / (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k / (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + (k + (k - 3)) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + (k + (k - 3)) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k ** (k - 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k ** (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) // 3:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 3:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) // 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 1:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) // 0:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 0:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) // 1:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 1:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 3) // -2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // -2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n - 1)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n - 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n * 1)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n * 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k + 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k + 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k * 3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k * 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 2)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 2)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 0)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 0)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 0)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 0)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + -1)]",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + -1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 3) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 4) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 4) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 2) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 2) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 0) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 0) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - 1) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - 1) // 2:\n        res = 'No'\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif m > n + k * (k - 3) // 2:",
      "mutated_line": "elif m > n + k * (k - -3) // 2:",
      "code": "def is_graph_possible(n, m, q, a_list, b_list, c_list):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n    res = 'Yes'\n    uf = UnionFind(n - 1)\n    for i in range(q):\n        if c_list[i] == 0:\n            uf.union(a_list[i], b_list[i])\n    for i in range(q):\n        if c_list[i] == 1:\n            if uf.same_check(a_list[i], b_list[i]):\n                res = 'No'\n    par_list = [0] * n\n    for i in range(n):\n        par_list[i] = uf.find(i)\n    k = len(set(par_list))\n    if max(c_list) == 0:\n        min_m = n - 1\n    else:\n        min_m = n\n    if m < min_m:\n        res = 'No'\n    elif m > n + k * (k - -3) // 2:\n        res = 'No'\n    return res"
    }
  ]
}