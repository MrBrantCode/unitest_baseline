{
  "task_id": "taco_3253",
  "entry_point": "calculate_max_damage",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 1\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = -1\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 1\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * m",
      "mutated_line": "used = [False] / m",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] / m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * m",
      "mutated_line": "used = [False] + m",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] + m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * m",
      "mutated_line": "used = [False] ** m",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] ** m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])",
      "mutated_line": "return ret - sum([ciel_cards[i] for i in range(m) if not used[i]])",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret - sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])",
      "mutated_line": "return ret * sum([ciel_cards[i] for i in range(m) if not used[i]])",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret * sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 1\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = -1\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 1\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "a = [val for pos, val in jiro_cards if pos == 'ATK']",
      "mutated_line": "d = [val for (pos, val) in jiro_cards if pos == 'DEF']",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos != 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "d = [val for pos, val in jiro_cards if pos == 'DEF']",
      "mutated_line": "d = [val for (pos, val) in jiro_cards if pos != 'DEF']",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos != 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ciel_cards[k] >= a[k]:",
      "mutated_line": "if ciel_cards[k] > a[k]:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] > a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ciel_cards[k] >= a[k]:",
      "mutated_line": "if ciel_cards[k] < a[k]:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] < a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ciel_cards[k] >= a[k]:",
      "mutated_line": "if ciel_cards[k] == a[k]:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] == a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "ret += ciel_cards[k] - a[k]",
      "mutated_line": "ret -= ciel_cards[k] - a[k]",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret -= ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "a = [val for pos, val in jiro_cards if pos == 'ATK']",
      "mutated_line": "d = [val for (pos, val) in jiro_cards if pos == 'DEF']",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == '']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [val for pos, val in jiro_cards if pos == 'DEF']",
      "mutated_line": "d = [val for (pos, val) in jiro_cards if pos == '']",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == '']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * m",
      "mutated_line": "used = [True] * m",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [True] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if not used[i] and ciel_cards[i] > val:",
      "mutated_line": "if not used[i] or ciel_cards[i] > val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] or ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 1\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return -1\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 1\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not used[i] and ciel_cards[i] >= val:",
      "mutated_line": "if not used[i] or ciel_cards[i] >= val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] or ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ret += ciel_cards[i] - val",
      "mutated_line": "ret -= ciel_cards[i] - val",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret -= ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 1\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return -1\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 1\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret += ciel_cards[k] - a[k]",
      "mutated_line": "ret += ciel_cards[k] + a[k]",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] + a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret += ciel_cards[k] - a[k]",
      "mutated_line": "ret += ciel_cards[k] * a[k]",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] * a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not used[i] and ciel_cards[i] > val:",
      "mutated_line": "if not used[i] and ciel_cards[i] >= val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not used[i] and ciel_cards[i] > val:",
      "mutated_line": "if not used[i] and ciel_cards[i] <= val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] <= val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not used[i] and ciel_cards[i] > val:",
      "mutated_line": "if not used[i] and ciel_cards[i] != val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] != val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "used[i] = True",
      "mutated_line": "used[i] = False",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = False\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not used[i] and ciel_cards[i] >= val:",
      "mutated_line": "if not used[i] and ciel_cards[i] > val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not used[i] and ciel_cards[i] >= val:",
      "mutated_line": "if not used[i] and ciel_cards[i] < val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] < val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not used[i] and ciel_cards[i] >= val:",
      "mutated_line": "if not used[i] and ciel_cards[i] == val:",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] == val:\n                    used[i] = True\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[i] = True",
      "mutated_line": "used[i] = False",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = False\n                    ret += ciel_cards[i] - val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret += ciel_cards[i] - val",
      "mutated_line": "ret += ciel_cards[i] + val",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] + val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret += ciel_cards[i] - val",
      "mutated_line": "ret += ciel_cards[i] * val",
      "code": "def calculate_max_damage(n, m, jiro_cards, ciel_cards):\n    a = [val for (pos, val) in jiro_cards if pos == 'ATK']\n    d = [val for (pos, val) in jiro_cards if pos == 'DEF']\n    ciel_cards.sort()\n    a.sort()\n    d.sort()\n\n    def solve1():\n        ret = 0\n        used = [False] * m\n        for val in d:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] > val:\n                    used[i] = True\n                    break\n            else:\n                return 0\n        for val in a:\n            for i in range(m):\n                if not used[i] and ciel_cards[i] >= val:\n                    used[i] = True\n                    ret += ciel_cards[i] * val\n                    break\n            else:\n                return 0\n        return ret + sum([ciel_cards[i] for i in range(m) if not used[i]])\n\n    def solve2():\n        ret = 0\n        ciel_cards.reverse()\n        for k in range(min(len(a), m)):\n            if ciel_cards[k] >= a[k]:\n                ret += ciel_cards[k] - a[k]\n            else:\n                break\n        return ret\n    return max(solve1(), solve2())"
    }
  ]
}