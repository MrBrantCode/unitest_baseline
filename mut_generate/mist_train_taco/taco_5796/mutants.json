{
  "task_id": "taco_5796",
  "entry_point": "min_edges_to_harmonious",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "sz[p1] += sz[p2]",
      "mutated_line": "sz[p1] -= sz[p2]",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] -= sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [1] / n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] / n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [1] + n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] + n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [1] ** n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] ** n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u += 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v += 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "comp = 0",
      "mutated_line": "comp = 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 1\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "comp = 0",
      "mutated_line": "comp = -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = -1\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "comp = 0",
      "mutated_line": "comp = 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 1\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mxb = 0",
      "mutated_line": "mxb = 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 1\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mxb = 0",
      "mutated_line": "mxb = -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = -1\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mxb = 0",
      "mutated_line": "mxb = 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 1\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if par[u] == u:",
      "mutated_line": "if par[u] != u:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] != u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if p1 == p2:",
      "mutated_line": "if p1 != p2:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 != p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if sz[p1] < sz[p2]:",
      "mutated_line": "if sz[p1] <= sz[p2]:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] <= sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if sz[p1] < sz[p2]:",
      "mutated_line": "if sz[p1] >= sz[p2]:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] >= sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if sz[p1] < sz[p2]:",
      "mutated_line": "if sz[p1] != sz[p2]:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] != sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 2\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 0\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 0\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= -1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 2\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 0\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 0\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= -1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if find(i) == i:",
      "mutated_line": "if find(i) != i:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) != i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "comp += 1",
      "mutated_line": "comp -= 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp -= 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mxb == i:",
      "mutated_line": "if mxb != i:",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb != i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "comp -= 1",
      "mutated_line": "comp += 1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp += 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [2] * n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [2] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [0] * n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [0] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [0] * n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [0] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sz = [1] * n",
      "mutated_line": "sz = [-1] * n",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [-1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comp += 1",
      "mutated_line": "comp += 2",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 2\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comp += 1",
      "mutated_line": "comp += 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 0\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comp += 1",
      "mutated_line": "comp += 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 0\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comp += 1",
      "mutated_line": "comp += -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += -1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 1\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "comp -= 1",
      "mutated_line": "comp -= 2",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 2\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "comp -= 1",
      "mutated_line": "comp -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 0\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "comp -= 1",
      "mutated_line": "comp -= 0",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= 0\n    return comp"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "comp -= 1",
      "mutated_line": "comp -= -1",
      "code": "def min_edges_to_harmonious(n, m, edges):\n\n    def find(u):\n        if par[u] == u:\n            return u\n        return find(par[u])\n\n    def unite(u, v):\n        p1 = find(u)\n        p2 = find(v)\n        if p1 == p2:\n            return\n        if sz[p1] < sz[p2]:\n            (p1, p2) = (p2, p1)\n        sz[p1] += sz[p2]\n        mx[p1] = max(mx[p1], mx[p2])\n        par[p2] = p1\n    par = [i for i in range(n)]\n    mx = [i for i in range(n)]\n    sz = [1] * n\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        unite(u, v)\n    comp = 0\n    mxb = 0\n    for i in range(n):\n        if find(i) == i:\n            comp += 1\n    for i in range(n):\n        mxb = max(mxb, mx[find(i)])\n        if mxb == i:\n            comp -= -1\n    return comp"
    }
  ]
}