{
  "task_id": "taco_2450",
  "entry_point": "min_push_box",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "time += 1",
      "mutated_line": "time -= 1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time -= 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 1\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = -1\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 1\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count -= 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return +1"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "g[grid[i][j]] += [complex(i, j)]",
      "mutated_line": "g[grid[i][j]] -= [complex(i, j)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] -= [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time += 1",
      "mutated_line": "time += 2",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 2\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 0\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 0\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time += 1",
      "mutated_line": "time += -1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += -1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "boxToTarget = b - target",
      "mutated_line": "boxToTarget = b + target",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b + target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "boxToTarget = b - target",
      "mutated_line": "boxToTarget = b * target",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b * target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 2)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 2)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 0)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 0)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 0)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 0)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], -1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], -1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "low = dict.fromkeys(floor, 0)",
      "mutated_line": "low = dict.fromkeys(floor, 1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 1)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "low = dict.fromkeys(floor, 0)",
      "mutated_line": "low = dict.fromkeys(floor, -1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, -1)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "low = dict.fromkeys(floor, 0)",
      "mutated_line": "low = dict.fromkeys(floor, 1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 1)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 2\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 0\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 0\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += -1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "tarjan(box, -1)",
      "mutated_line": "tarjan(box, +1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, +1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] == low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] == low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if not low[player] * low[target]:",
      "mutated_line": "if not low[player] / low[target]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] / low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if not low[player] * low[target]:",
      "mutated_line": "if not low[player] + low[target]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] + low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if not low[player] * low[target]:",
      "mutated_line": "if not low[player] ** low[target]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] ** low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return +1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "mutated_line": "return (abs(boxToTarget.real) + abs(boxToTarget.imag) - s, abs(boxToTarget), time)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) - s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "mutated_line": "return ((abs(boxToTarget.real) + abs(boxToTarget.imag)) * s, abs(boxToTarget), time)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return ((abs(boxToTarget.real) + abs(boxToTarget.imag)) * s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 1), 2, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 2, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 1), 0, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 0, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 1), 0, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 0, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 1), -1, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), -1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((2, -1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((2, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((0, -1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((0, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((0, -1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((0, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((-1, -1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((-1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, +1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, +1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, -1, 1j, +1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, +1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nextIndex = currIndex + direction",
      "mutated_line": "nextIndex = currIndex - direction",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex - direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nextIndex = currIndex + direction",
      "mutated_line": "nextIndex = currIndex * direction",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex * direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if nextIndex in floor and nextIndex != parentIndex:",
      "mutated_line": "if nextIndex in floor or nextIndex != parentIndex:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor or nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tarjan(box, -1)",
      "mutated_line": "tarjan(box, -2)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -2)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tarjan(box, -1)",
      "mutated_line": "tarjan(box, -0)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -0)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tarjan(box, -1)",
      "mutated_line": "tarjan(box, -0)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -0)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "tarjan(box, -1)",
      "mutated_line": "tarjan(box, --1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, --1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -2\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -0\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -0\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return --1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "mutated_line": "if nextBox in floor or nextPlayer in floor or (nextPlayer, currBox) not in visited or (low[currPlayer] == low[nextPlayer]):",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor or nextPlayer in floor or (nextPlayer, currBox) not in visited or (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))",
      "mutated_line": "(m, n, g) = (len(grid), len(grid[1]), collections.defaultdict(list))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[1]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))",
      "mutated_line": "(m, n, g) = (len(grid), len(grid[-1]), collections.defaultdict(list))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[-1]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))",
      "mutated_line": "(m, n, g) = (len(grid), len(grid[1]), collections.defaultdict(list))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[1]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "mutated_line": "return (abs(boxToTarget.real) - abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) - abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "mutated_line": "return (abs(boxToTarget.real) * abs(boxToTarget.imag) + s, abs(boxToTarget), time)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) * abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g[''], *g['B'], *g['T'], 1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g[''], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g[''], *g['T'], 1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g[''], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)",
      "mutated_line": "(player, box, target, time) = (*g['S'], *g['B'], *g[''], 1)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g[''], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "floor = {player, box, target, *g['.']}",
      "mutated_line": "floor = {player, box, target, *g['']}",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 2), 1, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 2), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 0), 1, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 0), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, 0), 1, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 0), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "alpha = [(f(box, 1), 1, player, box)]",
      "mutated_line": "alpha = [(f(box, -1), 1, player, box)]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, -1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, -2, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -2, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, -0, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -0, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, -0, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -0, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(directions, visited) = ((1, -1, 1j, -1j), set())",
      "mutated_line": "(directions, visited) = ((1, --1, 1j, -1j), set())",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, --1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nextIndex in floor and nextIndex != parentIndex:",
      "mutated_line": "if nextIndex not in floor and nextIndex != parentIndex:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex not in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nextIndex in floor and nextIndex != parentIndex:",
      "mutated_line": "if nextIndex in floor and nextIndex == parentIndex:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex == parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:+2]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:+2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "(nextPlayer, nextBox) = (currBox - direction, currBox + direction)",
      "mutated_line": "(nextPlayer, nextBox) = (currBox + direction, currBox + direction)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox + direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "(nextPlayer, nextBox) = (currBox - direction, currBox + direction)",
      "mutated_line": "(nextPlayer, nextBox) = (currBox * direction, currBox + direction)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox * direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "(nextPlayer, nextBox) = (currBox - direction, currBox + direction)",
      "mutated_line": "(nextPlayer, nextBox) = (currBox - direction, currBox - direction)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox - direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "(nextPlayer, nextBox) = (currBox - direction, currBox + direction)",
      "mutated_line": "(nextPlayer, nextBox) = (currBox - direction, currBox * direction)",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox * direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "mutated_line": "if nextBox not in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox not in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "mutated_line": "if nextBox in floor and nextPlayer not in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer not in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "mutated_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) in visited) and (low[currPlayer] == low[nextPlayer]):",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):",
      "mutated_line": "if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] != low[nextPlayer]):",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] != low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if nextBox == target:",
      "mutated_line": "if nextBox != target:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox != target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[+1]] != low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[+1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] != low[connect[+1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[+1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:-3]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-3]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:-1]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-1]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:-0]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-0]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:-1]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-1]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for w in connect[:-2]:",
      "mutated_line": "for w in connect[:--2]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:--2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "low[w] = low[connect[-1]]",
      "mutated_line": "low[w] = low[connect[+1]]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[+1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-2]] != low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-2]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-0]] != low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-0]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-0]] != low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-0]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[--1]] != low[connect[-1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[--1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] != low[connect[-2]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-2]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] != low[connect[-0]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-0]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] != low[connect[-0]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-0]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while dfn[connect[-1]] != low[connect[-1]]:",
      "mutated_line": "while dfn[connect[-1]] != low[connect[--1]]:",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[--1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "low[w] = low[connect[-1]]",
      "mutated_line": "low[w] = low[connect[-2]]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-2]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "low[w] = low[connect[-1]]",
      "mutated_line": "low[w] = low[connect[-0]]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-0]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "low[w] = low[connect[-1]]",
      "mutated_line": "low[w] = low[connect[-0]]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-0]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "low[w] = low[connect[-1]]",
      "mutated_line": "low[w] = low[connect[--1]]",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[--1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps - 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps - 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps * 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps * 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "connect.append(index[low[connect[-1]]])",
      "mutated_line": "connect.append(index[low[connect[+1]]])",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[+1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps - 1), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps - 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps * 1), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps * 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 2, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 2, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 0, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 0, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 0, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 0, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + -1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + -1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "connect.append(index[low[connect[-1]]])",
      "mutated_line": "connect.append(index[low[connect[-2]]])",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-2]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "connect.append(index[low[connect[-1]]])",
      "mutated_line": "connect.append(index[low[connect[-0]]])",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-0]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "connect.append(index[low[connect[-1]]])",
      "mutated_line": "connect.append(index[low[connect[-0]]])",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-0]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "connect.append(index[low[connect[-1]]])",
      "mutated_line": "connect.append(index[low[connect[--1]]])",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[--1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 2), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 2), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 0), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 0), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + 0), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + 0), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))",
      "mutated_line": "heapq.heappush(alpha, (f(nextBox, steps + -1), steps + 1, currBox, nextBox))",
      "code": "import heapq\nimport collections\n\ndef min_push_box(grid):\n    (m, n, g) = (len(grid), len(grid[0]), collections.defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            g[grid[i][j]] += [complex(i, j)]\n\n    def f(b, s):\n        nonlocal time\n        time += 1\n        boxToTarget = b - target\n        return (abs(boxToTarget.real) + abs(boxToTarget.imag) + s, abs(boxToTarget), time)\n    (player, box, target, time) = (*g['S'], *g['B'], *g['T'], 1)\n    floor = {player, box, target, *g['.']}\n    alpha = [(f(box, 1), 1, player, box)]\n    (directions, visited) = ((1, -1, 1j, -1j), set())\n    low = dict.fromkeys(floor, 0)\n    dfn = low.copy()\n    count = 0\n    index = {}\n\n    def tarjan(currIndex, parentIndex):\n        nonlocal count\n        count += 1\n        dfn[currIndex] = low[currIndex] = count\n        index[count] = currIndex\n        for direction in directions:\n            nextIndex = currIndex + direction\n            if nextIndex in floor and nextIndex != parentIndex:\n                if not low[nextIndex]:\n                    tarjan(nextIndex, currIndex)\n                low[currIndex] = min(low[currIndex], low[nextIndex])\n    tarjan(box, -1)\n    for currIndex in floor:\n        connect = [currIndex]\n        while dfn[connect[-1]] != low[connect[-1]]:\n            connect.append(index[low[connect[-1]]])\n        for w in connect[:-2]:\n            low[w] = low[connect[-1]]\n    if not low[player] * low[target]:\n        return -1\n    while alpha:\n        (_, steps, currPlayer, currBox) = heapq.heappop(alpha)\n        for direction in directions:\n            (nextPlayer, nextBox) = (currBox - direction, currBox + direction)\n            if nextBox in floor and nextPlayer in floor and ((nextPlayer, currBox) not in visited) and (low[currPlayer] == low[nextPlayer]):\n                if nextBox == target:\n                    return steps\n                heapq.heappush(alpha, (f(nextBox, steps + -1), steps + 1, currBox, nextBox))\n                visited.add((nextPlayer, currBox))\n    return -1"
    }
  ]
}