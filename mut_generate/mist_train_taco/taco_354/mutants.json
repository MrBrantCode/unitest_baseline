{
  "task_id": "taco_354",
  "entry_point": "count_multisets_by_average",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in R(1, N):",
      "mutated_line": "for i in R(2, N):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(2, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in R(1, N):",
      "mutated_line": "for i in R(0, N):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(0, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in R(1, N):",
      "mutated_line": "for i in R(0, N):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(0, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in R(1, N):",
      "mutated_line": "for i in R(-1, N):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(-1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q = K * i",
      "mutated_line": "q = K / i",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K / i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q = K * i",
      "mutated_line": "q = K + i",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K + i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q = K * i",
      "mutated_line": "q = K ** i",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K ** i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i > ~i + N:",
      "mutated_line": "if i >= ~i + N:",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i >= ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i > ~i + N:",
      "mutated_line": "if i <= ~i + N:",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i <= ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i > ~i + N:",
      "mutated_line": "if i != ~i + N:",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i != ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T -= [(y := T[-1][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T -= [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T -= [(y := (T[-1][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T -= [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = len(y) - i",
      "mutated_line": "p = len(y) + i",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) + i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = len(y) - i",
      "mutated_line": "p = len(y) * i",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) * i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "y[j + i] += y[j] % M",
      "mutated_line": "y[j + i] -= y[j] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] -= y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] += y[~j - i - q] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] += y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "T = [[1]]",
      "mutated_line": "T = [[2]]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[2]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "T = [[1]]",
      "mutated_line": "T = [[0]]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[0]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "T = [[1]]",
      "mutated_line": "T = [[0]]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[0]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "T = [[1]]",
      "mutated_line": "T = [[-1]]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[-1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if i > ~i + N:",
      "mutated_line": "if i > ~i - N:",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i - N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if i > ~i + N:",
      "mutated_line": "if i > ~i * N:",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i * N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "y[j + i] += y[j] % M",
      "mutated_line": "y[j + i] += y[j] * M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] * M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "y[j + i] += y[j] % M",
      "mutated_line": "y[j + i] += y[j] + M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] + M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in R(p - q):",
      "mutated_line": "for j in R(p + q):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p + q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in R(p - q):",
      "mutated_line": "for j in R(p * q):",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p * q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[~j - i - q] * M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] * M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[~j - i - q] + M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] + M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M + 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M + 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M * 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M * 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "y[j + i] += y[j] % M",
      "mutated_line": "y[j - i] += y[j] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j - i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "y[j + i] += y[j] % M",
      "mutated_line": "y[j * i] += y[j] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j * i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K * M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K * M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K + M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K + M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 2)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 2)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 0)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 0)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - -1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - -1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] - [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] - [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] * ([0] * q)))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] * ([0] * q)))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[~j - i + q] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i + q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[(~j - i) * q] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[(~j - i) * q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) / -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) / -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append((sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) + -~K) % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append((sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) + -~K) % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) ** (-~K) % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) ** (-~K) % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + [0] / q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] / q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + ([0] + q)))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + ([0] + q)))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + [0] ** q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] ** q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[~j + i - q] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j + i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "y[~j] -= y[~j - i - q] % M",
      "mutated_line": "y[~j] -= y[~j * i - q] % M",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j * i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * +~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * +~K % M - 1)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[+1][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[+1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[-2][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-2][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[-0][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-0][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[-0][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-0][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[--1][:len(T[~i + N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[--1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[+1][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[+1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + [1] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [1] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + [-1] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [-1] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-1][:] + [1] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [1] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] / T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] / T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] + T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] + T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] ** T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] ** T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[-1][:len(T[~i - N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i - N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "T += [(y := T[-1][:len(T[~i + N])])]",
      "mutated_line": "T += [(y := T[-1][:len(T[~i * N])])]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i * N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-2][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-2][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-0][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-0][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[-0][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-0][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "T += [(y := (T[-1][:] + [0] * q))]",
      "mutated_line": "T += [(y := (T[--1][:] + [0] * q))]",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[--1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i - N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i - N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result.append(sum((T[i][j] * T[~i + N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "mutated_line": "result.append(sum((T[i][j] * T[~i * N][j] for j in R(len(T[i])))) * -~K % M - 1)",
      "code": "def count_multisets_by_average(N: int, K: int, M: int) -> list[int]:\n    \"\"\"\n    Calculate the number of non-empty multisets containing between 0 and K instances\n    of each of the integers 1 through N such that the average of the elements is x,\n    for each x from 1 to N, modulo M.\n\n    Parameters:\n    - N (int): The maximum integer value in the multisets.\n    - K (int): The maximum number of instances of each integer in the multisets.\n    - M (int): The modulus for the result.\n\n    Returns:\n    - list[int]: A list of integers where the i-th element represents the number of\n                 multisets such that the average of the elements is i+1, modulo M.\n    \"\"\"\n    R = range\n    T = [[1]]\n    for i in R(1, N):\n        q = K * i\n        if i > ~i + N:\n            T += [(y := T[-1][:len(T[~i + N])])]\n        else:\n            T += [(y := (T[-1][:] + [0] * q))]\n        p = len(y) - i\n        for j in R(p):\n            y[j + i] += y[j] % M\n        for j in R(p - q):\n            y[~j] -= y[~j - i - q] % M\n    result = []\n    for i in R(N):\n        result.append(sum((T[i][j] * T[~i * N][j] for j in R(len(T[i])))) * -~K % M - 1)\n    return result"
    }
  ]
}