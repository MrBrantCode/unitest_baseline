{
  "task_id": "taco_6327",
  "entry_point": "minimum_coins_for_chips",
  "mutant_count": 140,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if mc == 1:",
      "mutated_line": "if mc != 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc != 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "has_one = 1 in costs",
      "mutated_line": "has_one = 1 not in costs",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 not in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(extras) == 0:",
      "mutated_line": "if len(extras) != 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) != 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if mc == 1:",
      "mutated_line": "if mc == 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 2:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if mc == 1:",
      "mutated_line": "if mc == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 0:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if mc == 1:",
      "mutated_line": "if mc == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 0:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if mc == 1:",
      "mutated_line": "if mc == -1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == -1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "has_one = 1 in costs",
      "mutated_line": "has_one = 2 in costs",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 2 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "has_one = 1 in costs",
      "mutated_line": "has_one = 0 in costs",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 0 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "has_one = 1 in costs",
      "mutated_line": "has_one = 0 in costs",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 0 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "has_one = 1 in costs",
      "mutated_line": "has_one = -1 in costs",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = -1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "extras.discard(0)",
      "mutated_line": "extras.discard(1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(1)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "extras.discard(0)",
      "mutated_line": "extras.discard(-1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(-1)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "extras.discard(0)",
      "mutated_line": "extras.discard(1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(1)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q, r = divmod(mc, 3)",
      "mutated_line": "(q, r) = divmod(mc, 4)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 4)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q, r = divmod(mc, 3)",
      "mutated_line": "(q, r) = divmod(mc, 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 2)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q, r = divmod(mc, 3)",
      "mutated_line": "(q, r) = divmod(mc, 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 0)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q, r = divmod(mc, 3)",
      "mutated_line": "(q, r) = divmod(mc, 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 1)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q, r = divmod(mc, 3)",
      "mutated_line": "(q, r) = divmod(mc, -3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, -3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(extras) == 0:",
      "mutated_line": "if len(extras) == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 1:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(extras) == 0:",
      "mutated_line": "if len(extras) == -1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == -1:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(extras) == 0:",
      "mutated_line": "if len(extras) == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 1:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif len(extras) == 1:",
      "mutated_line": "elif len(extras) != 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) != 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(2)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(0)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(0)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(-1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(-1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num * 3 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num * 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num + 3 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num + 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc >= num >= 3 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc >= num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc <= num >= 3 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc <= num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc != num >= 3 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc != num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.append(q + (not not r))",
      "mutated_line": "results.append(q - (not not r))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q - (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.append(q + (not not r))",
      "mutated_line": "results.append(q * (not not r))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q * (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif len(extras) == 1:",
      "mutated_line": "elif len(extras) == 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 2:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif len(extras) == 1:",
      "mutated_line": "elif len(extras) == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 0:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif len(extras) == 1:",
      "mutated_line": "elif len(extras) == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 0:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif len(extras) == 1:",
      "mutated_line": "elif len(extras) == -1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == -1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if r in extras:",
      "mutated_line": "if r not in extras:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r not in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r != 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r != 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % 4 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 4 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % 2 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 2 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % 0 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 0 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % 1 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 1 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % -3 for num in costs if num != mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % -3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "extras = set((num % 3 for num in costs if num != mc))",
      "mutated_line": "extras = set((num % 3 for num in costs if num == mc))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num == mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 3 / q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 / q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 3 + q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 + q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 3 ** q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 ** q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r != 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r != 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 3:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 3:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 1:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 0:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 1:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == -2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == -2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r != 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r != 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 4 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 4 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 2 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 2 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 0 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 0 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= 1 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 1 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "close_call = any((mc > num >= 3 * q for num in costs))",
      "mutated_line": "close_call = any((mc > num >= -3 * q for num in costs))",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= -3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q - 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q - 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q * 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q * 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 2:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 0:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 0:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == -1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == -1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r != 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r != 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q - 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q - 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q * 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q * 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 2:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 0:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 0:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif r == 1:",
      "mutated_line": "elif r == -1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == -1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 2)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 0)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 0)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + -1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + -1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 3:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 3:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 1:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 0:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 0:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == 1:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 1:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif r == 2:",
      "mutated_line": "elif r == -2:",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == -2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 3)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 1)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 0)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 1)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + -2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + -2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q - 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q - 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q * 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q * 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q - 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q - 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q * 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q * 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q - 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q - 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q * 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q * 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q - 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q - 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q * 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q * 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q - 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q - 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q * 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q * 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q - 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q - 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q * 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q * 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + -1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 3)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 1)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 0)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 1)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + -2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + -2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 2)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 0)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 0)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + -1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + -1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 3)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 1)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 0)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 1)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + -2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + -2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 2)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 0)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 0)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + -1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + -1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 3)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 1)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 0)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 1)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + -2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + -2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q - 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q - 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q * 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q * 2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q - 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q - 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q * 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q * 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 3)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 3)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 1)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 0)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + 1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 1)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(q + 2)",
      "mutated_line": "results.append(q + -2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + -2)\n            else:\n                results.append(q + 1)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 2)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 2)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 0)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + 0)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + 0)\n        else:\n            results.append(q + 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(q + 1)",
      "mutated_line": "results.append(q + -1)",
      "code": "def minimum_coins_for_chips(test_cases):\n    results = []\n    for case in test_cases:\n        (n, costs) = case\n        mc = max(costs)\n        if mc == 1:\n            results.append(1)\n            continue\n        has_one = 1 in costs\n        extras = set((num % 3 for num in costs if num != mc))\n        extras.discard(0)\n        (q, r) = divmod(mc, 3)\n        close_call = any((mc > num >= 3 * q for num in costs))\n        if len(extras) == 0:\n            results.append(q + (not not r))\n        elif len(extras) == 1:\n            if r in extras:\n                results.append(q + 1)\n            elif r == 1:\n                if close_call:\n                    results.append(q + 2)\n                else:\n                    results.append(q + 1)\n            elif r == 2:\n                results.append(q + 2)\n            else:\n                results.append(q + 1)\n        elif r == 2:\n            results.append(q + 2)\n        elif r == 1:\n            if has_one:\n                results.append(q + 2)\n            elif close_call:\n                results.append(q + 2)\n            else:\n                results.append(q + -1)\n        else:\n            results.append(q + 1)\n    return results"
    }
  ]
}