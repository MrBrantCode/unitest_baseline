{
  "task_id": "taco_15380",
  "entry_point": "find_longest_valid_subsequence",
  "mutant_count": 257,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 1\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = -1\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 1\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "result += int(c)",
      "mutated_line": "result -= int(c)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result -= int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 1\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cur = 0",
      "mutated_line": "cur = -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = -1\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 1\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card + 1 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card + 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card * 1 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card * 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n + 2, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n + 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n * 2, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n * 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, +1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, +1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, +1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, +1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i - 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i - 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i * 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i * 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 2",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 2\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 0\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 0\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = -1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos == -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos == -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j -= 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = -1\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [True for _ in range(8)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [True for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "appear[c] = True",
      "mutated_line": "appear[c] = False",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = False\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(10, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(10, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(8, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(8, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(0, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(0, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(1, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(1, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(-9, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(-9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, +1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, +1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -1, +1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, +1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if cur + tpow < n:",
      "mutated_line": "if cur + tpow <= n:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow <= n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if cur + tpow < n:",
      "mutated_line": "if cur + tpow >= n:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow >= n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if cur + tpow < n:",
      "mutated_line": "if cur + tpow != n:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow != n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card - 2 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 2 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card - 0 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 0 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card - 0 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 0 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [card - 1 for card in cards]",
      "mutated_line": "a = [card - -1 for card in cards]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - -1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[+1 for _ in range(8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[+1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 3, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 3, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 0, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - -2, -1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - -2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -2, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -2, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -0, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -0, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -0, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -0, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, --1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, --1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -2):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -2):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -0):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -0):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -0):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -0):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, --1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, --1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i + 2",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 2\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 0\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 0\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 1]] = i + -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + -1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[+1 for _ in range(n + 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[+1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos != +1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != +1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 2\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 0\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 0\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += -1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][1] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][-1] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][-1] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][1] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) + 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) + 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) * 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) * 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -2, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -2, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -0, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -0, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -0, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -0, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, --1, -1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, --1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -1, -2):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -2):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -1, -0):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -0):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -1, -0):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -0):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for lev in range(9, -1, -1):",
      "mutated_line": "for lev in range(9, -1, --1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, --1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tpow = 1 << lev",
      "mutated_line": "tpow = 2 << lev",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 2 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tpow = 1 << lev",
      "mutated_line": "tpow = 0 << lev",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 0 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tpow = 1 << lev",
      "mutated_line": "tpow = 0 << lev",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 0 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tpow = 1 << lev",
      "mutated_line": "tpow = -1 << lev",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = -1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if cur + tpow < n:",
      "mutated_line": "if cur - tpow < n:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur - tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if cur + tpow < n:",
      "mutated_line": "if cur * tpow < n:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur * tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret == -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret == -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "cur += tpow",
      "mutated_line": "cur -= tpow",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur -= tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-2 for _ in range(8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-2 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-0 for _ in range(8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-0 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-0 for _ in range(8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-0 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[--1 for _ in range(8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[--1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i - 1])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i - 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i * 1])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i * 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i - 1]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i - 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i * 1]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i * 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-2 for _ in range(n + 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-2 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-0 for _ in range(n + 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-0 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-0 for _ in range(n + 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-0 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[--1 for _ in range(n + 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[--1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos != -2:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -2:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -0:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -0:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while cpos != -1:",
      "mutated_line": "while cpos != --1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != --1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[+1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[+1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[1][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[-1][0] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[-1][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[1][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 or dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 or dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) - 2]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 2]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) - 0]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 0]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) - 0]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 0]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 8) - -1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - -1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [False for _ in range(9)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(9)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [False for _ in range(7)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(7)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [False for _ in range(0)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(0)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [False for _ in range(1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(1)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "appear = [False for _ in range(8)]",
      "mutated_line": "appear = [False for _ in range(-8)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(-8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ret = getLen(cur + tpow)",
      "mutated_line": "ret = getLen(cur - tpow)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur - tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ret = getLen(cur + tpow)",
      "mutated_line": "ret = getLen(cur * tpow)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur * tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret != +1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != +1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-1 for _ in range(9)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(9)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-1 for _ in range(7)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(7)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-1 for _ in range(0)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(0)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-1 for _ in range(1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(1)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nextcard = [[-1 for _ in range(8)] for _ in range(n)]",
      "mutated_line": "nextcard = [[-1 for _ in range(-8)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(-8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i + 2])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 2])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i + 0])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 0])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i + 0])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 0])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "nextcard[i] = copy.copy(nextcard[i + 1])",
      "mutated_line": "nextcard[i] = copy.copy(nextcard[i + -1])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + -1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 2]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 2]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 0]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 0]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + 0]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 0]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "nextcard[i][a[i + 1]] = i + 1",
      "mutated_line": "nextcard[i][a[i + -1]] = i + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + -1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n - 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n - 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n * 1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n * 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-2 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-2 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-0 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-0 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[--1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[--1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n - 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n - 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n * 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n * 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(2 << 8):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(2 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(0 << 8):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(0 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(0 << 8):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(0 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(-1 << 8):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(-1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(1 << 9):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 9):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(1 << 7):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 7):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(1 << 0):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 0):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(1 << 1):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 1):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for comb in range(1 << 8):",
      "mutated_line": "for comb in range(1 << -8):",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << -8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card != 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card != 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] == -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] == -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb - (1 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb - (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb * (1 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb * (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] == -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] == -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] == -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] == -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(2 << 8) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(2 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(0 << 8) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(0 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(0 << 8) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(0 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(-1 << 8) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(-1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 9) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 9) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 7) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 7) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 0) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 0) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << 1) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 1) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dp[n][(1 << 8) - 1]",
      "mutated_line": "return dp[n][(1 << -8) - 1]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << -8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret != -2:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -2:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -0:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -0:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if ret != -1:",
      "mutated_line": "if ret != --1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != --1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n + 2)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 2)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n + 0)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 0)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n + 0)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 0)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "jump = [[-1 for _ in range(n + 1)] for _ in range(n)]",
      "mutated_line": "jump = [[-1 for _ in range(n + -1)] for _ in range(n)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + -1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 2)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 2)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 0)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 0)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 0)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 0)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + -1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + -1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb | 1 << card == 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb | 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 1 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 1 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == -1 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == -1 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 1 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 1 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] != +1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != +1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] != +1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != +1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] - 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] - 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] * 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] * 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] != +1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != +1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] - 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] - 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] * 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] * 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i - 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i - 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i * 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i * 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(2 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(2 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(0 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(0 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(0 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(0 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(-1 << 8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(-1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 9)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 9)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 7)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 7)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 0)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 0)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << 1)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 1)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(1 << -8)] for _ in range(n + 1)]",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << -8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] != -2:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -2:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -0:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -0:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 1 << card == 0 and dp[i][comb] != --1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != --1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb + (2 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (2 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb + (0 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (0 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb + (0 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (0 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ncomb = comb + (1 << card)",
      "mutated_line": "ncomb = comb + (-1 << card)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (-1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] != -2:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -2:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -0:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -0:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if jump[i][val] != -1:",
      "mutated_line": "if jump[i][val] != --1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != --1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] + 2",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 2\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 0\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 0\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j = jump[i][val] + 1",
      "mutated_line": "j = jump[i][val] + -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + -1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] - val)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] - val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] * val)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] * val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val - 1] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val - 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val * 1] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val * 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] != -2:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -2:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -0:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] != -0:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -0:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 1] != --1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != --1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] + 2",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 2\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 0\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] + 0",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 0\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 1] + -1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + -1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val - 1)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val - 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], (dp[i][comb] + val) * 1)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], (dp[i][comb] + val) * 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 2][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 2][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 0][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 0][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 0][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 0][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + -1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + -1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i - 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i - 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i * 1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i * 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 2 << card == 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 2 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 0 << card == 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 0 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & 0 << card == 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 0 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if comb & 1 << card == 0 and dp[i][comb] != -1:",
      "mutated_line": "if comb & -1 << card == 0 and dp[i][comb] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & -1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 2] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 2] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 0] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 0] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + 0] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 0] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if jump[i][val + 1] != -1:",
      "mutated_line": "if jump[i][val + -1] != -1:",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + -1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val - 1] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val - 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val * 1] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val * 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] - val + 1)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] - val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] * val + 1)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] * val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 2)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 2)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 0)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 0)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 0)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 0)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)",
      "mutated_line": "dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + -1)",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + -1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i + 2][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 2][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i + 0][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 0][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i + 0][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 0][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])",
      "mutated_line": "dp[i + 1][comb] = max(dp[i + -1][comb], dp[i][comb])",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + -1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 2] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 2] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 0] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 0] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + 0] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + 0] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "j = jump[i][val + 1] + 1",
      "mutated_line": "j = jump[i][val + -1] + 1",
      "code": "import copy\n\ndef find_longest_valid_subsequence(n, cards):\n    a = [card - 1 for card in cards]\n    nextcard = [[-1 for _ in range(8)] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i + 1])\n        nextcard[i][a[i + 1]] = i + 1\n    jump = [[-1 for _ in range(n + 1)] for _ in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        while cpos != -1:\n            jump[i][j] = cpos\n            j += 1\n            cpos = nextcard[cpos][card]\n\n    def getLen(val):\n        dp = [[-1 for _ in range(1 << 8)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(n):\n            card = a[i]\n            for comb in range(1 << 8):\n                if comb & 1 << card == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1 << card)\n                    if jump[i][val] != -1:\n                        j = jump[i][val] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                    if jump[i][val + 1] != -1:\n                        j = jump[i][val + -1] + 1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n                dp[i + 1][comb] = max(dp[i + 1][comb], dp[i][comb])\n        return dp[n][(1 << 8) - 1]\n    appear = [False for _ in range(8)]\n    for c in a:\n        appear[c] = True\n    result = 0\n    for c in appear:\n        result += int(c)\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = 1 << lev\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n            if ret != -1:\n                result = max(result, ret)\n                cur += tpow\n    return result"
    }
  ]
}