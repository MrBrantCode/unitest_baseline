{
  "task_id": "taco_16025",
  "entry_point": "calculate_min_boat_rides",
  "mutant_count": 414,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][0] = 2",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 2\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 0\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 0\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][0] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = -1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][0] = 2",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 2\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 0\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 0\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][0] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = -1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][1] = 2",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 2\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 0\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 0\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][1] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = -1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][0] = 2",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 2\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 0\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 0\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][0] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = -1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 1\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][1] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = -1\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 1\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) >= 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) >= 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) <= 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) <= 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) != 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) != 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if min_rides == float('inf'):",
      "mutated_line": "return (-1, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides != float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] / 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] / 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] + 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] + 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] ** 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] ** 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][1] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][-1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][-1] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][1] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][1] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][-1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][-1] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[1][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][1] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][2] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][2] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][0] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][0] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[1][-1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][-1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(3, 51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(3, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(1, 51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(1, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(0, 51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(0, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(1, 51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(1, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(-2, 51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(-2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(2, 52):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 52):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(2, 50):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 50):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(2, 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 0):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(2, 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 1):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(2, 51):",
      "mutated_line": "for x in range(2, -51):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, -51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][1] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][-1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][-1] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][1] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][2] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][2] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][0] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][0] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][0][-1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][-1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 1:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > -1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > -1:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 1:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][1][2]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][2]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][1][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][0]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][1][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][0]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][1][-1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][-1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][1][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][1]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][1][-1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][-1]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][1][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][1]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((2 for i in weights if i == 50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((2 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((0 for i in weights if i == 50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((0 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((0 for i in weights if i == 50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((0 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((-1 for i in weights if i == 50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((-1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((2 for i in weights if i == 100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((2 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((0 for i in weights if i == 100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((0 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((0 for i in weights if i == 100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((0 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((-1 for i in weights if i == 100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((-1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 52 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 52 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 50 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 50 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 0 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 0 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 1 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 1 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * -51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * -51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[1][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[-1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[-1][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c[0][0] = 1",
      "mutated_line": "c[1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[1][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[2][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[2][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[0][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[0][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c[1][0] = 1",
      "mutated_line": "c[-1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[-1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[2][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[2][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[0][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[0][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[0][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c[1][1] = 1",
      "mutated_line": "c[-1][1] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[-1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x - 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x - 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x * 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x * 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] - c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] - c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] * c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] * c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][1][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][-1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][-1][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][0][1][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][1][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][1][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][1][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][-1][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][-1][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][0][1][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][1][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([1, 0, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([1, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([-1, 0, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([-1, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([1, 0, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([1, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, 1, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 1, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, -1, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, -1, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, 1, 0])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 1, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, 0, 1])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 1])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, 0, -1])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, -1])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([0, 0, 0])",
      "mutated_line": "q.append([0, 0, 1])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 1])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] -= d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] -= d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][2][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][2][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][0][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][0][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][0][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][0][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_rides = d[c50][c100][1][1]",
      "mutated_line": "min_rides = d[c50][c100][-1][1]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][-1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][2][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][2][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][0][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][0][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][0][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][0][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num_ways = d[c50][c100][1][0]",
      "mutated_line": "num_ways = d[c50][c100][-1][0]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][-1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if min_rides == float('inf'):",
      "mutated_line": "return (-1, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float(''):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (+1, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (+1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, 1)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 1)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, -1)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, -1)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, 1)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 1)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i != 50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i != 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i != 100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i != 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[1] * 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[1] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[-1] * 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[-1] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[1] * 51 for i in range(51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[1] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 51 for i in range(52)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(52)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 51 for i in range(50)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(50)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 51 for i in range(0)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(0)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 51 for i in range(1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(1)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * 51 for i in range(51)]",
      "mutated_line": "c = [[0] * 51 for i in range(-51)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(-51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x + 2):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 2):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 0):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 0):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for y in range(x + 1):",
      "mutated_line": "for y in range(x + -1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + -1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 - 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 - 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 * 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 * 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][1][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][1][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][-1][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][-1][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[0][1][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][1][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][1][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][1][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][-1][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][-1][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[0][1][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][1][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore != 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore != 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i - 1 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i - 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range((c50 - i) * 1 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range((c50 - i) * 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i - 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i - 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i * 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i * 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k and fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k and fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] >= d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] >= d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] <= d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] <= d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] != d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] != d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] <= d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] <= d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] >= d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] >= d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] != d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] != d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) / (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) / (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) + (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) + (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) ** (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) ** (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] / koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] / koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] + koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] + koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] ** koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] ** koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 - 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 - 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 * 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 * 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-2, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-2, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-0, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-0, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (-0, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-0, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1, 0",
      "mutated_line": "return (--1, 0)",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (--1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i == 51))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 51))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i == 49))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 49))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i == 0))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 0))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i == 1))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 1))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "c50 = sum(1 for i in weights if i == 50)",
      "mutated_line": "c50 = sum((1 for i in weights if i == -50))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == -50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i == 101))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 101))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i == 99))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 99))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i == 0))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 0))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i == 1))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 1))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "c100 = sum(1 for i in weights if i == 100)",
      "mutated_line": "c100 = sum((1 for i in weights if i == -100))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == -100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y + 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y + 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y * 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y * 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[-1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[-1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[1, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 - 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 - 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 * 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 * 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 2)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 2)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 0)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 0)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 0)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 0)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + -1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + -1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[1][0][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[1][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[-1][0][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[-1][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[0][0][0][0] = 1",
      "mutated_line": "d[1][0][0][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[1][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[1][0][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[1][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[-1][0][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[-1][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d[0][0][0][1] = 0",
      "mutated_line": "d[1][0][0][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[1][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 1 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 1 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == -1 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == -1 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 1 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 1 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 + i + 1 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 + i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 * i + 1 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 * i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 2 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 2 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 0 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 0 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 0 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 0 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + -1 if shore == 0 else i + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + -1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 2):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 2):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 0):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 0):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + 1):",
      "mutated_line": "for fifty in range(c50 - i + 1 if shore == 0 else i + -1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + -1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore != 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore != 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j - 1 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j - 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range((c100 - j) * 1 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range((c100 - j) * 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j - 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j - 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j * 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j * 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 >= k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 >= k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 <= k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 <= k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 != k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 != k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds != 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds != 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore != 0 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore != 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i - fifty if shore == 0 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i - fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i * fifty if shore == 0 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i * fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore == 0 else i + fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i + fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore == 0 else i * fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i * fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore != 0 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore != 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j - hundreds if shore == 0 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j - hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j * hundreds if shore == 0 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j * hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore == 0 else j + hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j + hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore == 0 else j * hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j * hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] - 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] - 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] * 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] * 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] - 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] - 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] * 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] * 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 1\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][0] = -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = -1\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][0] = 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 1\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] - 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] - 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] * 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] * 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][1] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][1] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][-1] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][-1] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][1] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][1] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][1] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][1] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][-1] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][-1] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][1] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][1] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 * 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 * 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 + 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 + 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 8",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 8\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 6",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 6\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 0\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 1\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + -7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + -7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x + 1][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x + 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x * 1][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x * 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 2] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 2] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 0] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 0] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 0] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 0] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - -1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - -1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x + 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x + 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x * 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x * 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(3)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(3)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(1)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(1)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(0)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(0)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(1)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(1)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(-2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(-2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 2)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 2)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 0)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 0)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 0)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 0)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]",
      "mutated_line": "d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + -1)] for j in range(c50 + 1)]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + -1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 1 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 1 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == -1 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == -1 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 1 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 1 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 + j + 1 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 + j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 * j + 1 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 * j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 2 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 2 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 0 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 0 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 0 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 0 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + -1 if shore == 0 else j + 1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + -1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 2):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 2):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 0):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 0):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 0):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):",
      "mutated_line": "for hundreds in range(c100 - j + 1 if shore == 0 else j + -1):",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + -1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 - hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 - hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 * (hundreds * 100) > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 * (hundreds * 100) > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty - hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty - hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty * hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty * hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 1:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == -1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == -1:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 1:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore == 1 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 1 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore == -1 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == -1 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i1 = i + fifty if shore == 0 else i - fifty",
      "mutated_line": "i1 = i + fifty if shore == 1 else i - fifty",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 1 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore == 1 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 1 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore == -1 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == -1 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j1 = j + hundreds if shore == 0 else j - hundreds",
      "mutated_line": "j1 = j + hundreds if shore == 1 else j - hundreds",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 1 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][2] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][2] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][0] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][0] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][0] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][0] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][-1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][-1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 2:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 2:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 0:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 0:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + -1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + -1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][2] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][2] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][0] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][0] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][0] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][0] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][-1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][-1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 2",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 2\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 0\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 0\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + -1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + -1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][1] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][-1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][-1] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][1] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][2] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][2] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][0] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][0] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][0] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][0] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][-1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][-1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 2:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 2:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 0:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 0:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + -1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + -1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore != 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore != 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore != 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore != 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 | shore][0] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 | shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][1] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][1] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][-1] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][-1] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][1] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][1] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 | shore][0] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 | shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 11 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 11 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 9 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 9 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 0 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 0 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 1 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 1 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= -10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= -10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 10 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 10 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 8 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 8 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 0 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 0 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 1 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 1 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][1 ^ shore][0] %= 10 ** -9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** -9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 2][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 2][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 0][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 0][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 0][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 0][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - -1][y - 1] + c[x - 1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - -1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x - 2][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 2][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x - 0][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 0][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x - 0][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 0][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c[x][y] = c[x - 1][y - 1] + c[x - 1][y]",
      "mutated_line": "c[x][y] = c[x - 1][y - 1] + c[x - -1][y]",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - -1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty / 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty / 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty + 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty + 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty ** 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty ** 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds / 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds / 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + (hundreds + 100) > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + (hundreds + 100) > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds ** 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds ** 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 | shore][1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 | shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][2] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][2] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][0] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][0] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][0] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][0] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][-1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][-1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 | shore][1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 | shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][2] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][2] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][0] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][0] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][0] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][0] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][-1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][-1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][1 | shore][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 | shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "q.append((i1, j1, 1 ^ shore))",
      "mutated_line": "q.append((i1, j1, 1 | shore))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 | shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 | shore][1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 | shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][2] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][2] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][0] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][0] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][0] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][0] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][-1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][-1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == -1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == -1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 1 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 1 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 1 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == -1 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == -1 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 1 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 1 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][2 ^ shore][0] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][2 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][0 ^ shore][0] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][0 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][0 ^ shore][0] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][0 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "mutated_line": "d[i1][j1][-1 ^ shore][0] += d[i][j][shore][0] * koeff",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][-1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][2 ^ shore][0] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][2 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][0 ^ shore][0] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][0 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][0 ^ shore][0] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][0 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7",
      "mutated_line": "d[i1][j1][-1 ^ shore][0] %= 10 ** 9 + 7",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][-1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 51 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 51 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 49 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 49 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 0 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 0 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 1 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 1 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * -50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * -50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 101 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 101 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 99 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 99 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 0 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 0 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * 1 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 1 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:",
      "mutated_line": "if fifty * 50 + hundreds * -100 > k or fifty + hundreds == 0:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * -100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][2 ^ shore][1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][2 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][0 ^ shore][1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][0 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][0 ^ shore][1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][0 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][-1 ^ shore][1] > d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][-1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][2 ^ shore][1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][2 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][0 ^ shore][1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][0 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][0 ^ shore][1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][0 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1",
      "mutated_line": "d[i1][j1][-1 ^ shore][1] = d[i][j][shore][1] + 1",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][-1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][2 ^ shore][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][2 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][0 ^ shore][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][0 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][0 ^ shore][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][0 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d[i1][j1][1 ^ shore][0] = 0",
      "mutated_line": "d[i1][j1][-1 ^ shore][0] = 0",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][-1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((i1, j1, 1 ^ shore))",
      "mutated_line": "q.append((i1, j1, 2 ^ shore))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 2 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((i1, j1, 1 ^ shore))",
      "mutated_line": "q.append((i1, j1, 0 ^ shore))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 0 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((i1, j1, 1 ^ shore))",
      "mutated_line": "q.append((i1, j1, 0 ^ shore))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 0 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((i1, j1, 1 ^ shore))",
      "mutated_line": "q.append((i1, j1, -1 ^ shore))",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, -1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][2 ^ shore][1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][2 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][0 ^ shore][1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][0 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][0 ^ shore][1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][0 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "mutated_line": "if d[i1][j1][-1 ^ shore][1] < d[i][j][shore][1] + 1:",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][-1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 + i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 + i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 * i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 * i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 + j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 + j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])",
      "mutated_line": "koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 * j][hundreds] if shore == 0 else c[j][hundreds])",
      "code": "from collections import deque\n\ndef calculate_min_boat_rides(n, k, weights):\n    c50 = sum((1 for i in weights if i == 50))\n    c100 = sum((1 for i in weights if i == 100))\n    c = [[0] * 51 for i in range(51)]\n    c[0][0] = 1\n    c[1][0] = 1\n    c[1][1] = 1\n    for x in range(2, 51):\n        for y in range(x + 1):\n            c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\n    d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n    d[0][0][0][0] = 1\n    d[0][0][0][1] = 0\n    q = deque()\n    q.append([0, 0, 0])\n    while len(q) > 0:\n        (i, j, shore) = q.popleft()\n        for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n            for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n                if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                    continue\n                i1 = i + fifty if shore == 0 else i - fifty\n                j1 = j + hundreds if shore == 0 else j - hundreds\n                if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                    d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                    d[i1][j1][1 ^ shore][0] = 0\n                    q.append((i1, j1, 1 ^ shore))\n                if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                    continue\n                koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (c[c100 * j][hundreds] if shore == 0 else c[j][hundreds])\n                d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n                d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\n    min_rides = d[c50][c100][1][1]\n    num_ways = d[c50][c100][1][0]\n    if min_rides == float('inf'):\n        return (-1, 0)\n    else:\n        return (min_rides, num_ways)"
    }
  ]
}