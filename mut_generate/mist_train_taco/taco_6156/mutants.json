{
  "task_id": "taco_6156",
  "entry_point": "count_distinct_ways",
  "mutant_count": 270,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M = 1000000007",
      "mutated_line": "M = 1000000008",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000008\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M = 1000000007",
      "mutated_line": "M = 1000000006",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000006\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M = 1000000007",
      "mutated_line": "M = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 0\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M = 1000000007",
      "mutated_line": "M = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M = 1000000007",
      "mutated_line": "M = -1000000007",
      "code": "def count_distinct_ways(n, m, k):\n    M = -1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "N = n * n",
      "mutated_line": "N = n / n",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n / n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "N = n * n",
      "mutated_line": "N = n + n",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n + n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "N = n * n",
      "mutated_line": "N = n ** n",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n ** n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] / (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] / (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] + (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] + (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] ** (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] ** (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[1] = 2",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 2\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[1] = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 0\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[1] = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 0\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[1] = -1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = -1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] / (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] / (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] + (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] + (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] ** (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] ** (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] / (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] / (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] + (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] + (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] ** (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] ** (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "left = m % n",
      "mutated_line": "",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m * n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "left = m % n",
      "mutated_line": "",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m + n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 2",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 2\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = -1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = -1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N - 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N - 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N * 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N * 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[2] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[2] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[0] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[0] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[0] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[0] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "iv[1] = 1",
      "mutated_line": "iv[-1] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[-1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(3, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(3, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(1, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(0, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(1, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(-2, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(-2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N - 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N - 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N * 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N * 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M + M // i * iv[M % i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M + M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M * (M // i * iv[M % i] % M)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M * (M // i * iv[M % i] % M)\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N - 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N - 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N * 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N * 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(2, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(0, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(0, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(-1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N - 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N * 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 1] * i * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i * M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 1] * i + M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i + M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N - 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N - 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N * 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N * 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(2, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(0, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(0, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(-1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N - 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N * 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 1] * iv[i] * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] * M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 1] * iv[i] + M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] + M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 1",
      "mutated_line": "r = 2",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 2\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 0\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 0\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 1",
      "mutated_line": "r = -1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = -1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p >= 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p >= 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p <= 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p <= 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p != 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p != 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] / (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] / (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] + (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] + (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] ** (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] ** (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][1] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][-1] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][-1] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][1] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [1] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [1] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [-1] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [-1] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [1] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [1] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N + 2)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 2)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 0)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 0)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "iv = [0] * (N + 1)",
      "mutated_line": "iv = [0] * (N + -1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + -1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 2):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 2):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 0):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 0):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + -1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + -1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M // i * iv[M % i] * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] * M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - (M // i * iv[M % i] + M)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - (M // i * iv[M % i] + M)\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [2] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [2] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [0] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [0] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [0] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [0] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [-1] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [-1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N + 2)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 2)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 0)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 0)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f1 = [1] * (N + 1)",
      "mutated_line": "f1 = [1] * (N + -1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + -1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 2):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 0):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 0):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + -1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 1] / i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] / i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = (f1[i - 1] + i) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = (f1[i - 1] + i) % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 1] ** i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] ** i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [2] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [2] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [0] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [0] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [0] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [0] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [-1] * (N + 1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [-1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N + 2)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 2)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 0)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N + 0)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 0)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f2 = [1] * (N + 1)",
      "mutated_line": "f2 = [1] * (N + -1)",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + -1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 2):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 0):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 0):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + -1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 1] / iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] / iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = (f2[i - 1] + iv[i]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = (f2[i - 1] + iv[i]) % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 1] ** iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] ** iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 1:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p > -1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > -1:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 1:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 >= 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 >= 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 <= 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 <= 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 != 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 != 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "b = b * b % M",
      "mutated_line": "b = b * b * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b * M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "b = b * b % M",
      "mutated_line": "b = b * b + M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b + M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p //= 2",
      "mutated_line": "p //= 3",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 3\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 1\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p //= 2",
      "mutated_line": "p //= 0",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 0\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 1\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p //= 2",
      "mutated_line": "p //= -2",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= -2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k - 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k - 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k * 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k * 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[1][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[-1][0] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[-1][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[1][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k - 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k - 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k * 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k * 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n and j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n and j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M // i / iv[M % i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i / iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - (M // i + iv[M % i]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - (M // i + iv[M % i]) % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - (M // i) ** iv[M % i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - (M // i) ** iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p * 2 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p * 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p + 2 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p + 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 > 1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 1:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 > -1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > -1:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 2 > 1:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 1:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = r * b % M",
      "mutated_line": "r = r * b * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b * M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = r * b % M",
      "mutated_line": "r = r * b + M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b + M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "b = b * b % M",
      "mutated_line": "b = b / b % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b / b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "b = b * b % M",
      "mutated_line": "b = (b + b) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = (b + b) % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "b = b * b % M",
      "mutated_line": "b = b ** b % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b ** b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] * M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] * M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] + M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] + M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n - i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n - i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n * i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n * i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(3)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(3)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(1)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(0)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(0)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(1)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(-2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(-2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[1] * (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[1] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[-1] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[1] * (k + 1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[1] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 2) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 2) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 0) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 0) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 0) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 0) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + -1) for i in range(n + 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + -1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n - 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n - 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n * 1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n * 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 2):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 2):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 0):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 0):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + -1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + -1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j >= i * n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j >= i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j <= i * n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j <= i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j != i * n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j != i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j <= k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j <= k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j >= k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j >= k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j != k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j != k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) - 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) - 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) * 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) * 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) * M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) * M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = dp[i + 1][j + l] + c[i < left][l] * dp[i][j] + M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = dp[i + 1][j + l] + c[i < left][l] * dp[i][j] + M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M / i * iv[M % i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M / i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M * i * iv[M % i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M * i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i + 1] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i + 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i * 1] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i * 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i + 1] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i + 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i * 1] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i * 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 3 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 3 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 1 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 1 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 0 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 0 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % 1 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 1 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if p % 2 > 0:",
      "mutated_line": "if p % -2 > 0:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % -2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = r * b % M",
      "mutated_line": "r = r / b % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r / b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = r * b % M",
      "mutated_line": "r = (r + b) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = (r + b) % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = r * b % M",
      "mutated_line": "r = r ** b % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r ** b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M / f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M / f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM((f1[n] * f2[j] % M + f2[n - j]) % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM((f1[n] * f2[j] % M + f2[n - j]) % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM((f1[n] * f2[j] % M) ** f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM((f1[n] * f2[j] % M) ** f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m / n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m / n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m * n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m * n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n - 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n - 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n * 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n * 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n + 2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 2)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n + 0)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 0)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n + 0)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 0)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[0] * (k + 1) for i in range(n + 1)]",
      "mutated_line": "dp = [[0] * (k + 1) for i in range(n + -1)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + -1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i / n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i / n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i + n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i + n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i ** n or j < k - (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i ** n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k + (n - i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k + (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k * ((n - i) * n):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k * ((n - i) * n):\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) + 2):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 2):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 0):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) + 0):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 0):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k - j) + -1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + -1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j - l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j - l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j * l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j * l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] - c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] - c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = dp[i + 1][j + l] * (c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = dp[i + 1][j + l] * (c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M // i * iv[M * i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M * i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "iv[i] = M - M // i * iv[M % i] % M",
      "mutated_line": "iv[i] = M - M // i * iv[M + i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M + i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 2] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 2] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 0] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 0] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - 0] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 0] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f1[i] = f1[i - 1] * i % M",
      "mutated_line": "f1[i] = f1[i - -1] * i % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - -1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 2] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 2] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 0] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 0] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - 0] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 0] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f2[i] = f2[i - 1] * iv[i] % M",
      "mutated_line": "f2[i] = f2[i - -1] * iv[i] % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - -1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] * M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] * M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM((f1[n] * f2[j] + M) * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM((f1[n] * f2[j] + M) * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 2)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 2)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 0)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 0)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 0)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 0)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + -1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + -1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k - (n - i) / n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) / n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k - (n - i + n):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i + n):\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k - (n - i) ** n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) ** n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k + j) + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k + j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(min(n, k - j) + 1):",
      "mutated_line": "for l in range(min(n, k * j) + 1):",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k * j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i - 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i - 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i * 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i * 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] / dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] / dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + (c[i < left][l] + dp[i][j])) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + (c[i < left][l] + dp[i][j])) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] ** dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] ** dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] / f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] / f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM((f1[n] + f2[j]) % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM((f1[n] + f2[j]) % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] ** f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] ** f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n + j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n + j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "mutated_line": "c = [[powM(f1[n] * f2[j] % M * f2[n * j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n * j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k - (n + i) * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n + i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if j > i * n or j < k - (n - i) * n:",
      "mutated_line": "if j > i * n or j < k - n * i * n:",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - n * i * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 2][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 2][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 0][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 0][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 0][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 0][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + -1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + -1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j - l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j - l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j * l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j * l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i - 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i - 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i * 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i * 1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 2][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 2][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 0][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 0][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 0][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 0][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + -1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + -1][j + l] + c[i < left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i <= left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i <= left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i >= left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i >= left][l] * dp[i][j]) % M\n    return dp[n][k]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i < left][l] * dp[i][j]) % M",
      "mutated_line": "dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i != left][l] * dp[i][j]) % M",
      "code": "def count_distinct_ways(n, m, k):\n    M = 1000000007\n    N = n * n\n    iv = [0] * (N + 1)\n    iv[1] = 1\n    for i in range(2, N + 1):\n        iv[i] = M - M // i * iv[M % i] % M\n    f1 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f1[i] = f1[i - 1] * i % M\n    f2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        f2[i] = f2[i - 1] * iv[i] % M\n    left = m % n\n\n    def powM(b, p):\n        r = 1\n        while p > 0:\n            if p % 2 > 0:\n                r = r * b % M\n            b = b * b % M\n            p //= 2\n        return r\n    c = [[powM(f1[n] * f2[j] % M * f2[n - j] % M, m // n + i) for j in range(n + 1)] for i in range(2)]\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if j > i * n or j < k - (n - i) * n:\n                continue\n            for l in range(min(n, k - j) + 1):\n                dp[i + 1][j + l] = (dp[i + 1][j + l] + c[i != left][l] * dp[i][j]) % M\n    return dp[n][k]"
    }
  ]
}