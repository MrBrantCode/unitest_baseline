{
  "task_id": "taco_6210",
  "entry_point": "count_beautiful_permutations",
  "mutant_count": 232,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "from functools import lru_cache\nmod = 10 ** 9 - 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "from functools import lru_cache\nmod = 10 ** 9 * 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "from functools import lru_cache\nmod = 10 * 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "from functools import lru_cache\nmod = 10 + 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 8\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 6\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 0\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 1\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + -7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) / 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) / 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) * 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) * 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n / 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n / 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n * 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n * 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[0] == 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] == 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "from functools import lru_cache\nmod = 11 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "from functools import lru_cache\nmod = 9 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "from functools import lru_cache\nmod = 0 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "from functools import lru_cache\nmod = 1 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "from functools import lru_cache\nmod = -10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "from functools import lru_cache\nmod = 10 ** 10 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "from functools import lru_cache\nmod = 10 ** 8 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "from functools import lru_cache\nmod = 10 ** 0 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "from functools import lru_cache\nmod = 10 ** 1 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "from functools import lru_cache\nmod = 10 ** -9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i >= n:",
      "mutated_line": "if i > n:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i > n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i >= n:",
      "mutated_line": "if i < n:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i < n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i >= n:",
      "mutated_line": "if i == n:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i == n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if permutation[i] != 0:",
      "mutated_line": "if permutation[i] == 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] == 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 1\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = -1\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 1\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens >= 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens >= 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens <= 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens <= 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens != 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens != 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans -= evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans -= evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds >= 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds >= 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds <= 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds <= 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds != 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds != 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans -= odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans -= odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return ans % mod",
      "mutated_line": "return ans * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans * mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return ans % mod",
      "mutated_line": "return ans + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans + mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n - 1) // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n - 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = n * 1 // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = n * 1 // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) // 3",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 3\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) // 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 1\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) // 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 0\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) // 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 1\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 1) // -2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // -2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n // 3",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 3\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n // 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 1\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n // 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 0\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n // 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 1\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "evens = n // 2",
      "mutated_line": "evens = n // -2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // -2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if v != 0:",
      "mutated_line": "if v == 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v == 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[0] != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 1:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[0] != -1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != -1:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[0] != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 1:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 1, k, 0) * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) * mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 1, k, 0) + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) + mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans - odds * f(1, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans - odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans * (odds * f(1, odds - 1, evens, k, 1) % mod)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans * (odds * f(1, odds - 1, evens, k, 1) % mod)\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return ans % mod",
      "mutated_line": "return ans * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans * mod"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return ans % mod",
      "mutated_line": "return ans + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans + mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if permutation[i] != 0:",
      "mutated_line": "if permutation[i] != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 1:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if permutation[i] != 0:",
      "mutated_line": "if permutation[i] != -1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != -1:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if permutation[i] != 0:",
      "mutated_line": "if permutation[i] != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 1:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) * mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) + mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens > 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 1:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens > -1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > -1:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if evens > 0:",
      "mutated_line": "if evens > 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 1:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) * mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) + mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds > 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 1:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds > -1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > -1:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if odds > 0:",
      "mutated_line": "if odds > 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 1:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) * mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) + mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) + mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 2) // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 2) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 0) // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 0) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + 0) // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 0) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "odds = (n + 1) // 2",
      "mutated_line": "odds = (n + -1) // 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + -1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v != 0:",
      "mutated_line": "if v != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 1:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v != 0:",
      "mutated_line": "if v != -1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != -1:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v != 0:",
      "mutated_line": "if v != 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 1:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v * 2:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v * 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v + 2:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v + 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "odds -= 1",
      "mutated_line": "odds += 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds += 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "evens -= 1",
      "mutated_line": "evens += 1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens += 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[1] != 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[1] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[-1] != 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[-1] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if permutation[0] != 0:",
      "mutated_line": "if permutation[1] != 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[1] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(2, odds, evens, k, permutation[0] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(2, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(0, odds, evens, k, permutation[0] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(0, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(0, odds, evens, k, permutation[0] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(0, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(-1, odds, evens, k, permutation[0] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(-1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] * 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] * 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] + 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] + 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens / f(1, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens / f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = (evens + f(1, odds, evens - 1, k, 0)) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = (evens + f(1, odds, evens - 1, k, 0)) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens ** f(1, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens ** f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) * mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) * mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + (odds * f(1, odds - 1, evens, k, 1) + mod)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + (odds * f(1, odds - 1, evens, k, 1) + mod)\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return int(K == 1)",
      "mutated_line": "return int(K != 1)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K != 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens / f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens / f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += (evens + f(i + 1, odds, evens - 1, K - (prev != 0), 0)) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += (evens + f(i + 1, odds, evens - 1, K - (prev != 0), 0)) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens ** f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens ** f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds / f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds / f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += (odds + f(i + 1, odds - 1, evens, K - (prev != 1), 1)) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += (odds + f(i + 1, odds - 1, evens, K - (prev != 1), 1)) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds ** f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds ** f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 3:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 3:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 1:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 0:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 0:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 1:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 1:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v % 2:",
      "mutated_line": "if v % -2:",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % -2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "odds -= 1",
      "mutated_line": "odds -= 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 2\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "odds -= 1",
      "mutated_line": "odds -= 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 0\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "odds -= 1",
      "mutated_line": "odds -= 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 0\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "odds -= 1",
      "mutated_line": "odds -= -1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= -1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "evens -= 1",
      "mutated_line": "evens -= 2",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 2\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "evens -= 1",
      "mutated_line": "evens -= 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 0\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "evens -= 1",
      "mutated_line": "evens -= 0",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 0\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "evens -= 1",
      "mutated_line": "evens -= -1",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= -1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] % 3)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 3)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] % 1)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 1)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] % 0)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 0)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] % 1)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 1)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[0] % -2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % -2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds / f(1, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds / f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + (odds + f(1, odds - 1, evens, k, 1)) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + (odds + f(1, odds - 1, evens, k, 1)) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds ** f(1, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds ** f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(K == 1)",
      "mutated_line": "return int(K == 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 2)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(K == 1)",
      "mutated_line": "return int(K == 0)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 0)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(K == 1)",
      "mutated_line": "return int(K == 0)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 0)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(K == 1)",
      "mutated_line": "return int(K == -1)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == -1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i - 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i - 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i * 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i * 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K + (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K + (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K * (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K * (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] * 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] * 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] + 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] + 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[1] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[1] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[-1] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[-1] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f(1, odds, evens, k, permutation[0] % 2)",
      "mutated_line": "return f(1, odds, evens, k, permutation[1] % 2)",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[1] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(2, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(2, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(0, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(0, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(0, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(0, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(-1, odds, evens - 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(-1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens + 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens + 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens * 1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens * 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 1, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 1) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 1, k, -1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, -1) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 1, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 1) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 2, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 2, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 0, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 0, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 0, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 0, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + -1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + -1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev == permutation[i] % 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev == permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 3) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 3) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 1) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 0) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 1) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % -2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % -2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i - 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i - 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i * 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i * 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens + 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens + 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens * 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens * 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K + (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K + (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K * (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K * (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 1) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), -1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), -1) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 1) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i - 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i - 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i * 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i * 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds + 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds + 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds * 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds * 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K + (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K + (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K * (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K * (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 2) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 0) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 0) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), -1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), -1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 2, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 2, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 0, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 0, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - 0, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 0, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = evens * f(1, odds, evens - 1, k, 0) % mod",
      "mutated_line": "ans = evens * f(1, odds, evens - -1, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - -1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(2, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(2, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(0, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(0, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(0, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(0, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(-1, odds - 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(-1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds + 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds + 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds * 1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds * 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 1, evens, k, 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 2) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 1, evens, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 0) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 1, evens, k, 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 0) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 1, evens, k, -1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, -1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] * 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] * 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] + 2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] + 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 2, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 2, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 0, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 0, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 0, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 0, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + -1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + -1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 2, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 2, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 0, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 0, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 0, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 0, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - -1, K - (prev != 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - -1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev == 0), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev == 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 2, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 2, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 0, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 0, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 0, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 0, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + -1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + -1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 2, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 2, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 0, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 0, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 0, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 0, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - -1, evens, K - (prev != 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - -1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev == 1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev == 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 2, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 2, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 0, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 0, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - 0, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 0, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod",
      "mutated_line": "ans = ans + odds * f(1, odds - -1, evens, k, 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - -1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 3), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 3), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 1), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 1), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 0), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 0), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 1), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 1), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod",
      "mutated_line": "return f(i + 1, odds, evens, K - (prev != permutation[i] % -2), permutation[i] % 2) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % -2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 1), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 1), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != -1), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != -1), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod",
      "mutated_line": "ans += evens * f(i + 1, odds, evens - 1, K - (prev != 1), 0) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 1), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 2), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 2), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 0), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 0), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 0), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != 0), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != 1), 1) % mod",
      "mutated_line": "ans += odds * f(i + 1, odds - 1, evens, K - (prev != -1), 1) % mod",
      "code": "from functools import lru_cache\nmod = 10 ** 9 + 7\n\ndef count_beautiful_permutations(n, k, permutation):\n\n    @lru_cache(maxsize=None)\n    def f(i, odds, evens, K, prev):\n        if i >= n:\n            return int(K == 1)\n        if permutation[i] != 0:\n            return f(i + 1, odds, evens, K - (prev != permutation[i] % 2), permutation[i] % 2) % mod\n        ans = 0\n        if evens > 0:\n            ans += evens * f(i + 1, odds, evens - 1, K - (prev != 0), 0) % mod\n        if odds > 0:\n            ans += odds * f(i + 1, odds - 1, evens, K - (prev != -1), 1) % mod\n        return ans % mod\n    odds = (n + 1) // 2\n    evens = n // 2\n    for v in permutation:\n        if v != 0:\n            if v % 2:\n                odds -= 1\n            else:\n                evens -= 1\n    if permutation[0] != 0:\n        return f(1, odds, evens, k, permutation[0] % 2)\n    else:\n        ans = evens * f(1, odds, evens - 1, k, 0) % mod\n        f.cache_clear()\n        ans = ans + odds * f(1, odds - 1, evens, k, 1) % mod\n        return ans % mod"
    }
  ]
}