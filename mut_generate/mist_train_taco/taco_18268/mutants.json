{
  "task_id": "taco_18268",
  "entry_point": "process_permutations",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] + 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] + 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] * 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] * 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] / n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] / n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] + n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] + n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] ** n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] ** n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 2\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 0\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 0\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = -1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while i <= n:",
      "mutated_line": "while i < n:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i < n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while i <= n:",
      "mutated_line": "while i > n:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i > n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while i <= n:",
      "mutated_line": "while i == n:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i == n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [0] / n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] / n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [0] + n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] + n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [0] ** n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] ** n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [0] / n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] / n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [0] + n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] + n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [0] ** n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] ** n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "no_of_permutations = 0",
      "mutated_line": "no_of_permutations = 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 1\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "no_of_permutations = 0",
      "mutated_line": "no_of_permutations = -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = -1\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "no_of_permutations = 0",
      "mutated_line": "no_of_permutations = 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 1\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 2\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 0\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 0\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - -1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i - 1"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i * 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n = test_case['N']",
      "mutated_line": "n = test_case['']",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = test_case['A']",
      "mutated_line": "a = test_case['']",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = test_case['P']",
      "mutated_line": "p = test_case['']",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "q = test_case['Q']",
      "mutated_line": "q = test_case['']",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operations = test_case['operations']",
      "mutated_line": "operations = test_case['']",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] != 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] != 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "no_of_permutations += 1",
      "mutated_line": "no_of_permutations -= 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations -= 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] + k % m] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] + k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] * (k % m)] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] * (k % m)] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [True] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [True] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i - 1] = False",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = False\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "while j != i:",
      "mutated_line": "while j == i:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j == i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 2"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 0"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 0"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [1] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [-1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [-1] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cycle = [0] * n",
      "mutated_line": "cycle = [1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [1] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [1] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [-1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [-1] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index_in_cycle = [0] * n",
      "mutated_line": "index_in_cycle = [1] * n",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [1] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 2:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 0:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 0:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == -1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == -1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "no_of_permutations += 1",
      "mutated_line": "no_of_permutations += 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 2\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "no_of_permutations += 1",
      "mutated_line": "no_of_permutations += 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 0\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "no_of_permutations += 1",
      "mutated_line": "no_of_permutations += 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 0\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "no_of_permutations += 1",
      "mutated_line": "no_of_permutations += -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += -1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] != 2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] != 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k * m] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k * m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1",
      "mutated_line": "return cycles[cycle[ind]][index_in_cycle[ind] - (k + m)] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - (k + m)] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i + 1]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i + 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i * 1]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i * 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i + 1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i + 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i * 1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i * 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i + 1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i + 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i * 1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i * 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j - 1] = False",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = False\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c + 1] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c + 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c * 1] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c * 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c + 1] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c + 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c * 1] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c * 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[1] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[-1] == 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[-1] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[1] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 3:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 3:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 1:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 0:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 0:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 1:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == -2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == -2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] + 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] + 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] * 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] * 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] + 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] + 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] * 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] * 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] + 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] + 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] * 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] * 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i - 2]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 2]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i - 0]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 0]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i - 0]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 0]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not visited[i - 1]:",
      "mutated_line": "if not visited[i - -1]:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - -1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i - 2] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 2] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i - 0] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 0] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i - 0] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 0] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "visited[i - 1] = True",
      "mutated_line": "visited[i - -1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - -1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i - 2]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 2]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i - 0]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 0]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i - 0]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 0]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "j = p[i - 1]",
      "mutated_line": "j = p[i - -1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - -1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j + 1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j + 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j * 1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j * 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j + 1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j + 1]\n        i = i + 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j * 1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j * 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c - 2] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 2] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c - 0] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 0] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c - 0] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 0] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cycle[c - 1] = i",
      "mutated_line": "cycle[c - -1] = i",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - -1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c - 2] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 2] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c - 0] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 0] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c - 0] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 0] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "index_in_cycle[c - 1] = j",
      "mutated_line": "index_in_cycle[c - -1] = j",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - -1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[1] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[-1] == 2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[-1] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[1] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] - 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 2\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 0\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 0\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[1] - -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - -1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] - 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 2\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 0\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 0\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[2] - -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - -1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] - 2",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 2\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 0\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] - 0",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 0\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[1] - -1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - -1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j - 2] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 2] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j - 0] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 0] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j - 0] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 0] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "visited[j - 1] = True",
      "mutated_line": "visited[j - -1] = True",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - -1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j - 2]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 2]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j - 0]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 0]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j - 0]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 0]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "j = p[j - 1]",
      "mutated_line": "j = p[j - -1]",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - -1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[2] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[2] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[0] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[0] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[0] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[0] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = query[1] - 1",
      "mutated_line": "x = query[-1] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[-1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[3] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[3] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[1] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[1] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[0] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[0] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[1] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[1] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "y = query[2] - 1",
      "mutated_line": "y = query[-2] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[-2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[2] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[2] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[0] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[0] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[0] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[0] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ind = query[1] - 1",
      "mutated_line": "ind = query[-1] - 1",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[-1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "UOI",
      "lineno": 58,
      "original_line": "cycles[-1].append(j)",
      "mutated_line": "cycles[+1].append(j)",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[+1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "cycles[-1].append(j)",
      "mutated_line": "cycles[-2].append(j)",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-2].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "cycles[-1].append(j)",
      "mutated_line": "cycles[-0].append(j)",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-0].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "cycles[-1].append(j)",
      "mutated_line": "cycles[-0].append(j)",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[-0].append(j)\n                j = p[j - 1]\n        i = i + 1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "cycles[-1].append(j)",
      "mutated_line": "cycles[--1].append(j)",
      "code": "def process_permutations(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        n = test_case['N']\n        a = test_case['A']\n        p = test_case['P']\n        q = test_case['Q']\n        operations = test_case['operations']\n        cycles = []\n        cycle = [0] * n\n        index_in_cycle = [0] * n\n        determine_cycles(p, n, cycles)\n        no_of_cycles = len(cycles)\n        for i in range(no_of_cycles):\n            cycle_i = cycles[i]\n            for j in range(len(cycle_i)):\n                c = cycles[i][j]\n                cycle[c - 1] = i\n                index_in_cycle[c - 1] = j\n        no_of_permutations = 0\n        test_results = []\n        for query in operations:\n            if query[0] == 1:\n                no_of_permutations += 1\n            elif query[0] == 2:\n                x = query[1] - 1\n                y = query[2] - 1\n                x1 = get_value(no_of_permutations, x, cycles, cycle, index_in_cycle)\n                y1 = get_value(no_of_permutations, y, cycles, cycle, index_in_cycle)\n                (a[x1], a[y1]) = (a[y1], a[x1])\n            else:\n                ind = query[1] - 1\n                test_results.append(a[get_value(no_of_permutations, ind, cycles, cycle, index_in_cycle)])\n        results.append(test_results)\n    return results\n\ndef get_value(k, ind, cycles, cycle, index_in_cycle):\n    m = len(cycles[cycle[ind]])\n    return cycles[cycle[ind]][index_in_cycle[ind] - k % m] - 1\n\ndef determine_cycles(p, n, cycles):\n    visited = [False] * n\n    i = 1\n    while i <= n:\n        if not visited[i - 1]:\n            visited[i - 1] = True\n            cycles.append([i])\n            j = p[i - 1]\n            while j != i:\n                visited[j - 1] = True\n                cycles[--1].append(j)\n                j = p[j - 1]\n        i = i + 1"
    }
  ]
}