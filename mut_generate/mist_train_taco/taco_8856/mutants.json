{
  "task_id": "taco_8856",
  "entry_point": "minimize_max_overshoot",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "late += minLeft",
      "mutated_line": "late -= minLeft",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late -= minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 1\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "time = 0",
      "mutated_line": "time = -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = -1\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 1\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "length = 0",
      "mutated_line": "length = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 1\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "length = 0",
      "mutated_line": "length = -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = -1\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "length = 0",
      "mutated_line": "length = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 1\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "late = 0",
      "mutated_line": "late = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 1\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "late = 0",
      "mutated_line": "late = -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = -1\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "late = 0",
      "mutated_line": "late = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 1\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(array) == 1:",
      "mutated_line": "if len(array) != 1:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) != 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "si = 0",
      "mutated_line": "si = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 1\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "si = 0",
      "mutated_line": "si = -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = -1\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "si = 0",
      "mutated_line": "si = 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 1\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) + 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) + 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) * 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) * 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if si == ei:",
      "mutated_line": "if si != ei:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si != ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if length < deadline:",
      "mutated_line": "if length <= deadline:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length <= deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if length < deadline:",
      "mutated_line": "if length >= deadline:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length >= deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if length < deadline:",
      "mutated_line": "if length != deadline:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length != deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if index != None:",
      "mutated_line": "if index == None:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index == None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 or array or array[0] < deadline:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 or array or array[0] < deadline:\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft += 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft += 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(array) == 1:",
      "mutated_line": "if len(array) == 2:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 2:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(array) == 1:",
      "mutated_line": "if len(array) == 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 0:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(array) == 1:",
      "mutated_line": "if len(array) == 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 0:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(array) == 1:",
      "mutated_line": "if len(array) == -1:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == -1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number >= array[0]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number >= array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number <= array[0]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number <= array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number != array[0]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number != array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) - 2",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 2\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) - 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 0\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) - 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 0\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ei = len(array) - 1",
      "mutated_line": "ei = len(array) - -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - -1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if number >= array[si]:",
      "mutated_line": "if number > array[si]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number > array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if number >= array[si]:",
      "mutated_line": "if number < array[si]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number < array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if number >= array[si]:",
      "mutated_line": "if number == array[si]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number == array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 2 - si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 - si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 2 * si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 * si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if number > array[middle]:",
      "mutated_line": "if number >= array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number >= array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if number > array[middle]:",
      "mutated_line": "if number <= array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number <= array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if number > array[middle]:",
      "mutated_line": "if number != array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number != array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline + 1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline + 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline * 1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline * 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 or minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 or minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "index -= 1",
      "mutated_line": "index += 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index += 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft += 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft += 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft >= 0 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft >= 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft <= 0 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft <= 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft != 0 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft != 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[0] <= deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] <= deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[0] >= deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] >= deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[0] != deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] != deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 2",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 2\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 0\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 0\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= -1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 1\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return -1\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 1\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si + 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si + 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si * 1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si * 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) / 2 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) / 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) * 2 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) * 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif number < array[middle]:",
      "mutated_line": "elif number <= array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number <= array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif number < array[middle]:",
      "mutated_line": "elif number >= array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number >= array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif number < array[middle]:",
      "mutated_line": "elif number != array[middle]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number != array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(deadline - length):",
      "mutated_line": "for i in range(deadline + length):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline + length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(deadline - length):",
      "mutated_line": "for i in range(deadline * length):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline * length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline - 2)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 2)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline - 0)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 0)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline - 0)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 0)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "index = returnIndex(array, deadline - 1)",
      "mutated_line": "index = returnIndex(array, deadline - -1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - -1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index > 0 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index > 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index < 0 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index < 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index == 0 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index == 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft >= 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft >= 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft <= 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft <= 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft != 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft != 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "index -= 1",
      "mutated_line": "index -= 2",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 2\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "index -= 1",
      "mutated_line": "index -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 0\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "index -= 1",
      "mutated_line": "index -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 0\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "index -= 1",
      "mutated_line": "index -= -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= -1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 2",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 2\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 0\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 0\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "minLeft -= 1",
      "mutated_line": "minLeft -= -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= -1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 1 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 1 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > -1 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > -1 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 1 and array and (array[0] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 1 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "array.pop(0)",
      "mutated_line": "array.pop(1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(1)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "array.pop(0)",
      "mutated_line": "array.pop(-1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(-1)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "array.pop(0)",
      "mutated_line": "array.pop(1)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(1)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number > array[1]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[1]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number > array[-1]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[-1]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if number > array[0]:",
      "mutated_line": "if number > array[1]:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[1]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si - 2",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 2\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si - 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 0\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si - 0",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 0\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return si - 1",
      "mutated_line": "return si - -1",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - -1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei + si) // 2 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei + si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = ei * si // 2 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = ei * si // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 3 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 3 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 1 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 1 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 0 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 0 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // 1 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 1 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "middle = (ei - si) // 2 + si",
      "mutated_line": "middle = (ei - si) // -2 + si",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // -2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle - 1, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle - 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle * 1, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle * 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "array.append(i + length)",
      "mutated_line": "array.append(i - length)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i - length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "array.append(i + length)",
      "mutated_line": "array.append(i * length)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i * length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 1 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 1 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= -1 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= -1 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 1 and minLeft > 0:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 1 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft > 1:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 1:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft > -1:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > -1:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while index >= 0 and minLeft > 0:",
      "mutated_line": "while index >= 0 and minLeft > 1:",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 1:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[1] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[1] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[-1] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[-1] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while minLeft > 0 and array and (array[0] < deadline):",
      "mutated_line": "while minLeft > 0 and array and (array[1] < deadline):",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[1] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle + 2, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 2, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle + 0, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 0, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle + 0, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + 0, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return binarySearch(array, number, middle + 1, ei)",
      "mutated_line": "return binarySearch(array, number, middle + -1, ei)",
      "code": "def minimize_max_overshoot(tasks):\n\n    def returnIndex(array, number):\n        if not array:\n            return None\n        if len(array) == 1:\n            if number > array[0]:\n                return 0\n            else:\n                return None\n        si = 0\n        ei = len(array) - 1\n        return binarySearch(array, number, si, ei)\n\n    def binarySearch(array, number, si, ei):\n        if si == ei:\n            if number >= array[si]:\n                return si\n            else:\n                return si - 1\n        else:\n            middle = (ei - si) // 2 + si\n            if number > array[middle]:\n                return binarySearch(array, number, middle + -1, ei)\n            elif number < array[middle]:\n                return binarySearch(array, number, si, middle)\n            else:\n                return middle\n\n    def addJob(length, array, deadline, minutes, late):\n        if length < deadline:\n            for i in range(deadline - length):\n                array.append(i + length)\n            length = deadline\n        minLeft = minutes\n        index = returnIndex(array, deadline - 1)\n        if index != None:\n            while index >= 0 and minLeft > 0:\n                array.pop(index)\n                index -= 1\n                minLeft -= 1\n        while minLeft > 0 and array and (array[0] < deadline):\n            array.pop(0)\n            minLeft -= 1\n        late += minLeft\n        return (late, length)\n    time = 0\n    length = 0\n    nl = []\n    late = 0\n    results = []\n    for (deadline, minutes) in tasks:\n        (late, length) = addJob(length, nl, deadline, minutes, late)\n        results.append(late)\n    return results"
    }
  ]
}