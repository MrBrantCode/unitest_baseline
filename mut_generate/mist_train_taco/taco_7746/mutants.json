{
  "task_id": "taco_7746",
  "entry_point": "get_cell_color_at_iteration",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = False",
      "mutated_line": "f = True",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = True\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ss = 1",
      "mutated_line": "ss = 2",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 2\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ss = 1",
      "mutated_line": "ss = 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 0\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ss = 1",
      "mutated_line": "ss = 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 0\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ss = 1",
      "mutated_line": "ss = -1",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = -1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "ss += 1",
      "mutated_line": "ss -= 1",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss -= 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[0] / m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] / m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[0] + m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] + m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[0] ** m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] ** m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ss += 1",
      "mutated_line": "ss += 2",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 2\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ss += 1",
      "mutated_line": "ss += 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 0\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ss += 1",
      "mutated_line": "ss += 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 0\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ss += 1",
      "mutated_line": "ss += -1",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += -1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if initial_grid[i][j] == '1':",
      "mutated_line": "if initial_grid[i][j] != '1':",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] != '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[1] * m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[1] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[-1] * m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[-1] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "X = [[0] * m for _ in range(n)]",
      "mutated_line": "X = [[1] * m for _ in range(n)]",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[1] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n or 0 <= b < m or initial_grid[a][b] == c:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n or 0 <= b < m or initial_grid[a][b] == c:\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n or 0 <= b < m or X[a][b] == 0:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n or 0 <= b < m or X[a][b] == 0:\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i + 1, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i + 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i * 1, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i * 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j + 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j * 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j * 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(1, p - X[i][j] + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(1, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(-1, p - X[i][j] + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(-1, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(1, p - X[i][j] + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(1, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p - X[i][j] - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] - 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, (p - X[i][j]) * 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, (p - X[i][j]) * 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if initial_grid[i][j] == '1':",
      "mutated_line": "if initial_grid[i][j] == '':",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 < a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 < a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 > a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 > a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 == a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 == a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 0 < b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 < b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 0 > b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 > b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 0 == b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 == b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] != c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] != c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X[i][j] = 1",
      "mutated_line": "X[i][j] = 2",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 2\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X[i][j] = 1",
      "mutated_line": "X[i][j] = 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 0\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X[i][j] = 1",
      "mutated_line": "X[i][j] = 0",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 0\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X[i][j] = 1",
      "mutated_line": "X[i][j] = -1",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = -1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = True",
      "mutated_line": "f = False",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = False\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 < a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 < a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 > a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 > a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 == a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 == a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 < b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 < b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 > b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 > b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 == b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 == b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 <= b < m and (X[a][b] != 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] != 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 2, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 2, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 0, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 0, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 0, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 0, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - -1, j - 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - -1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 2)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 0)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 0)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - -1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - -1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p + X[i][j] + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p + X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p * X[i][j] + 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p * X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p - X[i][j] + 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 2)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p - X[i][j] + 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 0)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p - X[i][j] + 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 0)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f = max(0, p - X[i][j] + 1)",
      "mutated_line": "f = max(0, p - X[i][j] + -1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + -1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 + f % 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 + f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 * (f % 2))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 * (f % 2))\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f * 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f * 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f + 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f + 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if -1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if -1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 1 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 1 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 1 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and -1 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and -1 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= a < n and 0 <= b < m and initial_grid[a][b] == c:",
      "mutated_line": "if 0 <= a < n and 1 <= b < m and (initial_grid[a][b] == c):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 1 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:",
      "mutated_line": "for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)]:",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 1 <= a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 1 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if -1 <= a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if -1 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 1 <= a < n and 0 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 1 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 1 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 1 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and -1 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and -1 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 1 <= b < m and (X[a][b] == 0):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 1 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 <= b < m and (X[a][b] == 1):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 1):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 <= b < m and (X[a][b] == -1):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == -1):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= a < n and 0 <= b < m and X[a][b] == 0:",
      "mutated_line": "if 0 <= a < n and 0 <= b < m and (X[a][b] == 1):",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 1):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j + 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j + 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j * 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j * 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(2 - f % 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(2 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(0 - f % 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(0 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(0 - f % 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(0 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(-1 - f % 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(-1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f * 2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f * 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - (f + 2))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - (f + 2))\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f % 3)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 3)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f % 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f % 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f % 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results.append(f % 2)",
      "mutated_line": "results.append(f % -2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % -2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i + 1][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i + 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i * 1][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i * 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j - 2]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 2]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j - 0]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 0]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j - 0]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 0]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 1][j - -1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - -1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f % 3)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 3)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f % 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 1)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f % 0)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 0)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f % 1)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 1)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(1 - f % 2)",
      "mutated_line": "results.append(1 - f % -2)",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % -2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 2][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 2][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 0][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 0][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - 0][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - 0][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(int(initial_grid[i - 1][j - 1]))",
      "mutated_line": "results.append(int(initial_grid[i - -1][j - 1]))",
      "code": "def get_cell_color_at_iteration(n, m, initial_grid, queries):\n    X = [[0] * m for _ in range(n)]\n    stack = []\n    f = False\n    for i in range(n):\n        for j in range(m):\n            c = initial_grid[i][j]\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (initial_grid[a][b] == c):\n                    X[i][j] = 1\n                    stack.append((i, j))\n                    f = True\n                    break\n    ss = 1\n    while stack:\n        tmp = []\n        ss += 1\n        while stack:\n            (i, j) = stack.pop()\n            for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= a < n and 0 <= b < m and (X[a][b] == 0):\n                    X[a][b] = ss\n                    tmp.append((a, b))\n        stack = tmp\n    results = []\n    if not f:\n        for (i, j, p) in queries:\n            results.append(int(initial_grid[i - -1][j - 1]))\n    else:\n        for (i, j, p) in queries:\n            (i, j) = (i - 1, j - 1)\n            f = max(0, p - X[i][j] + 1)\n            if initial_grid[i][j] == '1':\n                results.append(1 - f % 2)\n            else:\n                results.append(f % 2)\n    return results"
    }
  ]
}